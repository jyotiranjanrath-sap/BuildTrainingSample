const logger = require('../../../logger');
const path = require('path');
const fs = require('fs-extra');
const loaderUtils = require('loader-utils');
const schemaUtils = require('schema-utils');
const _ = require('lodash');

const schema = {
  type: 'object',
  properties: {
  fragmentsPath: {
    type: 'string',
  },
  },
};

const CIMs ={
  loaded: false,
  points:[]
}

function initCimFragment(sRoot, sProject) {
  if (!CIMs.loaded) {
    CIMs.loaded=true;  
    let aCims = [];
    const sProjectPath = path.join(sRoot,sProject);
    if (fs.existsSync(sProjectPath)) {
      aCims = fs.readdirSync(sProjectPath).filter((sFile) => {
        if (sFile.endsWith('.cim')) {
          return sFile;
        }
      });
    }

    aCims.forEach((sCim) => {
      const oCim = fs.readJSONSync(path.join(sProjectPath, sCim));
      CIMs.points = CIMs.points.concat(oCim.IntegrationPoints ? oCim.IntegrationPoints : []);
    });
  }
}

function getSourceFragment(sFragment) {
  try {
    const oPoint = CIMs.points.find((oPoint) => {
      return oPoint.Target === sFragment;
    });
    return oPoint ? oPoint.Source : sFragment;
  } catch (e) {
    return sFragment;
  }
}

function hasFragment(content) {
  const regexp = /\"([\/\-_a-zA-Z0-9\.]*\.fragment)\"/g;
  return regexp.test(content);
}
function hasComplexFragment(content) {
  // has overriding or parameter
  const regexp = /\"_Type\":\s*\"Fragment\"/g;
  return regexp.test(content);
}
function resolveFragment(dir, content) {
  if (hasComplexFragment(content)) {
    const obj = JSON.parse(content);
    resolveComplexFragment(dir, obj);
    content = JSON.stringify(obj);
  }

  const regexp = /\"([\/\-_a-zA-Z0-9\.]*\.fragment)\"/g;
  const output = content.replace(regexp, function(i, match) {
    console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('resolving fragment ') + logger.getInfoMore(match));
    const sSourceFragment = getSourceFragment(match);
    const sPath = path.join(dir, sSourceFragment);
    let fragmentContent = fs.readFileSync(sPath, 'utf8');
    if (hasFragment(fragmentContent)) {
      return resolveFragment(dir, fragmentContent);
    }
    return fragmentContent;
  });

  return output;
}
function overrideNamedProperties(obj, properties) {
  if (Object.keys(properties).length > 0) {
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        const value = obj[key];
        if (value && typeof value === "object") {
          if (value.hasOwnProperty("_Name")) {
            const name = value["_Name"];
            for (const n in properties) {
              if (properties.hasOwnProperty(n) && n === name) {
                obj[key] = _.merge(value, properties[n]);
                delete properties[n];
              }
            }
          }
          overrideNamedProperties(value, properties);
        }
      }
    }
  }
}
function removeNullProperties(obj) {
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      const value = obj[key];
      if (value === null) {
        delete obj[key];
      } else if (value && typeof value === "object") {
        removeNullProperties(value);
      }
    }
  }
  return obj;
};
function resolveComplexFragment(dir, obj) {
  let tempParent = {
    obj: obj
  };

  resolveComplexFragmentObject(dir, obj, 'obj', tempParent, false);
  if (tempParent.obj !== obj && Object.keys(tempParent.obj).length > 0) {
    for(var k in obj) delete obj[k];
    for(var k in tempParent.obj) obj[k] = tempParent.obj[k];
  }
  
  for (let property in obj) {
    if (obj.hasOwnProperty(property)) {
      const value = obj[property];
      if (value && typeof value === "object") {
        resolveComplexFragmentObject(dir, value, property, obj, true);
      }
    }
  }
}

function resolveComplexFragmentObject(dir, value, property, parent, recursive) {
  if (value.hasOwnProperty("_Type") && value["_Type"] === "Fragment") {
    const fragmentPath = value.Fragment;
    console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('resolving complex fragment ') + logger.getInfoMore(fragmentPath));
    const sSourceFragment = getSourceFragment(fragmentPath);
    const sPath = path.join(dir, sSourceFragment);
    let fragmentContent = fs.readFileSync(sPath, 'utf8');

    if (hasFragment(fragmentContent)) {
      fragmentContent = resolveFragment(dir, fragmentContent);
    }
    const properties = value.Properties;
    const namedProperties = {};
    const indexedProperties = {};
    for (const key in properties) {
      if (properties.hasOwnProperty(key)) {
        if (key.startsWith("#Index:")) {
          indexedProperties[key] = properties[key];
          delete properties[key];
        } else if (key.startsWith("#Name:")) {
          const name = key.substring(6);
          namedProperties[name] = properties[key];
          delete properties[key];
        }
      }
    }
    // 1. merge new properties
    const fragmentObj = _.merge(JSON.parse(fragmentContent), properties);
    // 2. override properties by name
    overrideNamedProperties(fragmentObj, namedProperties);
    const names = Object.keys(namedProperties);
    if (names.length > 0) {
      // still have unfound properties
      throw new Error('Cannot find properties: ' + JSON.stringify(names));
    }
    // 3. override propertier by index
    // 4. remove all null properties
    parent[property] = removeNullProperties(fragmentObj);
  } else if (recursive && hasComplexFragment(JSON.stringify(value))) {
    resolveComplexFragment(dir, value);
  }
}

module.exports = function(source) {
  const options = loaderUtils.getOptions(this);
  schemaUtils.validate(schema, options, {
    name: 'Fragments Loader',
    baseDataPath: 'options',
  });
  const fragmentsPath = options.fragmentsPath;
  if (hasFragment(source)) {
    initCimFragment(options.fragmentsPath, options.baseApplicationName);
    return resolveFragment(fragmentsPath, source);
  }
  return source;
}
