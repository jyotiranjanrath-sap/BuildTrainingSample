"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ODataMetadataProvider = void 0;
const _ = require("lodash");
const MDKApplicationDelegate_1 = require("../export/MDKApplicationDelegate");
const SchemaProvider_1 = require("../service/schema/SchemaProvider");
const SchemaVersionAdapter_1 = require("../tool/SchemaVersionAdapter");
const LogUtil_1 = require("./LogUtil");
const ODataMetadataV3Service_1 = require("./ODataMetadataV3Service");
const ODataMetadataV4Service_1 = require("./ODataMetadataV4Service");
const TargetHelper_1 = require("./TargetHelper");
class ODataMetadataProvider {
    constructor(_documentProvider) {
        this._documentProvider = _documentProvider;
        this._services = [];
        this._bindableReferenceSchema = null;
    }
    static init(documentProvider) {
        ODataMetadataProvider._instance = new ODataMetadataProvider(documentProvider);
    }
    static get instance() {
        return ODataMetadataProvider._instance;
    }
    refreshServiceCache(id) {
        _.remove(this._services, service => {
            if (service[0] === id) {
                return true;
            }
            return false;
        });
    }
    getEntities(serviceFullPath, anchorDocumentUri) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let schemaVersion = yield SchemaVersionAdapter_1.SchemaVersionHelper.getApplicationSchemaVersion(anchorDocumentUri);
                let oDataMetadataService = yield this._findSevice(serviceFullPath, anchorDocumentUri, schemaVersion);
                if (oDataMetadataService) {
                    let oDataEntities = oDataMetadataService.getEntities();
                    const isOfflineEnabled = yield this._checkServiceOfflineEnabled(serviceFullPath);
                    if (isOfflineEnabled) {
                        oDataEntities = oDataEntities.concat(['ErrorArchive', 'EventLog', 'RequestQueue']);
                    }
                    return oDataEntities;
                }
                else {
                    return [];
                }
            }
            catch (error) {
                LogUtil_1.Log.error(error);
                return [];
            }
        });
    }
    getEntityByNavigationProperty(serviceFullPath, entity, navigationProperty, anchorDocumentUri) {
        return __awaiter(this, void 0, void 0, function* () {
            return SchemaVersionAdapter_1.SchemaVersionHelper.getApplicationSchemaVersion(anchorDocumentUri).then(schemaVersion => {
                return this._findSevice(serviceFullPath, anchorDocumentUri, schemaVersion).then(serviceObject => {
                    if (serviceObject) {
                        return serviceObject.getEntityByNavigationProperty(entity, navigationProperty);
                    }
                });
            });
        });
    }
    getEntityProperties(serviceFullPath, entity, anchorDocumentUri) {
        return __awaiter(this, void 0, void 0, function* () {
            /*if (!this._isSupportEntityString(entity)) {
                Log.debug('unsupported entity name: ' + entity);
                return [];
            } else */ if (entity === 'ErrorArchive') {
                return this._getErrorArchiveEntityProperties();
            }
            else if (entity === 'EventLog') {
                return this._getEventLogEntityProperties();
            }
            else if (entity === 'RequestQueue') {
                return this._getRequestQueueEntityProperties();
            }
            let that = this;
            return SchemaVersionAdapter_1.SchemaVersionHelper.getApplicationSchemaVersion(anchorDocumentUri).then(schemaVersion => {
                return this._findSevice(serviceFullPath, anchorDocumentUri, schemaVersion).then(serviceObject => {
                    let resultProperties = [];
                    if (serviceObject) {
                        let properties = serviceObject.getEntityProperties(entity);
                        resultProperties.push(...that._getNavigationProperties(properties));
                        resultProperties.push(...that._getNonNavigationProperties(properties));
                    }
                    return resultProperties;
                });
            });
        });
    }
    getEntityPropertiesWithDetail(serviceFullPath, entity, anchorDocumentUri) {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            return SchemaVersionAdapter_1.SchemaVersionHelper.getApplicationSchemaVersion(anchorDocumentUri).then(schemaVersion => {
                return this._findSevice(serviceFullPath, anchorDocumentUri, schemaVersion).then(serviceObject => {
                    if (serviceObject) {
                        return serviceObject.getEntityProperties(entity);
                    }
                    return [];
                });
            });
        });
    }
    getEntityPropertiesSchema(serviceFullPath, entity, anchorDocumentUri, isServiceOfflineEnabled) {
        return __awaiter(this, void 0, void 0, function* () {
            /*if (!this._isSupportEntityString(entity)) {
                Log.debug('unsupported entity name: ' + entity);
                return [];
            } else */ if (entity === 'ErrorArchive') {
                return this._getErrorArchiveEntityProperties();
            }
            else if (entity === 'EventLog') {
                return this._getEventLogEntityProperties();
            }
            else if (entity === 'RequestQueue') {
                return this._getRequestQueueEntityProperties();
            }
            let schemaVersion = yield SchemaVersionAdapter_1.SchemaVersionHelper.getApplicationSchemaVersion(anchorDocumentUri);
            let serviceObject = yield this._findSevice(serviceFullPath, anchorDocumentUri, schemaVersion);
            if (serviceObject) {
                let schema = serviceObject.getEntityProperties(entity);
                this._bindableReferenceSchema = yield SchemaProvider_1.SchemaProvider.getInstance(schemaVersion).getSchemaByPath("definitions/BindableReference.json");
                if (isServiceOfflineEnabled) {
                    schema = schema.filter(item => {
                        return !item.type.startsWith('Collection(');
                    });
                }
                schema.forEach(item => {
                    let sc = serviceObject.getComplexType(item.type, false);
                    item.type = this.convertTypeToBindable(sc.type, this._bindableReferenceSchema);
                    if (sc.type === "object" && sc.properties) {
                        this._processNavProperties(serviceObject, sc.properties, isServiceOfflineEnabled);
                        item["properties"] = sc.properties;
                    }
                    else if (sc.type === "array" && sc.items) {
                        this._processNavPropertiesForArray(serviceObject, sc);
                        item["items"] = sc.items;
                    }
                });
                return schema;
            }
            return [];
        });
    }
    getNonNavigationEntityProperties(serviceFullPath, entity, anchorDocumentUri) {
        return __awaiter(this, void 0, void 0, function* () {
            /*if (!this._isSupportEntityString(entity)) {
                Log.debug('unsupported entity name: ' + entity);
                return [];
            } else */ if (entity === 'ErrorArchive') {
                return this._getErrorArchiveEntityProperties();
            }
            else if (entity === 'EventLog') {
                return this._getEventLogEntityProperties();
            }
            else if (entity === 'RequestQueue') {
                return this._getRequestQueueEntityProperties();
            }
            let that = this;
            return SchemaVersionAdapter_1.SchemaVersionHelper.getApplicationSchemaVersion(anchorDocumentUri).then(schemaVersion => {
                return that._findSevice(serviceFullPath, anchorDocumentUri, schemaVersion).then(serviceObject => {
                    if (serviceObject) {
                        let properties = serviceObject.getEntityProperties(entity);
                        return that._getNonNavigationProperties(properties);
                    }
                    return [];
                });
            });
        });
    }
    convertTypeToBindable(odataType, bindableReferenceSchema) {
        let _knownType = ["boolean", "number", "integer"];
        if (!bindableReferenceSchema || _knownType.indexOf(odataType) < 0) {
            return odataType;
        }
        let _type = {
            "anyOf": bindableReferenceSchema["anyOf"].concat({ "type": odataType })
        };
        if (odataType === "number") {
            _type.anyOf = _type.anyOf.concat({ type: 'string', pattern: '^-?\\d+(\\.\\d+)?$' });
        }
        else if (odataType === "integer") {
            _type.anyOf = _type.anyOf.concat({ type: 'string', pattern: '^-?\\d+$' });
        }
        return _type;
    }
    _processNavProperties(serviceObject, properties, isServiceOfflineEnabled, depth = 1) {
        let maxDepth = 4; // update this value to change the recursion depth
        if (serviceObject && properties) {
            for (let key in properties) {
                if (properties.hasOwnProperty(key)) {
                    let item = properties[key];
                    if (isServiceOfflineEnabled && item.type.startsWith('Collection(')) {
                        delete properties[key];
                        continue;
                    }
                    let sc = serviceObject.getComplexType(item.type, false);
                    item.type = this.convertTypeToBindable(sc.type, this._bindableReferenceSchema);
                    if (depth <= maxDepth) {
                        if (sc.type === "object" && sc.properties) {
                            this._processNavProperties(serviceObject, sc.properties, isServiceOfflineEnabled, ++depth);
                            item["properties"] = sc.properties;
                        }
                        else if (sc.type === "array" && sc.items) {
                            this._processNavPropertiesForArray(serviceObject, sc, ++depth);
                            item["items"] = sc.items;
                        }
                    }
                }
            }
        }
    }
    _processNavPropertiesForArray(serviceObject, sc, depth = 1) {
        let maxDepth = 4; // update this value to change the recursion depth
        if (serviceObject && sc && sc.items && sc.items.type) {
            let sc2 = serviceObject.getComplexType(sc.items.type, false);
            sc.items.type = this.convertTypeToBindable(sc2.type, this._bindableReferenceSchema);
            if (depth <= maxDepth) {
                if (sc2.type === "object" && sc2.properties) {
                    this._processNavProperties(serviceObject, sc2.properties, false, ++depth);
                    sc.items["properties"] = sc2.properties;
                }
                else if (sc2.type === "array" && sc2.items) {
                    this._processNavPropertiesForArray(serviceObject, sc2, ++depth);
                }
            }
        }
    }
    _getNonNavigationProperties(rawProperties) {
        let resultProperties = [];
        for (let property of rawProperties) {
            if (!property.isNavigation) {
                resultProperties.push(property.name);
            }
        }
        return this._addPredefinedEnityProperties(resultProperties);
    }
    _addPredefinedEnityProperties(properties) {
        // append predefined odata annotation properties
        properties.push("@odata.id");
        properties.push("@odata.readLink");
        properties.push("@odata.editLink");
        properties.push("@odata.etag");
        properties.push("@odata.count");
        properties.push("@odata.type");
        return properties;
    }
    getNavigationEntityProperties(serviceFullPath, entity, anchorDocumentUri) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!TargetHelper_1.TargetHelper.isSupportEntityString(entity)) {
                LogUtil_1.Log.debug('unsupported entity name: ' + entity);
                return [];
            }
            else if (entity === 'ErrorArchive') {
                return this._getErrorArchiveEntityProperties();
            }
            else if (entity === 'EventLog') {
                return this._getEventLogEntityProperties();
            }
            else if (entity === 'RequestQueue') {
                return this._getRequestQueueEntityProperties();
            }
            let that = this;
            return SchemaVersionAdapter_1.SchemaVersionHelper.getApplicationSchemaVersion(anchorDocumentUri).then(schemaVersion => {
                return that._findSevice(serviceFullPath, anchorDocumentUri, schemaVersion).then(serviceObject => {
                    if (serviceObject) {
                        let properties = serviceObject.getEntityProperties(entity);
                        return that._getNavigationProperties(properties);
                    }
                    return [];
                });
            });
        });
    }
    _getNavigationProperties(rawProperties) {
        let resultProperties = [];
        for (let property of rawProperties) {
            if (property.isNavigation) {
                resultProperties.push(property.name);
            }
        }
        return this._addPredefinedNavigationProperties(resultProperties);
    }
    _addPredefinedNavigationProperties(properties) {
        // append predefined odata annotation properties
        properties.push("@odata.navigationLink");
        properties.push("@odata.associationLink");
        return properties;
    }
    _findSevice(serviceFullPath, anchorDocumentUri, schemaVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            if (serviceFullPath) {
                for (let pair of this._services) {
                    if (pair[0] === serviceFullPath) {
                        return pair[1];
                    }
                }
                let serviceObject = this._loadService(serviceFullPath, anchorDocumentUri, schemaVersion);
                this._services.push([serviceFullPath, serviceObject]);
                return serviceObject;
            }
        });
    }
    _loadService(serviceFullPath, anchorDocumentUri, schemaVersion) {
        let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(anchorDocumentUri, this._documentProvider);
        return appDelegate.getServiceMetadataContent(serviceFullPath).then(content => {
            if (content) {
                let reg = /<(edmx:)?Edmx\s+[^>]*Version="([^"]*)"[^>]*>/;
                let match = content.match(reg);
                if (match && match[2] === '4.0') {
                    if (!schemaVersion) {
                        return new ODataMetadataV4Service_1.ODataMetadataV4Service(content);
                    }
                    let numSchemaVersion = Number(schemaVersion.slice(0, 3));
                    if (numSchemaVersion >= 3.1) {
                        return new ODataMetadataV4Service_1.ODataMetadataV4Service(content);
                    }
                    else {
                        LogUtil_1.Log.error('Currently OData version 4 is not supported.');
                    }
                }
                return new ODataMetadataV3Service_1.ODataMetadataV3Service(content);
            }
        });
    }
    _getErrorArchiveEntityProperties() {
        // The description of ErrorArchive: https://github.wdf.sap.corp/snowblind/sdk/search?q=ErrorArchive&unscoped_q=ErrorArchive
        // The definition of ErrorArchive: https://github.wdf.sap.corp/snowblind/sdk/blob/master/packaging/ExtensionSample/src/ExtensionSample.mdkproject/metadata/Objects/SampleService/ErrorArchive.object
        let properties = [
            'RequestID',
            'CustomTag',
            'HTTPStatusCode',
            'Code',
            'Message',
            'InnerError',
            'Domain',
            'RequestMethod',
            'RequestURL',
            'RequestBody'
        ];
        return this._addPredefinedEnityProperties(properties);
    }
    _getEventLogEntityProperties() {
        // https://help.sap.com/doc/c2d571df73104f72b9f1b73e06c5609a/Latest/en-US/docs/javadoc/offline-odata/reference/com/sap/cloud/mobile/odata/offline/OfflineODataEvent.html#eventType
        let properties = [
            'Details',
            'EventType',
            'Id',
            'Time'
        ];
        return this._addPredefinedEnityProperties(properties);
    }
    _getRequestQueueEntityProperties() {
        // https://github.wdf.sap.corp/CPMSCF/docs/blob/7007ba78471aa4b67b4ab09595879c8e2ebb6a56/docs-en/docs/guides/features/offline/common/modifying-offline-data/modifying-offline-data.md
        let properties = [
            'RequestID',
            'Status',
            'Method',
            'URL',
            'Body',
            'CustomTag'
        ];
        return this._addPredefinedEnityProperties(properties);
    }
    _checkServiceOfflineEnabled(serviceFullPath) {
        return __awaiter(this, void 0, void 0, function* () {
            let serviceObj = yield this._documentProvider.getDocumentJson(serviceFullPath);
            return serviceObj && serviceObj["sourceType"] !== "Cloud" && serviceObj["OfflineEnabled"] !== false;
        });
    }
    getFunctionsandActions(serviceFullPath, anchorDocumentUri) {
        return __awaiter(this, void 0, void 0, function* () {
            let schemaVersion = yield SchemaVersionAdapter_1.SchemaVersionHelper.getApplicationSchemaVersion(anchorDocumentUri);
            let serviceObject = yield this._findSevice(serviceFullPath, anchorDocumentUri, schemaVersion);
            if (serviceObject && serviceObject.getFunctionsandActions) {
                return serviceObject.getFunctionsandActions();
            }
            return [];
        });
    }
    getEntityPropertiesByType(serviceFullPath, entity, anchorDocumentUri, type) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!TargetHelper_1.TargetHelper.isSupportEntityString(entity)) {
                LogUtil_1.Log.debug('unsupported entity name: ' + entity);
                return;
            }
            let that = this;
            return SchemaVersionAdapter_1.SchemaVersionHelper.getApplicationSchemaVersion(anchorDocumentUri).then(schemaVersion => {
                return that._findSevice(serviceFullPath, anchorDocumentUri, schemaVersion).then(serviceObject => {
                    if (serviceObject) {
                        let properties = serviceObject.getEntityProperties(entity);
                        if (properties) {
                            properties = properties.filter(property => property.type === type);
                            let result = properties.map(property => property.name);
                            return result;
                        }
                    }
                    return [];
                });
            });
        });
    }
    getTypeInSchema(serviceFullPath, anchorDocumentUri, type, bEntitySet, bFunction) {
        return __awaiter(this, void 0, void 0, function* () {
            if (type === "ErrorArchive") {
                return {
                    type: "object",
                    properties: {
                        'RequestID': {
                            type: "Edm.Int64"
                        },
                        'CustomTag': {
                            type: "Edm.String"
                        },
                        'HTTPStatusCode': {
                            type: "Edm.Int32"
                        },
                        'Code': {
                            type: "Edm.String"
                        },
                        'Message': {
                            type: "Edm.String"
                        },
                        'InnerError': {
                            type: "Edm.String"
                        },
                        'Domain': {
                            type: "Edm.String"
                        },
                        'RequestMethod': {
                            type: "Edm.String"
                        },
                        'RequestURL': {
                            type: "Edm.String"
                        },
                        'RequestBody': {
                            type: "Edm.String"
                        }
                    },
                    required: [
                        "RequestID"
                    ]
                };
            }
            if (type === 'EventLog') {
                return {
                    type: "object",
                    properties: {
                        'Details': {
                            type: "Edm.String"
                        },
                        'EventType': {
                            type: "Edm.String"
                        },
                        'Id': {
                            type: "Edm.Int64"
                        },
                        'Time': {
                            type: "Edm.DateTime"
                        }
                    }
                };
            }
            if (type === 'RequestQueue') {
                return {
                    type: "object",
                    properties: {
                        'RequestID': {
                            type: "Edm.Int64"
                        },
                        'Status': {
                            type: "Edm.String"
                        },
                        'Method': {
                            type: "Edm.String"
                        },
                        'URL': {
                            type: "Edm.String"
                        },
                        'Body': {
                            type: "Edm.String"
                        },
                        'CustomTag': {
                            type: "Edm.String"
                        }
                    }
                };
            }
            if (!TargetHelper_1.TargetHelper.isSupportEntityString(type)) {
                LogUtil_1.Log.debug('unsupported entity name: ' + type);
                return;
            }
            let that = this;
            return SchemaVersionAdapter_1.SchemaVersionHelper.getApplicationSchemaVersion(anchorDocumentUri).then(schemaVersion => {
                return that._findSevice(serviceFullPath, anchorDocumentUri, schemaVersion).then(serviceObject => {
                    if (serviceObject) {
                        return serviceObject.getTypeInSchema(type, bEntitySet, bFunction);
                    }
                });
            });
        });
    }
}
exports.ODataMetadataProvider = ODataMetadataProvider;
ODataMetadataProvider._instance = null;
//# sourceMappingURL=ODataMetadataProvider.js.map