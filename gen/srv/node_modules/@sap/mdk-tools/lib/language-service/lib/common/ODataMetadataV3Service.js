"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ODataMetadataV3Service = void 0;
const fast_xml_parser_1 = require("fast-xml-parser");
const LogUtil_1 = require("./LogUtil");
const _ = require("lodash");
class ODataMetadataV3Service {
    constructor(xmlContent) {
        this._load(xmlContent);
    }
    getEntities() {
        let entities = [];
        let schemas = this._getSchemas();
        schemas.forEach(schema => {
            let entityContainers = schema.EntityContainer;
            if (entityContainers) {
                entityContainers.forEach(entityContainer => {
                    let entitySets = entityContainer.EntitySet;
                    if (entitySets) {
                        entitySets.forEach(entitySet => {
                            let entityName = entitySet.Name;
                            if (entityName && entities.indexOf(entityName) < 0) {
                                entities.push(entityName);
                            }
                        });
                    }
                });
            }
        });
        return entities;
    }
    getEntityByNavigationProperty(entity, navigationProperty) {
        entity = this.removeCollectionFromEntityName(entity);
        let resultEntity = this._findEntityType(entity);
        if (resultEntity && resultEntity.NavigationProperty) {
            for (let property of resultEntity.NavigationProperty) {
                if (property.Name === navigationProperty) {
                    return this._getToRoleEntityByRelationShip(property.Relationship, property.ToRole);
                }
            }
        }
        return null;
    }
    removeCollectionFromEntityName(entity) {
        if (entity && entity.startsWith("Collection(")) {
            entity = entity.slice('Collection('.length, -1);
        }
        return entity;
    }
    _getToRoleEntityByRelationShip(relationship, toRole) {
        if (relationship && toRole) {
            let schemas = this._getSchemas();
            if (schemas) {
                let parts = relationship.split('.');
                let relationshipName = parts.pop();
                let namespaceOrAlias = parts.join('.');
                let association = this._findAssociationInSchema(schemas, relationshipName, namespaceOrAlias);
                for (let end of association.End) {
                    if (end.Role === toRole) {
                        // the v3 odata doesn't support Collection() ?
                        if (end.Multiplicity === "*") {
                            return "Collection(" + end.Type + ")";
                        }
                        return end.Type;
                    }
                }
            }
        }
        return null;
    }
    getEntityProperties(entity) {
        entity = this.removeCollectionFromEntityName(entity);
        let resultProperties = [];
        let resultEntity = this._findEntityType(entity);
        if (resultEntity) {
            if (resultEntity.Property) {
                resultEntity.Property.forEach(p => {
                    resultProperties.push({
                        name: p.Name,
                        isNavigation: false,
                        type: p.Type
                    });
                });
            }
            if (resultEntity.NavigationProperty) {
                resultEntity.NavigationProperty.forEach(np => {
                    resultProperties.push({
                        name: np.Name,
                        isNavigation: true,
                        type: this._getToRoleEntityByRelationShip(np.Relationship, np.ToRole)
                    });
                });
            }
        }
        return resultProperties;
    }
    getFunctionsandActions() {
        let actions = [];
        let schemas = this._getSchemas();
        schemas.forEach(schema => {
            let entityContainers = schema.EntityContainer;
            if (entityContainers) {
                entityContainers.forEach(entityContainer => {
                    let pendingItems = {};
                    let findItem = (items, type) => {
                        if (items) {
                            items.forEach(item => {
                                pendingItems[item.Name] = item;
                            });
                        }
                    };
                    findItem(entityContainer.ActionImport, 'action');
                    findItem(entityContainer.FunctionImport, 'function');
                    for (let key in pendingItems) {
                        if (pendingItems.hasOwnProperty(key)) {
                            let value = pendingItems[key];
                            let actionToadd = { name: key };
                            if (value.ReturnType) {
                                actionToadd.returnType = this._getComplexType(value.ReturnType, true);
                            }
                            if (value.Parameter) {
                                actionToadd.parameter = [];
                                value.Parameter.forEach(parameter => {
                                    let parameterToadd = { name: parameter.Name, type: undefined, nullable: parameter.Nullable !== false };
                                    parameterToadd.type = this._getComplexType(parameter.Type, true);
                                    actionToadd.parameter.push(parameterToadd);
                                });
                            }
                            actions.push(actionToadd);
                        }
                    }
                });
            }
        });
        return actions;
    }
    getComplexType(type, recursive) {
        return this._getComplexType(type, recursive);
    }
    _getComplexType(type, recursive) {
        if (type.startsWith('Edm.')) {
            return { type: this._ODataTypeToJsonType(type) };
        }
        if (type.startsWith('Collection(')) {
            let elementType = type.slice('Collection('.length, -1);
            let jsonType;
            if (recursive) {
                jsonType = this._getComplexType(elementType, true);
            }
            else {
                jsonType = { type: elementType };
            }
            let result = {};
            result.type = 'array';
            result.items = jsonType;
            return result;
        }
        let result = { type: 'object', properties: {} };
        let schema = this._getSchemas().find(schema => {
            const _alias = schema.Alias ? (schema.Alias + ".") : undefined;
            const _ns = schema.Namespace ? (schema.Namespace + ".") : undefined;
            return type.startsWith(_alias) || type.startsWith(_ns);
        });
        let shortTypeName = this._stripPrefix(type, schema);
        if (schema && schema.EnumType) {
            let enumType = schema.EnumType.find(item => item.Name === shortTypeName);
            if (enumType) {
                let result = {};
                result.type = "string";
                result.enum = [];
                enumType.Member.forEach(item => {
                    result.enum.push(item.Name);
                });
                return result;
            }
        }
        let complexType;
        if (schema && schema.ComplexType) {
            complexType = schema.ComplexType.find(item => item.Name === shortTypeName);
        }
        if (!complexType && schema.EntityType) {
            complexType = schema.EntityType.find(item => item.Name === shortTypeName);
        }
        if (complexType) {
            if (complexType.BaseType) {
                let baseType = this._getComplexType(complexType.BaseType, recursive);
                _.merge(result.properties, baseType.properties);
            }
            if (complexType.Property) {
                complexType.Property.forEach(property => {
                    if (recursive) {
                        result.properties[property.Name] = this._getComplexType(property.Type, true);
                    }
                    else {
                        result.properties[property.Name] = { type: property.Type };
                    }
                    if (!result.properties[property.Name]) {
                        console.error("error with property " + property.Name);
                    }
                    if (property.Nullable === false) {
                        if (!result.required) {
                            result.required = [];
                        }
                        result.required.push(property.Name);
                    }
                });
            }
            if (complexType.NavigationProperty) {
                complexType.NavigationProperty.forEach(property => {
                    if (recursive) {
                        // result.properties[property.Name] = {type: 'object'};
                    }
                    else {
                        let npType = this._getToRoleEntityByRelationShip(property.Relationship, property.ToRole);
                        result.properties[property.Name] = { type: npType, description: 'navigationProperty' };
                        if (!result.properties[property.Name]) {
                            console.error("error with property " + property.Name);
                        }
                    }
                });
            }
            return result;
        }
    }
    getTypeInSchema(type, bEntitySet, bFunction) {
        if (bEntitySet) {
            let entitySet;
            let schemas = this._getSchemas();
            if (schemas) {
                for (let schema of schemas) {
                    if (schema.EntityContainer) {
                        for (let container of schema.EntityContainer) {
                            if (container.EntitySet) {
                                entitySet = container.EntitySet.find(item => item.Name === type || item.EntityType === type);
                                if (entitySet) {
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            if (entitySet) {
                return this._getComplexType(entitySet.EntityType, false);
            }
            else {
                return;
            }
        }
        else if (bFunction) {
            let action;
            let schemas = this._getSchemas();
            if (schemas) {
                for (let schema of schemas) {
                    if (schema.EntityContainer && schema.EntityContainer.FunctionImport) {
                        let functionItem = schema.EntityContainer.FunctionImport.find(item => item.Name === type);
                        if (functionItem) {
                            action = functionItem.Function;
                            break;
                        }
                    }
                    if (schema.EntityContainer && schema.EntityContainer.ActionImport) {
                        let actionItem = schema.EntityContainer.ActionImport.find(item => item.Name === type);
                        if (actionItem) {
                            action = actionItem.Action;
                            break;
                        }
                    }
                }
            }
            if (action) {
                return this._getComplexType(action, false);
            }
        }
        return this._getComplexType(type, false);
    }
    _ODataTypeToJsonType(odataType) {
        switch (odataType) {
            case 'Edm.Boolean':
                return 'boolean';
            case 'Edm.Decimal':
            case 'Edm.Double':
                return 'number';
            case 'Edm.Int16':
            case 'Edm.Int32':
            case 'Edm.Int64':
                return 'integer';
            default:
                return 'string';
        }
    }
    _stripPrefix(type, schema) {
        const _alias = schema.Alias ? (schema.Alias + ".") : undefined;
        const _ns = schema.Namespace ? (schema.Namespace + ".") : undefined;
        if (type.startsWith(_alias)) {
            return type.slice(_alias.length);
        }
        else if (type.startsWith(_ns)) {
            return type.slice(_ns.length);
        }
        return type;
    }
    _findEntityType(entity) {
        let resultEntity = this._findResultEntry(entity);
        if (!resultEntity) {
            let parts = entity.split('.');
            let entityType = parts.pop();
            let namespace = parts.join('.');
            let schemas = this._getSchemas();
            if (schemas) {
                resultEntity = this._findEntityTypeInSchema(schemas, entityType, namespace);
            }
        }
        return resultEntity;
    }
    _findEntityTypeInEntityContainer(entityContainer, entityType, findEntityType) {
        let resultEntity;
        if (entityContainer) {
            entityContainer.some(element => {
                if (element.EntitySet && element.EntitySet.some(entity => {
                    if (entity.Name === entityType) {
                        let entityNS = entity.EntityType;
                        if (entityNS) {
                            let parts = entityNS.split('.');
                            let tmpEntityType = parts.pop();
                            let tmpNamespace = parts.join('.');
                            resultEntity = findEntityType(tmpEntityType, tmpNamespace);
                        }
                        if (resultEntity) {
                            return true;
                        }
                    }
                })) {
                    return true;
                }
            });
        }
        return resultEntity;
    }
    _findEntityTypeInSchema(schemas, entityType, namespace) {
        let resultEntity;
        for (let schema of schemas) {
            if (schema && (schema.Namespace === namespace || schema.Alias === namespace)) {
                let entities = schema.EntityType;
                if (entities) {
                    entities.some(e => {
                        if (e.Name === entityType) {
                            resultEntity = e;
                            return true;
                        }
                    });
                }
                break;
            }
        }
        return resultEntity;
    }
    _findAssociationInSchema(schemas, relationship, namespace) {
        let resultAssociation;
        for (let schema of schemas) {
            if (schema && (schema.Namespace === namespace || schema.Alias === namespace)) {
                let associations = schema.Association;
                if (associations) {
                    associations.some(a => {
                        if (a.Name === relationship) {
                            resultAssociation = a;
                            return true;
                        }
                    });
                }
                break;
            }
        }
        return resultAssociation;
    }
    _load(xmlContent) {
        if (xmlContent) {
            xmlContent = xmlContent.replace('<Edmx', '<edmx:Edmx');
            xmlContent = xmlContent.replace('</Edmx', '</edmx:Edmx');
            xmlContent = xmlContent.replace('<DataServices', '<edmx:DataServices');
            xmlContent = xmlContent.replace('</DataServices', '</edmx:DataServices');
            const arrTagNames = [
                "EntityContainer",
                "EntitySet",
                "NavigationProperty",
                "Parameter",
                "Property",
                "ActionImport",
                "FunctionImport",
                "EnumType",
                "Member",
                "ComplexType",
                "Association"
            ];
            const options = {
                attributeNamePrefix: "",
                ignoreAttributes: false,
                ignoreNameSpace: false,
                parseAttributeValue: true,
                isArray: (tagName, jPath, isLeafNode, isAttribute) => {
                    if (isLeafNode && !arrTagNames.includes(tagName)) {
                        return false;
                    }
                    return true;
                }
            };
            try {
                const parser = new fast_xml_parser_1.XMLParser(options);
                this._metadataObject = parser.parse(xmlContent);
                LogUtil_1.Log.debug('parsing metadata successful: ' + xmlContent);
            }
            catch (error) {
                LogUtil_1.Log.error('Failed to parse odata (<=v3) metadata: ' + xmlContent.substring(0, 256));
                LogUtil_1.Log.error('The error is: ' + error);
            }
        }
    }
    _findResultEntry(entity) {
        let _this = this;
        let resultEntity;
        let schemas = this._getSchemas();
        if (schemas) {
            for (let schema of schemas) {
                resultEntity = this._findEntityTypeInEntityContainer(schema.EntityContainer, entity, (enityType, namespace) => {
                    if (namespace) {
                        return _this._findEntityTypeInSchema(schemas, enityType, namespace);
                    }
                    return _this._findEntityTypeInSchema(schemas, enityType, schema.Namespace);
                });
                if (resultEntity) {
                    break;
                }
            }
        }
        return resultEntity;
    }
    _getSchemas() {
        if (this._metadataObject && this._metadataObject["edmx:Edmx"] && this._metadataObject["edmx:Edmx"][0]["edmx:DataServices"]) {
            return this._metadataObject["edmx:Edmx"][0]["edmx:DataServices"][0].Schema;
        }
        return [];
    }
}
exports.ODataMetadataV3Service = ODataMetadataV3Service;
//# sourceMappingURL=ODataMetadataV3Service.js.map