"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MDKApplicationDelegate = exports.ServiceMetadataXmlStatus = exports.CheckFileReferenceResult = void 0;
const path = require("path");
const cache_1 = require("../cache");
const PathUtil_1 = require("../common/PathUtil");
const TargetHelper_1 = require("../common/TargetHelper");
const EMPTY_STRING = '';
var CheckFileReferenceResult;
(function (CheckFileReferenceResult) {
    CheckFileReferenceResult[CheckFileReferenceResult["ApplicationNotFound"] = 0] = "ApplicationNotFound";
    CheckFileReferenceResult[CheckFileReferenceResult["FileReferenceNotExist"] = 1] = "FileReferenceNotExist";
    CheckFileReferenceResult[CheckFileReferenceResult["NoProblem"] = 2] = "NoProblem";
})(CheckFileReferenceResult = exports.CheckFileReferenceResult || (exports.CheckFileReferenceResult = {}));
var ServiceMetadataXmlStatus;
(function (ServiceMetadataXmlStatus) {
    ServiceMetadataXmlStatus[ServiceMetadataXmlStatus["Unknown"] = 0] = "Unknown";
    ServiceMetadataXmlStatus[ServiceMetadataXmlStatus["NotExist"] = 1] = "NotExist";
    ServiceMetadataXmlStatus[ServiceMetadataXmlStatus["IsExpired"] = 2] = "IsExpired";
    ServiceMetadataXmlStatus[ServiceMetadataXmlStatus["OK"] = 3] = "OK";
})(ServiceMetadataXmlStatus = exports.ServiceMetadataXmlStatus || (exports.ServiceMetadataXmlStatus = {}));
class MDKApplicationDelegate {
    constructor(anchorDocumentFullPath, documentProvider, referenceApps) {
        this._anchorDocumentFullPath = PathUtil_1.PathUtil.tryParseUri(anchorDocumentFullPath);
        this._documentProvider = documentProvider;
        this._referenceApps = referenceApps;
    }
    getApplicationInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            let searchingFolderFullPath = path.dirname(this._anchorDocumentFullPath);
            return this._findApplicationInfo(searchingFolderFullPath);
        });
    }
    checkFileReference(fileReference) {
        return __awaiter(this, void 0, void 0, function* () {
            let fileFullPath = yield this.toFileFullPath(fileReference);
            if (!fileFullPath) {
                return CheckFileReferenceResult.ApplicationNotFound;
            }
            if (this._documentProvider.isExistSync(fileFullPath)) {
                return CheckFileReferenceResult.NoProblem;
            }
            else {
                let parts = fileReference.split('/');
                if (parts && parts.length > 3 && parts[2] === 'Services' && parts[3].endsWith('.service')) {
                    let serviceReference = '/' + parts[1] + '/' + parts[2] + '/' + parts[3];
                    fileFullPath = yield this.toFileFullPath(serviceReference);
                    if (this._documentProvider.isExistSync(fileFullPath)) {
                        return CheckFileReferenceResult.NoProblem;
                    }
                }
                else if (MDKApplicationDelegate._isImage(fileReference)) {
                    return this._checkImagePath(fileFullPath);
                }
                return CheckFileReferenceResult.FileReferenceNotExist;
            }
        });
    }
    checkUnusedFileReference(fileReference) {
        return __awaiter(this, void 0, void 0, function* () {
            let fileFullPath = yield this.toFileFullPath(fileReference);
            if (!fileFullPath) {
                return EMPTY_STRING;
            }
            if (this._documentProvider.isExistSync(fileFullPath)) {
                return fileFullPath;
            }
            else {
                return EMPTY_STRING;
            }
        });
    }
    checkExtensionUnusedFileReference(fileReference, applicationPath) {
        return __awaiter(this, void 0, void 0, function* () {
            let fileFullPath = yield this.toExtensionFileFullPath(fileReference, applicationPath);
            if (!fileFullPath) {
                return EMPTY_STRING;
            }
            if (this._documentProvider.isExistSync(fileFullPath)) {
                return fileFullPath;
            }
            else {
                return EMPTY_STRING;
            }
        });
    }
    toFileReferenceFromImport(fileReference) {
        return __awaiter(this, void 0, void 0, function* () {
            let fileFullPath = path.resolve(path.dirname(this._anchorDocumentFullPath), fileReference);
            let fileRef = yield this.toFileReference(fileFullPath);
            return fileRef;
        });
    }
    toExtensionFileFullPath(fileReference, applicationName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (fileReference && applicationName) {
                return PathUtil_1.PathUtil.toFullPath(fileReference, applicationName);
            }
            return EMPTY_STRING;
        });
    }
    toFileReference(fileFullPath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (fileFullPath) {
                fileFullPath = PathUtil_1.PathUtil.tryParseUri(fileFullPath);
                let folderFullPath = path.dirname(fileFullPath);
                let appInfo = yield this._findApplicationInfo(folderFullPath);
                if (appInfo) {
                    return PathUtil_1.PathUtil.toFileReference(fileFullPath, appInfo.name, appInfo.basePath);
                }
            }
            return EMPTY_STRING;
        });
    }
    toFileFullPath(fileReference) {
        return __awaiter(this, void 0, void 0, function* () {
            if (fileReference) {
                let applicationName = PathUtil_1.PathUtil.parseApplicationName(fileReference);
                if (applicationName) {
                    let appInfo = yield this.getApplicationInfo();
                    if (appInfo && appInfo.name === applicationName) {
                        return PathUtil_1.PathUtil.toFullPath(fileReference, appInfo.basePath);
                    }
                    else if (this._referenceApps) {
                        let referenceApp = this._referenceApps.find(item => item.name === applicationName && item.comp === appInfo.name);
                        if (referenceApp && referenceApp.path) {
                            if (!this._documentProvider.isExistSync(referenceApp.path)) {
                                return EMPTY_STRING;
                            }
                            let referenceAppBasePath = path.dirname(referenceApp.path);
                            return PathUtil_1.PathUtil.toFullPath(fileReference, referenceAppBasePath);
                        }
                    }
                }
            }
            return EMPTY_STRING;
        });
    }
    getMDKTypeFolderFullPath(fileType) {
        return __awaiter(this, void 0, void 0, function* () {
            let appInfo = yield this.getApplicationInfo();
            if (appInfo) {
                return path.join(appInfo.basePath, PathUtil_1.PathUtil.getFileFolder(fileType));
            }
            return EMPTY_STRING;
        });
    }
    getMDKTypeFileFullPaths(fileType, otherFileTypes) {
        return __awaiter(this, void 0, void 0, function* () {
            let allFileFullPaths = [];
            try {
                let appInfo = yield this.getApplicationInfo();
                if (appInfo) {
                    let folders = [];
                    //let folderFullPath = path.join(appInfo.basePath, PathUtil.getFileFolder(fileType));
                    let folderFullPath;
                    if (fileType !== PathUtil_1.MDKFileType.App) {
                        folderFullPath = path.join(appInfo.basePath, PathUtil_1.PathUtil.getFileFolder(fileType));
                    }
                    else {
                        folderFullPath = appInfo.basePath;
                    }
                    folders.push(folderFullPath);
                    if (this._referenceApps) {
                        let referenceApp = this._referenceApps.find(item => item.comp === appInfo.name);
                        if (referenceApp && referenceApp.path) {
                            let referenceAppBasePath = path.dirname(referenceApp.path);
                            folderFullPath = path.join(referenceAppBasePath, PathUtil_1.PathUtil.getFileFolder(fileType));
                            folders.push(folderFullPath);
                        }
                    }
                    let fileTypes = [fileType];
                    if (otherFileTypes && otherFileTypes.length > 0) {
                        fileTypes = fileTypes.concat(otherFileTypes);
                    }
                    allFileFullPaths = yield this._getMDKTypeFileFullPathsInFolders(folders, fileTypes);
                }
            }
            catch (error) {
                console.error(error);
            }
            return allFileFullPaths;
        });
    }
    getMDKTypeFileRelativeReference(fileType, fullPath) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // if (PathUtil.getMDKFileType(fullPath) === fileType) {
                let appInfo = yield this.getApplicationInfo();
                if (appInfo) {
                    let apps = [{ name: appInfo.name, basePath: appInfo.basePath }];
                    if (this._referenceApps) {
                        let referenceApp = this._referenceApps.find(item => item.comp === appInfo.name);
                        if (referenceApp && referenceApp.path) {
                            let referenceAppBasePath = path.dirname(referenceApp.path);
                            apps.push({ name: referenceApp.name, basePath: referenceAppBasePath });
                        }
                    }
                    let folderName = PathUtil_1.PathUtil.getFileFolder(fileType);
                    let app, folderReference;
                    if (fileType !== PathUtil_1.MDKFileType.App) {
                        app = apps.find(item => {
                            return fullPath.startsWith(path.join(item.basePath, folderName));
                        });
                        folderReference = '/' + app.name + '/' + folderName + '/';
                    }
                    else {
                        app = apps.find(item => {
                            return fullPath.startsWith(item.basePath);
                        });
                        folderReference = '/' + app.name + '/';
                    }
                    let fileReference = PathUtil_1.PathUtil.toFileReference(fullPath, app.name, app.basePath);
                    return fileReference.substr(folderReference.length);
                }
                // }
            }
            catch (error) {
                console.error(error);
            }
            return EMPTY_STRING;
        });
    }
    getDefaultI18nFileFullPath() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let appInfo = yield this.getApplicationInfo();
                if (appInfo) {
                    let defaultI18nFileReference = appInfo.jsonData['Localization'];
                    if (defaultI18nFileReference) {
                        return this.toFileFullPath(defaultI18nFileReference);
                    }
                    return path.join(appInfo.basePath, 'i18n', 'i18n.properties');
                }
            }
            catch (error) {
                console.error(error);
            }
            return EMPTY_STRING;
        });
    }
    getDefaultI18nContent() {
        return __awaiter(this, void 0, void 0, function* () {
            let defaultI18nFileFullPath = yield this.getDefaultI18nFileFullPath();
            if (defaultI18nFileFullPath) {
                return this._documentProvider.getDocumentText(defaultI18nFileFullPath);
            }
            return EMPTY_STRING;
        });
    }
    getCimInfos() {
        return __awaiter(this, void 0, void 0, function* () {
            let cimInfos = [];
            try {
                let appInfo = yield this.getApplicationInfo();
                if (appInfo) {
                    let appFolderSubFileFullPaths = yield this._documentProvider.getChildrenFullPaths(appInfo.basePath, false);
                    for (const appFolderSubFileFullPath of appFolderSubFileFullPaths) {
                        if (PathUtil_1.PathUtil.getMDKFileType(appFolderSubFileFullPath) === PathUtil_1.MDKFileType.CIM) {
                            let cimJson = yield this._documentProvider.getDocumentJson(appFolderSubFileFullPath);
                            if (cimJson) {
                                cimJson['IntegrationPoints'] = cimJson['IntegrationPoints'] ? cimJson['IntegrationPoints'] : [];
                                cimInfos.push({
                                    projectName: cimJson['ProjectName'],
                                    applicationName: cimJson['ApplicationName'],
                                    componentVersion: cimJson['ComponentVersion'],
                                    displayName: cimJson['DisplayName'],
                                    integrationPoints: cimJson['IntegrationPoints'].map(ip => {
                                        return {
                                            source: ip['Source'],
                                            target: ip['Target']
                                        };
                                    })
                                });
                            }
                        }
                    }
                }
            }
            catch (error) {
                console.error(error);
            }
            return cimInfos;
        });
    }
    getApplicationInfoFromCimAnchor(appContext) {
        return __awaiter(this, void 0, void 0, function* () {
            if (appContext && PathUtil_1.PathUtil.getMDKFileType(this._anchorDocumentFullPath) === PathUtil_1.MDKFileType.CIM) {
                let cimJson = yield this._documentProvider.getDocumentJson(this._anchorDocumentFullPath);
                let cimAppName = cimJson['ApplicationName'];
                for (const appFullPath of appContext.allAppFullPaths) {
                    let appInfo = yield this._readApplicationInfo(appFullPath);
                    if (appInfo && appInfo.name === cimAppName) {
                        return appInfo;
                    }
                }
                console.error("Faied to get appInfo from cim: " + this._anchorDocumentFullPath);
                console.log("The appFullPaths is: " + appContext.allAppFullPaths);
            }
        });
    }
    getServiceMetadataContent(serviceFullPath) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let serviceXmlFullPath = TargetHelper_1.TargetHelper.getServiceXmlFullPath(serviceFullPath);
                return this._documentProvider.getDocumentText(serviceXmlFullPath);
            }
            catch (error) {
                console.error(error);
            }
            return EMPTY_STRING;
        });
    }
    checkServiceMetadataXml(serviceFileReference, maxExpiredDays) {
        return __awaiter(this, void 0, void 0, function* () {
            if (maxExpiredDays < 0) {
                return ServiceMetadataXmlStatus.OK;
            }
            else if (maxExpiredDays === 0) {
                return ServiceMetadataXmlStatus.IsExpired;
            }
            else {
                try {
                    let appInfo = yield this.getApplicationInfo();
                    if (appInfo) {
                        let serviceXmlReference = TargetHelper_1.TargetHelper.getServiceXmlReference(serviceFileReference);
                        let serviceXmlFullPath = PathUtil_1.PathUtil.toFullPath(serviceXmlReference, appInfo.basePath);
                        if (!this._documentProvider.isExistSync(serviceXmlFullPath)) {
                            return ServiceMetadataXmlStatus.NotExist;
                        }
                        else {
                            let serviceXmlModifyTime = yield this._documentProvider.getDocumentModifyTime(serviceXmlFullPath);
                            if (!serviceXmlModifyTime) {
                                return ServiceMetadataXmlStatus.Unknown;
                            }
                            else {
                                if (serviceXmlModifyTime.getTime() < Date.now()) {
                                    let maxExpiredTime = maxExpiredDays * 24 * 60 * 60 * 1000;
                                    let expiredTime = Date.now() - serviceXmlModifyTime.getTime();
                                    if (expiredTime >= maxExpiredTime) {
                                        return ServiceMetadataXmlStatus.IsExpired;
                                    }
                                    else {
                                        return ServiceMetadataXmlStatus.OK;
                                    }
                                }
                                else {
                                    return ServiceMetadataXmlStatus.IsExpired;
                                }
                            }
                        }
                    }
                }
                catch (error) {
                    console.error(error);
                    return ServiceMetadataXmlStatus.Unknown;
                }
            }
        });
    }
    getSchemaTypeByFilePath(fileFullPath) {
        let fileContent = this._documentProvider.getDocumentJsonSync(fileFullPath);
        if (fileContent && fileContent._Type) {
            return fileContent._Type;
        }
        else {
            return EMPTY_STRING;
        }
    }
    _findApplicationInfo(folderFullPath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!folderFullPath || !path.basename(folderFullPath) || folderFullPath === '.') {
                return;
            }
            let documentProvider = this._documentProvider;
            let isFolderExist = yield documentProvider.isExist(folderFullPath);
            if (!isFolderExist) {
                return;
            }
            let appFullPath = PathUtil_1.PathUtil.buildApplicationPath(folderFullPath);
            let isAppExist = yield documentProvider.isExist(appFullPath);
            if (isAppExist) {
                return this._readApplicationInfo(appFullPath);
            }
            else {
                let parentFolderPath = path.dirname(folderFullPath);
                return this._findApplicationInfo(parentFolderPath);
            }
        });
    }
    _readApplicationInfo(applicationFullPath) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let appJson = yield this._documentProvider.getDocumentJson(applicationFullPath);
                if (Object.keys(appJson).length === 0) {
                    let cachedAppInfo = cache_1.cache.getAppInfo(applicationFullPath);
                    if (cachedAppInfo) {
                        appJson = cache_1.cache.getAppInfo(applicationFullPath);
                    }
                }
                else {
                    cache_1.cache.setAppInfo(applicationFullPath, appJson);
                }
                return {
                    name: appJson['_Name'],
                    version: appJson['Version'],
                    basePath: path.dirname(applicationFullPath),
                    fullPath: applicationFullPath,
                    jsonData: appJson
                };
            }
            catch (error) {
                console.error(error);
            }
        });
    }
    _getMDKTypeFileFullPathsInFolders(folderFullPaths, fileTypes) {
        return __awaiter(this, void 0, void 0, function* () {
            let allFileFullPaths = [];
            folderFullPaths.forEach((folderFullPath) => __awaiter(this, void 0, void 0, function* () {
                let folderFileFullPaths = yield this._documentProvider.getChildrenFullPaths(folderFullPath, true);
                folderFileFullPaths = folderFileFullPaths.filter(folderFileFullPath => {
                    let _fileType = PathUtil_1.PathUtil.getMDKFileType(folderFileFullPath);
                    return fileTypes.includes(_fileType);
                });
                if (folderFileFullPaths) {
                    allFileFullPaths.push(...folderFileFullPaths);
                }
            }));
            return allFileFullPaths;
        });
    }
    _checkImagePath(imageFileFullPath) {
        let imageFileNamePart = '';
        let imageExtPart = '';
        let checkImagePath = '';
        const replacePos = imageFileFullPath.lastIndexOf('.');
        if (replacePos > 0) {
            imageFileNamePart = imageFileFullPath.substr(0, replacePos);
            imageExtPart = imageFileFullPath.substr(replacePos, imageFileFullPath.length - replacePos);
        }
        if (imageFileNamePart !== '' && imageExtPart !== '') {
            checkImagePath = imageFileNamePart + '.light' + imageExtPart;
            if (this._documentProvider.isExistSync(checkImagePath)) {
                return CheckFileReferenceResult.NoProblem;
            }
            checkImagePath = imageFileNamePart + '.dark' + imageExtPart;
            if (this._documentProvider.isExistSync(checkImagePath)) {
                return CheckFileReferenceResult.NoProblem;
            }
        }
        return CheckFileReferenceResult.FileReferenceNotExist;
    }
    static _isImage(sReference) {
        if (!this._isValidString(sReference)) {
            return false;
        }
        // The regex checks for strings ending with pattern, case-insensitive
        let imageExtensionRegEx = new RegExp('.(jpe?g|png|pdf)$', 'i');
        // probably not an exhaustive list
        return sReference.includes('/Images/') && imageExtensionRegEx.test(sReference);
    }
    static _isValidString(sReference) {
        return typeof (sReference) === 'string' && !sReference.includes(' ');
    }
}
exports.MDKApplicationDelegate = MDKApplicationDelegate;
//# sourceMappingURL=MDKApplicationDelegate.js.map