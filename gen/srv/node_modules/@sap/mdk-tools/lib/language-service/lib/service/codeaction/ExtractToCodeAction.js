"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtractToCodeAction = void 0;
const jsonParser_1 = require("vscode-json-languageservice/lib/umd/parser/jsonParser");
const vscode_uri_1 = require("vscode-uri");
const LanguageHelper_1 = require("../../common/LanguageHelper");
const PathUtil_1 = require("../../common/PathUtil");
const mdkLanguageTypes_1 = require("../../mdkLanguageTypes");
const SchemaVersionAdapter_1 = require("../../tool/SchemaVersionAdapter");
const SchemaProvider_1 = require("../schema/SchemaProvider");
class ExtractToCodeAction {
    constructor(commandId, commandType) {
        this._commandId = commandId;
        this._fileType = commandType;
    }
    provideCodeActions(document, range, context) {
        if (context.diagnostics.length > 0) {
            return Promise.resolve([]);
        }
        let offset = document.offsetAt(range.start);
        let jsonDocument = (0, jsonParser_1.parse)(document);
        let node = jsonDocument.getNodeFromOffset(offset);
        if (!node || node.type !== 'string' || LanguageHelper_1.LanguageHelper.isKey(node)) {
            return Promise.resolve([]);
        }
        let overwriteRange = mdkLanguageTypes_1.Range.create(document.positionAt(node.offset + 1), document.positionAt(node.offset + node.length - 1));
        let codeActionCommand = this.buildCodeActionCommand(vscode_uri_1.default.parse(document.uri), overwriteRange, node.value);
        if (this._fileType === PathUtil_1.MDKFileType.Rule) {
            return this.canBeRuleReference(document.uri, jsonDocument, offset, node).then(isRuleNode => {
                if (isRuleNode && !node.value.startsWith("/")) {
                    return [
                        codeActionCommand
                    ];
                }
            });
        }
        else if (this._fileType === PathUtil_1.MDKFileType.Global) {
            return this.canBeGlobalReference(document.uri, jsonDocument, offset, node).then(isGlobalNode => {
                if (isGlobalNode && this.isLiteralNode(node)) {
                    return [
                        codeActionCommand
                    ];
                }
            });
        }
        else if (this._fileType === PathUtil_1.MDKFileType.i18n) {
            return this.canBeI18nValue(document.uri, jsonDocument, offset, node).then(isI18nNode => {
                if (isI18nNode && this.isLiteralNode(node)) {
                    return Promise.resolve([
                        codeActionCommand
                    ]);
                }
            });
        }
        else {
            return Promise.resolve([]);
        }
    }
    isLiteralNode(node) {
        return node && !node.value.startsWith("/") && // file reference
            !node.value.startsWith("#") && // target path
            !node.value.startsWith("$") && // i18n string
            !node.value.startsWith("{") && // binding property
            !node.value.startsWith("res://"); // res data
    }
    canBeRuleReference(fullPath, jsonDoc, offset, node) {
        return this.canBeFileReference(fullPath, jsonDoc, offset, node, PathUtil_1.MDKFileType.Rule);
    }
    canBeGlobalReference(fullPath, jsonDoc, offset, node) {
        return this.canBeFileReference(fullPath, jsonDoc, offset, node, PathUtil_1.MDKFileType.Global);
    }
    canBeFileReference(fullPath, jsonDoc, offset, node, fileType) {
        return SchemaVersionAdapter_1.SchemaVersionHelper.getApplicationSchemaVersion(fullPath).then(schemaVersion => {
            return SchemaProvider_1.SchemaProvider.getInstance(schemaVersion).getSchemaForMetadata(fullPath, jsonDoc).then(schemaContent => {
                let schemaObj = JSON.parse(schemaContent);
                let matchingSchemas = jsonDoc.getMatchingSchemas(schemaObj, offset);
                let patterns = LanguageHelper_1.LanguageHelper.getAvailablePatterns(node, matchingSchemas);
                return patterns.some(pattern => {
                    return LanguageHelper_1.LanguageHelper.getType(pattern) === fileType;
                });
            });
        });
    }
    canBeI18nValue(fullPath, jsonDoc, offset, node) {
        let parentNode = node.parent;
        if (parentNode && parentNode.valueNode === node) {
            let keyNode = parentNode.keyNode;
            if (keyNode.value.indexOf('_') === 0) {
                return Promise.resolve(false); // e.g. node key is: '_Type' or '_Name'
            }
            else {
                if (node.type !== "string") {
                    return Promise.resolve(false);
                }
                else {
                    return SchemaVersionAdapter_1.SchemaVersionHelper.getApplicationSchemaVersion(fullPath).then(schemaVersion => {
                        return SchemaProvider_1.SchemaProvider.getInstance(schemaVersion).getSchemaForMetadata(fullPath, jsonDoc).then(schemaContent => {
                            let schemaObj = JSON.parse(schemaContent);
                            let matchingSchemas = jsonDoc.getMatchingSchemas(schemaObj, offset);
                            if (matchingSchemas && matchingSchemas.length > 0) {
                                let isStringEnum = false;
                                matchingSchemas.forEach(schemaInfo => {
                                    if (schemaInfo.node === node && !schemaInfo.inverted && schemaInfo.schema) {
                                        let matchedSchema = schemaInfo.schema;
                                        if (matchedSchema.type === "string" && matchedSchema.enum) {
                                            isStringEnum = true;
                                        }
                                    }
                                });
                                return !isStringEnum;
                            }
                            else {
                                return true; // string node but no schema matched will always can attach i18n value
                            }
                        });
                    });
                }
            }
        }
        else {
            return Promise.resolve(false);
        }
    }
    buildCodeActionCommand(uri, overwriteRange, nodeValue) {
        return {
            title: 'MDK: Extract to ' + PathUtil_1.PathUtil.getFileTypeName(this._fileType),
            command: this._commandId,
            arguments: [
                uri, overwriteRange, nodeValue
            ]
        };
    }
}
exports.ExtractToCodeAction = ExtractToCodeAction;
//# sourceMappingURL=ExtractToCodeAction.js.map