"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileReferenceCodeAction = void 0;
const LanguageHelper_1 = require("../../common/LanguageHelper");
const PathUtil_1 = require("../../common/PathUtil");
const MDKApplicationDelegate_1 = require("../../export/MDKApplicationDelegate");
class FileReferenceCodeAction {
    constructor(documentProvider, appContext, appInfos) {
        this._documentProvider = documentProvider;
        this._appContext = appContext;
        this._appInfos = appInfos;
    }
    provideCodeActions(document, range, context) {
        for (let index = 0; index < context.diagnostics.length; index++) {
            if (context.diagnostics[index].code === "ApplicationNotFound") {
                let diagnostic = context.diagnostics[index];
                let fileReference = document.getText(diagnostic.range);
                //strip ""
                fileReference = fileReference.substring(1, fileReference.length - 1);
                return _generateCommand(document, fileReference, this._documentProvider, this._appInfos);
            }
            if (context.diagnostics[index].code === "PathNotFound") {
                let diagnostic = context.diagnostics[index];
                let fileReference = document.getText(diagnostic.range);
                //strip ""
                fileReference = fileReference.substring(1, fileReference.length - 1);
                return _getFullPathFromFileReference(document, fileReference, this._documentProvider, this._appContext).then(fullPath => {
                    if (!PathUtil_1.PathUtil.isMDKFile(fullPath)) {
                        return [];
                    }
                    let type = PathUtil_1.PathUtil.getFileTypeName(PathUtil_1.PathUtil.getMDKFileType(fullPath)).toLowerCase();
                    let commandId = "mdk.new" + type;
                    let title = "MDK: Create " + type + " for this reference";
                    return [{
                            title: title,
                            command: commandId,
                            arguments: [fullPath]
                        }];
                });
            }
        }
        let referenceApps;
        if (this._appContext) {
            referenceApps = this._appContext.referenceApps;
        }
        return _generateLastingResolveCommand(document, range, this._documentProvider, this._appInfos, referenceApps);
    }
}
exports.FileReferenceCodeAction = FileReferenceCodeAction;
function _getFullPathFromFileReference(textDocument, fileReference, documentProvider, appContext) {
    return __awaiter(this, void 0, void 0, function* () {
        let documentFullPath = PathUtil_1.PathUtil.tryParseUri(textDocument.uri);
        if (PathUtil_1.PathUtil.getMDKFileType(documentFullPath) === PathUtil_1.MDKFileType.CIM && appContext) {
            let baseAppDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(documentFullPath, documentProvider, appContext.referenceApps);
            let fileFullPath = yield baseAppDelegate.toFileFullPath(fileReference);
            if (!fileFullPath) {
                let cimAppInfo = yield baseAppDelegate.getApplicationInfoFromCimAnchor(appContext);
                if (cimAppInfo) {
                    let cimAppDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(cimAppInfo.fullPath, documentProvider);
                    return cimAppDelegate.toFileFullPath(fileReference);
                }
            }
            else {
                return fileFullPath;
            }
        }
        else {
            let referenceApps;
            if (appContext) {
                referenceApps = appContext.referenceApps;
            }
            let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(documentFullPath, documentProvider, referenceApps);
            return appDelegate.toFileFullPath(fileReference);
        }
    });
}
function _generateCommand(document, fileReference, documentProvider, appInfos, forLastingResolve, referenceApps) {
    return __awaiter(this, void 0, void 0, function* () {
        let appName = PathUtil_1.PathUtil.parseApplicationName(fileReference);
        let documentFullPath = PathUtil_1.PathUtil.tryParseUri(document.uri);
        let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(documentFullPath, documentProvider);
        let currentAppInfo = yield appDelegate.getApplicationInfo();
        if (currentAppInfo.name === appName) {
            return [];
        }
        let commandId = "mdk.solveApplicationReference";
        let title = "MDK: Resolve the application reference";
        let count = 0;
        let matchedApps = [];
        appInfos.forEach(app => {
            if (app.name === appName) {
                matchedApps.push(app);
                count++;
            }
        });
        if (count === 0) {
            title = "MDK: Ignore the application reference";
        }
        if (forLastingResolve) {
            if (count < 1) {
                return Promise.resolve([]);
            }
            else if (count === 1) {
                if (referenceApps) {
                    let referenceApp = referenceApps.find(referenceApp => referenceApp.name === appName && referenceApp.comp === currentAppInfo.name);
                    if (referenceApp && referenceApp.path && referenceApp.path.startsWith(matchedApps[0].fullPath)) {
                        return Promise.resolve([]);
                    }
                }
            }
        }
        return Promise.resolve([{
                title: title,
                command: commandId,
                arguments: [document.uri, appName]
            }]);
    });
}
function _generateLastingResolveCommand(document, range, documentProvider, appInfos, referenceApps) {
    let fileReference = LanguageHelper_1.LanguageHelper.getFileReference(document, range.end);
    if (fileReference) {
        return _generateCommand(document, fileReference, documentProvider, appInfos, true, referenceApps);
    }
    return Promise.resolve([]);
}
//# sourceMappingURL=FileReferenceCodeAction.js.map