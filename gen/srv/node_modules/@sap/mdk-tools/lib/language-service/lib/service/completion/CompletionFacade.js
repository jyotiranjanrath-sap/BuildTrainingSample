"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompletionFacade = void 0;
const path = require("path");
const jsonParser_1 = require("vscode-json-languageservice/lib/umd/parser/jsonParser");
const LogUtil_1 = require("../../common/LogUtil");
const PathUtil_1 = require("../../common/PathUtil");
const MDKApplicationDelegate_1 = require("../../export/MDKApplicationDelegate");
const mdkLanguageTypes_1 = require("../../mdkLanguageTypes");
const SchemaVersionAdapter_1 = require("../../tool/SchemaVersionAdapter");
const SchemaProvider_1 = require("../schema/SchemaProvider");
class CompletionFacade {
    constructor(documentProvider) {
        this._documentProvider = documentProvider;
        this._registeredCompletions = [];
    }
    register(completion) {
        if (completion) {
            if (this._registeredCompletions.indexOf(completion) >= 0) {
                LogUtil_1.Log.error("completion registered more than one time.");
            }
            else {
                this._registeredCompletions.push(completion);
            }
        }
        else {
            LogUtil_1.Log.error("a undefined completion is trying to register.");
        }
    }
    doComplete(document, position, context) {
        return __awaiter(this, void 0, void 0, function* () {
            let completions = [];
            if (document) {
                try {
                    yield this._setup(document, context);
                    let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(document.uri, this._documentProvider);
                    let fileReference = yield appDelegate.toFileReference(document.uri);
                    let fileName = path.basename(document.uri);
                    if (PathUtil_1.PathUtil.isMDKFile(fileReference) || ["mdkproject.json", "brandedsettings.json"].includes(fileName.toLowerCase())) {
                        if (PathUtil_1.PathUtil.getMDKFileType(fileReference) !== PathUtil_1.MDKFileType.Rule) {
                            completions = yield this._completeMetadata(document, position);
                        }
                        else {
                            completions = yield this._completeRule(document, position);
                        }
                    }
                }
                catch (error) {
                    LogUtil_1.Log.error(error);
                }
            }
            return mdkLanguageTypes_1.CompletionList.create(completions, false);
        });
    }
    _setup(document, context) {
        return __awaiter(this, void 0, void 0, function* () {
            let promises = [];
            this._registeredCompletions.forEach(completion => {
                if (completion.setup) {
                    promises.push(completion.setup(document, context));
                }
            });
            yield Promise.all(promises);
        });
    }
    _completeMetadata(document, position) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let offset = document.offsetAt(position);
                let jsonDocument = (0, jsonParser_1.parse)(document);
                let schemaVersion = yield SchemaVersionAdapter_1.SchemaVersionHelper.getApplicationSchemaVersion(document.uri);
                let schemaString = yield SchemaProvider_1.SchemaProvider.getInstance(schemaVersion).getSchemaForMetadata(document.uri, jsonDocument);
                let schema = JSON.parse(schemaString);
                let matchingSchemas = jsonDocument.getMatchingSchemas(schema, offset);
                let promises = [];
                this._registeredCompletions.forEach(completion => {
                    promises.push(completion.provideCompletionItemsForJSON(document, position, jsonDocument, matchingSchemas));
                });
                let resultCompletions = [];
                return Promise.all(promises).then(completionsArray => {
                    completionsArray.forEach(completions => {
                        if (completions) {
                            resultCompletions.push(...completions);
                        }
                    });
                    return resultCompletions;
                }).catch(error => {
                    LogUtil_1.Log.error(error);
                    return [];
                });
            }
            catch (error) {
                LogUtil_1.Log.debug(error);
                return [];
            }
        });
    }
    _completeRule(document, position) {
        return __awaiter(this, void 0, void 0, function* () {
            let promises = [];
            try {
                this._registeredCompletions.forEach(completion => {
                    promises.push(completion.provideCompletionItemsForJS(document, position));
                });
            }
            catch (error) {
                LogUtil_1.Log.debug(error);
            }
            let resultCompletions = [];
            return Promise.all(promises).then(completionsArray => {
                completionsArray.forEach(completions => {
                    if (completions) {
                        resultCompletions.push(...completions);
                    }
                });
                return resultCompletions;
            }).catch(error => {
                LogUtil_1.Log.error(error);
                return [];
            });
        });
    }
}
exports.CompletionFacade = CompletionFacade;
//# sourceMappingURL=CompletionFacade.js.map