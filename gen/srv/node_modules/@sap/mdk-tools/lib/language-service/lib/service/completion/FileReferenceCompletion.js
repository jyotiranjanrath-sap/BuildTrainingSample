"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileReferenceCompletion = void 0;
const LanguageHelper_1 = require("../../common/LanguageHelper");
const LogUtil_1 = require("../../common/LogUtil");
const PathUtil_1 = require("../../common/PathUtil");
const RuleHelper_1 = require("../../common/RuleHelper");
const MDKApplicationDelegate_1 = require("../../export/MDKApplicationDelegate");
const mdkLanguageTypes_1 = require("../../mdkLanguageTypes");
const _ = require("lodash");
class FileReferenceCompletion {
    constructor(documentProvider) {
        this._documentProvider = documentProvider;
    }
    setup(document, context) {
        return __awaiter(this, void 0, void 0, function* () {
            this._appContext = context;
        });
    }
    getCurrentWord(document, offset) {
        let text = document.getText();
        text = text.substring(0, offset);
        let doubleQuotePos = text.lastIndexOf('"');
        let singleQuotePos = text.lastIndexOf('\'');
        let startPos = Math.max(doubleQuotePos, singleQuotePos) + 1;
        return text.substring(startPos, offset);
    }
    provideCompletionItemsForJS(document, position) {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            let offset = document.offsetAt(position);
            let currentWord = this.getCurrentWord(document, offset);
            let overwriteRange = null;
            return new Promise((resolve, reject) => {
                let jsContext;
                let esprima = require('esprima');
                esprima.parseModule(document.getText(), {
                    loc: true,
                    tokens: true,
                    comment: true,
                    tolerant: true
                }, function (node) {
                    if (RuleHelper_1.RuleHelper.checkEsprimaNode(node, "executeAction")) {
                        if (node.arguments && node.arguments.length > 0) {
                            overwriteRange = _getOverwriteRangeFromEsprimaLoc(node.arguments[0].loc);
                            let argValue = _getTextValueFromEsprimaLoc(document, position, node.arguments[0].loc);
                            if (argValue) {
                                jsContext = {
                                    types: [PathUtil_1.MDKFileType.Action],
                                    value: argValue,
                                    currentWord: currentWord,
                                    document: document.uri,
                                    overwriteRange: overwriteRange
                                };
                            }
                        }
                    }
                    else if (RuleHelper_1.RuleHelper.checkEsprimaNode(node, "getGlobalDefinition")) {
                        if (node.arguments && node.arguments.length > 0) {
                            overwriteRange = _getOverwriteRangeFromEsprimaLoc(node.arguments[0].loc);
                            let argValue = _getTextValueFromEsprimaLoc(document, position, node.arguments[0].loc);
                            if (argValue) {
                                jsContext = {
                                    types: [PathUtil_1.MDKFileType.Global],
                                    value: argValue,
                                    currentWord: currentWord,
                                    document: document.uri,
                                    overwriteRange: overwriteRange
                                };
                            }
                        }
                    }
                });
                return that.addFileReferenceCompletions(jsContext).then((items) => {
                    resolve(items);
                });
            }).catch(error => {
                LogUtil_1.Log.debug(error);
                return Promise.resolve([]);
            });
        });
    }
    provideCompletionItemsForJSON(document, position, jsonDocument, matchingSchemas) {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            let offset = document.offsetAt(position);
            let node = jsonDocument.getNodeFromOffset(offset);
            let currentWord = this.getCurrentWord(document, offset);
            let overwriteRange = null;
            if (!node || LanguageHelper_1.LanguageHelper.isKey(node)) {
                return Promise.resolve([]);
            }
            if (node.length === 2 && node.value === ",") {
                return Promise.resolve([]);
            }
            // return SchemaVersionHelper.getApplicationSchemaVersion(document.uri).then(schemaVersion => {
            // todo: original is textDocument.uri.fsPath. I remove .path at the end
            // return SchemaProvider.getInstance(schemaVersion).getSchemaForMetadata(document.uri, jsonDocument).then(async (schemaStr) => {
            // let schema = JSON.parse(schemaStr);
            if (node.type === "string") {
                let availablePatterns = LanguageHelper_1.LanguageHelper.getAvailablePatterns(node, matchingSchemas);
                let types = [];
                availablePatterns.forEach((pattern) => {
                    let type = LanguageHelper_1.LanguageHelper.getType(pattern);
                    if (type !== undefined) {
                        types.push(type);
                    }
                });
                if (availablePatterns.length === 0 && node.value !== "") {
                    if (!that.hasEnumSchema(node, matchingSchemas)) {
                        that.getTypesForNodeWithoutSchema(types, document);
                    }
                }
                overwriteRange = mdkLanguageTypes_1.Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length - 1));
                let anchorDocumentuRIs = [document.uri];
                let promise;
                let fileFullPath = PathUtil_1.PathUtil.tryParseUri(document.uri);
                let bCIMFile = PathUtil_1.PathUtil.getMDKFileType(fileFullPath) === PathUtil_1.MDKFileType.CIM;
                if (bCIMFile && that._appContext) {
                    let documentProvider = that._documentProvider;
                    let baseAppDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(fileFullPath, documentProvider);
                    promise = baseAppDelegate.getApplicationInfoFromCimAnchor(that._appContext);
                }
                else {
                    promise = Promise.resolve(undefined);
                }
                return promise.then((cimAppInfo) => __awaiter(this, void 0, void 0, function* () {
                    if (cimAppInfo) {
                        anchorDocumentuRIs.push(cimAppInfo.fullPath);
                    }
                    let promises = [];
                    let result = [];
                    anchorDocumentuRIs.forEach(anchorDocumentUri => {
                        let context = {
                            types: types,
                            value: JSON.stringify(node.value),
                            currentWord: currentWord,
                            document: anchorDocumentUri,
                            overwriteRange: overwriteRange,
                            bCIMFile: bCIMFile
                        };
                        promises.push(that.addFileReferenceCompletions(context));
                    });
                    return Promise.all(promises).then(completionItemsArray => {
                        completionItemsArray.forEach(completionItems => {
                            if (completionItems) {
                                result.push(...completionItems);
                            }
                        });
                        return result;
                    });
                }));
            }
            // });
            // });
        });
    }
    hasEnumSchema(node, matchingSchemas) {
        for (let i = 0; i < matchingSchemas.length; i++) {
            let s = matchingSchemas[i];
            if (s.node === node && !s.inverted && s.schema) {
                let result = this.hasEnum(s.schema);
                if (result) {
                    return true;
                }
            }
        }
        return false;
    }
    hasEnum(s) {
        if (s.enum) {
            return true;
        }
        else if (Array.isArray(s.anyOf)) {
            for (let i = 0; i < s.anyOf.length; i++) {
                let schema = s.anyOf[i];
                let result = this.hasEnum(schema);
                if (result) {
                    return true;
                }
            }
        }
        return false;
    }
    getTypesForNodeWithoutSchema(types, document) {
        for (let item in PathUtil_1.MDKFileType) {
            let type = Number(item);
            if (!isNaN(type) && type !== PathUtil_1.MDKFileType.App && type !== PathUtil_1.MDKFileType.Service && type !== PathUtil_1.MDKFileType.CIM) {
                if (type === PathUtil_1.MDKFileType.i18n || type === PathUtil_1.MDKFileType.Style) {
                    if (PathUtil_1.PathUtil.getMDKFileType(document.uri) === PathUtil_1.MDKFileType.App) {
                        types.push(type);
                    }
                }
                else {
                    types.push(type);
                }
            }
        }
    }
    addFileReferenceCompletions(context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (context) {
                return this._getTypePathList(context.document, context.types, context.bCIMFile).then((typePathItems) => __awaiter(this, void 0, void 0, function* () {
                    let validArg = typePathItems.find((item, index, obj) => {
                        return (context.currentWord.startsWith(item + '/'));
                    });
                    if (validArg) {
                        let matchedType;
                        if (validArg.split('/').length > 2) { //File path includes subfolder
                            matchedType = context.types.find(type => {
                                return context.currentWord.indexOf('/' + PathUtil_1.PathUtil.getFileFolder(type)) > 0;
                            });
                        }
                        else {
                            matchedType = PathUtil_1.MDKFileType.App; //File path for .app type
                        }
                        let tmpFolders = validArg.split('/');
                        let appName = tmpFolders[1];
                        let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(context.document, this._documentProvider);
                        let appInfo = yield appDelegate.getApplicationInfo();
                        let anchorDocumentUri;
                        if (appName === appInfo.name) {
                            anchorDocumentUri = context.document;
                        }
                        else if (this._appContext && this._appContext.referenceApps) {
                            let referenceApp = this._appContext.referenceApps.find(item => item.name === appName && item.comp === appInfo.name && this._documentProvider.isExistSync(item.path));
                            if (referenceApp) {
                                anchorDocumentUri = referenceApp.path;
                            }
                        }
                        return this._getFilePathList(anchorDocumentUri, matchedType).then(filePathList => {
                            let completionItems = [];
                            if (filePathList) {
                                let posLastSlash = context.currentWord.lastIndexOf('/');
                                let prefix = context.currentWord.substring(validArg.length + 1, posLastSlash + 1);
                                let overwriteRange = mdkLanguageTypes_1.Range.create(mdkLanguageTypes_1.Position.create(context.overwriteRange.start.line, context.overwriteRange.start.character + posLastSlash + 2), context.overwriteRange.end);
                                filePathList.forEach(filePath => {
                                    if (filePath.startsWith(prefix)) {
                                        let label = filePath.substr(posLastSlash - validArg.length);
                                        let completionItem = mdkLanguageTypes_1.CompletionItem.create(label);
                                        completionItem.filterText = context.value[0] + validArg + '/' + filePath;
                                        completionItem.textEdit = mdkLanguageTypes_1.TextEdit.replace(overwriteRange, label);
                                        completionItem.detail = "Full path: \n" + completionItem.filterText.substring(1);
                                        completionItems.push(completionItem);
                                    }
                                });
                            }
                            return completionItems;
                        });
                    }
                    else {
                        validArg = typePathItems.find((item, index, obj) => {
                            return item.startsWith(context.currentWord);
                        });
                        if (validArg || context.currentWord.length === 0) {
                            let completionItems = [];
                            let typePaths = (typePathItems.map(item => item + "/"));
                            if (typePaths) {
                                typePaths.forEach(typePath => {
                                    let completionItem = mdkLanguageTypes_1.CompletionItem.create(typePath);
                                    completionItem.filterText = context.value[0] + typePath;
                                    completionItem.textEdit = mdkLanguageTypes_1.TextEdit.replace(context.overwriteRange, completionItem.filterText);
                                    completionItem.command = {
                                        title: 'Suggest',
                                        command: 'editor.action.triggerSuggest'
                                    };
                                    completionItems.push(completionItem);
                                });
                            }
                            return completionItems;
                        }
                        else {
                            return [];
                        }
                    }
                }));
            }
        });
    }
    _getTypePathList(anchorDocumentUri, types, bCIMFile) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = [];
            let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(anchorDocumentUri, this._documentProvider);
            let appInfo = yield appDelegate.getApplicationInfo();
            if (!appInfo) {
                return result;
            }
            let appNames = [];
            if (appInfo.name) {
                appNames.push(appInfo.name);
            }
            if (!bCIMFile) {
                if (this._appContext && this._appContext.referenceApps) {
                    this._appContext.referenceApps.forEach(referenceApp => {
                        if (referenceApp.comp === appInfo.name && this._documentProvider.isExistSync(referenceApp.path)) {
                            appNames.push(referenceApp.name);
                        }
                    });
                }
                appNames = _.uniq(appNames);
            }
            for (const appName of appNames) {
                for (const type of types) {
                    if (type !== PathUtil_1.MDKFileType.App) {
                        result.push('/' + appName + '/' + PathUtil_1.PathUtil.getFileFolder(type));
                        if (type === PathUtil_1.MDKFileType.Image && result.indexOf("sap-icon:/") < 0) {
                            result.push("sap-icon:/");
                        }
                    }
                    else {
                        result.push('/' + appName);
                    }
                }
            }
            return result;
        });
    }
    _getFilePathList(anchorDocumentUri, type) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = [];
            if (!anchorDocumentUri) {
                return [];
            }
            let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(anchorDocumentUri, this._documentProvider);
            let typeFileFullPaths = yield appDelegate.getMDKTypeFileFullPaths(type);
            for (const typeFileFullPath of typeFileFullPaths) {
                result.push(yield appDelegate.getMDKTypeFileRelativeReference(type, typeFileFullPath));
            }
            return result;
        });
    }
}
exports.FileReferenceCompletion = FileReferenceCompletion;
function _getTextValueFromEsprimaLoc(document, position, loc) {
    let startPosition = RuleHelper_1.RuleHelper.getPositionFromEsprimaPosition(loc.start);
    let endPosition = RuleHelper_1.RuleHelper.getPositionFromEsprimaPosition(loc.end);
    if (LanguageHelper_1.LanguageHelper.Position.isAfter(position, startPosition) && LanguageHelper_1.LanguageHelper.Position.isBefore(position, endPosition)) {
        let range = RuleHelper_1.RuleHelper.getRangeFromEsprimaLocation(loc);
        return document.getText(range);
    }
}
function _getOverwriteRangeFromEsprimaLoc(loc) {
    return mdkLanguageTypes_1.Range.create(RuleHelper_1.RuleHelper.getPositionFromEsprimaPosition(loc.start), mdkLanguageTypes_1.Position.create(loc.end.line - 1, loc.end.column - 1));
}
//# sourceMappingURL=FileReferenceCompletion.js.map