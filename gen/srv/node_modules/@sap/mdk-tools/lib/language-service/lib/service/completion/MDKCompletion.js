"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MDKCompletion = void 0;
const URL = require("url");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const LanguageHelper_1 = require("../../common/LanguageHelper");
const SchemaVersionAdapter_1 = require("../../tool/SchemaVersionAdapter");
const SchemaProvider_1 = require("../schema/SchemaProvider");
const SchemaService_1 = require("../schema/SchemaService");
let JSONCompletion = require('vscode-json-languageservice/lib/umd/services/jsonCompletion.js').JSONCompletion;
let workspaceContext = {
    resolveRelativePath: (relativePath, resource) => {
        return URL.resolve(resource, relativePath);
    }
};
let currentDocument = null;
let currentJsonDocument = null;
let _appContext;
let schemaRequestService = (fsPath) => {
    return SchemaVersionAdapter_1.SchemaVersionHelper.getApplicationSchemaVersion(currentDocument.uri).then(schemaVersion => {
        return SchemaProvider_1.SchemaProvider.getInstance(schemaVersion).getSchema(fsPath, currentJsonDocument, currentDocument.uri, _appContext);
    });
};
var SchemaType;
(function (SchemaType) {
    SchemaType[SchemaType["object"] = 0] = "object";
    SchemaType[SchemaType["string"] = 1] = "string";
    SchemaType[SchemaType["enum"] = 2] = "enum";
    SchemaType[SchemaType["boolean"] = 3] = "boolean";
    SchemaType[SchemaType["number"] = 4] = "number";
    SchemaType[SchemaType["unknown"] = 5] = "unknown";
})(SchemaType || (SchemaType = {}));
var SchemaTypeParseResult;
(function (SchemaTypeParseResult) {
    SchemaTypeParseResult[SchemaTypeParseResult["allEnums"] = 0] = "allEnums";
    SchemaTypeParseResult[SchemaTypeParseResult["allStrings"] = 1] = "allStrings";
    SchemaTypeParseResult[SchemaTypeParseResult["hasBoolean"] = 2] = "hasBoolean";
    SchemaTypeParseResult[SchemaTypeParseResult["reserved"] = 3] = "reserved";
})(SchemaTypeParseResult || (SchemaTypeParseResult = {}));
class MDKCompletion {
    constructor() {
        let schemaService = new SchemaService_1.MDKSchemaService(schemaRequestService, workspaceContext, Promise);
        this._mdkCompletion = new JSONCompletion(schemaService, [], Promise);
    }
    setup(document, context) {
        return __awaiter(this, void 0, void 0, function* () {
            _appContext = context;
        });
    }
    provideCompletionItemsForJSON(document, position, jsonDocument, matchingSchemas) {
        return __awaiter(this, void 0, void 0, function* () {
            currentDocument = document;
            currentJsonDocument = jsonDocument;
            let offset = document.offsetAt(position);
            let node = jsonDocument.getNodeFromOffset(offset);
            let nodeSchemas = LanguageHelper_1.LanguageHelper.findNodeSchema(node, matchingSchemas);
            // consider the case of auto triggerring
            if (node.type === 'property' && node.keyNode && !node.valueNode &&
                node.keyNode.type === 'string' && node.keyNode.value) {
                for (let schema of nodeSchemas) {
                    if (schema.type === 'object' && schema.properties) {
                        let propertySchema = schema.properties[node.keyNode.value];
                        if (propertySchema) {
                            if (propertySchema.anyOf) {
                                nodeSchemas = propertySchema.anyOf;
                            }
                            else if (propertySchema.allOf) {
                                nodeSchemas = propertySchema.allOf;
                            }
                            else {
                                nodeSchemas = [propertySchema];
                            }
                            break;
                        }
                    }
                }
            }
            return this._mdkCompletion.doComplete(document, position, currentJsonDocument).then(completionList => {
                completionList.items.forEach(item => {
                    for (let nodeSchema of nodeSchemas) {
                        if (nodeSchema && nodeSchema.properties) {
                            let propSchema = nodeSchema.properties[item.label];
                            if (propSchema) {
                                let result = this._parseSchemaFirstLevelType(propSchema);
                                if (result === SchemaTypeParseResult.allEnums) {
                                    if (!item.command) {
                                        item.command = {
                                            command: 'editor.action.triggerSuggest',
                                            title: 'Suggest'
                                        };
                                    }
                                }
                                else if (result === SchemaTypeParseResult.allStrings) {
                                    if (item.insertText) {
                                        let parts = item.insertText.split(':');
                                        item.insertText = parts[0] + ': "$1"';
                                        item.textEdit.newText = item.insertText;
                                    }
                                    if (!item.command) {
                                        item.command = {
                                            command: 'editor.action.triggerSuggest',
                                            title: 'Suggest'
                                        };
                                    }
                                }
                                else if (result === SchemaTypeParseResult.hasBoolean) {
                                    if (item.insertText) {
                                        let parts = item.insertText.split(':');
                                        if (parts.length < 2) {
                                            item.insertText = parts[0] + ': ';
                                            item.textEdit.newText = item.insertText;
                                        }
                                    }
                                    if (!item.command) {
                                        item.command = {
                                            command: 'editor.action.triggerSuggest',
                                            title: 'Suggest'
                                        };
                                    }
                                }
                                break;
                            }
                        }
                    }
                });
                let resultItems = this._filterDuplicatedEnumValues(completionList.items, nodeSchemas);
                return resultItems;
            });
        });
    }
    _filterDuplicatedEnumValues(items, nodeSchemas) {
        let resultItems = [];
        let enumValues = [];
        let uniqueEnumValues = [];
        for (let schema of nodeSchemas) {
            if (schema.enum) {
                schema.enum.forEach(schemaValue => {
                    schemaValue = '"' + schemaValue + '"';
                    enumValues.push(schemaValue);
                    let needAppend = true;
                    let position = uniqueEnumValues.findIndex(enumValue => {
                        if (schemaValue.toLocaleLowerCase() === enumValue.toLocaleLowerCase()) {
                            if (schemaValue < enumValue) {
                                return true;
                            }
                            else {
                                needAppend = false;
                            }
                        }
                    });
                    if (position >= 0) {
                        uniqueEnumValues.splice(position, 1);
                    }
                    if (needAppend) {
                        uniqueEnumValues.push(schemaValue);
                    }
                });
            }
        }
        for (let item of items) {
            if (item.kind === vscode_languageserver_types_1.CompletionItemKind.Value && enumValues.some(enumValue => {
                if (enumValue === item.label) {
                    return true;
                }
            })) {
                if (uniqueEnumValues.some(uniqueEnmuValue => {
                    if (uniqueEnmuValue === item.label) {
                        return true;
                    }
                })) {
                    resultItems.push(item);
                }
            }
            else {
                resultItems.push(item);
            }
        }
        return resultItems;
    }
    provideCompletionItemsForJS(document, position) {
        return __awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    _parseSchemaFirstLevelType(schema) {
        let schemaTypes = [];
        this._visitShemaObject(schema, schemaTypes);
        let countEnum = 0;
        let countString = 0;
        let countBoolean = 0;
        schemaTypes.forEach(type => {
            if (type === SchemaType.enum) {
                countEnum++;
            }
            else if (type === SchemaType.string) {
                countString++;
            }
            else if (type === SchemaType.boolean) {
                countBoolean++;
            }
        });
        if (countEnum > 0 && countEnum === schemaTypes.length) {
            return SchemaTypeParseResult.allEnums;
        }
        else if (countString + countEnum === schemaTypes.length) {
            return SchemaTypeParseResult.allStrings;
        }
        else if (countBoolean > 0) {
            return SchemaTypeParseResult.hasBoolean;
        }
        else {
            return SchemaTypeParseResult.reserved;
        }
    }
    _visitShemaObject(schema, schemaTypes) {
        if (schema) {
            if (schema.enum) {
                schemaTypes.push(SchemaType.enum);
            }
            else if (Array.isArray(schema.anyOf)) {
                schema.anyOf.forEach(childSchema => {
                    this._visitShemaObject(childSchema, schemaTypes);
                });
            }
            else if (Array.isArray(schema.allOf)) {
                schema.allOf.forEach(childSchema => {
                    this._visitShemaObject(childSchema, schemaTypes);
                });
            }
            else if (schema.type) {
                schemaTypes.push(this._convertToSchemaType(schema.type));
            }
        }
    }
    _convertToSchemaType(type) {
        if (type === 'string') {
            return SchemaType.string;
        }
        else if (type === 'object') {
            return SchemaType.object;
        }
        else if (type === 'boolean') {
            return SchemaType.boolean;
        }
        else if (type === 'number') {
            return SchemaType.number;
        }
        else {
            return SchemaType.unknown;
        }
    }
}
exports.MDKCompletion = MDKCompletion;
//# sourceMappingURL=MDKCompletion.js.map