"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TargetPathCompletion = void 0;
const cache_1 = require("../../cache");
const LanguageHelper_1 = require("../../common/LanguageHelper");
const ODataMetadataProvider_1 = require("../../common/ODataMetadataProvider");
const RuleHelper_1 = require("../../common/RuleHelper");
const TargetHelper_1 = require("../../common/TargetHelper");
const MDKApplicationDelegate_1 = require("../../export/MDKApplicationDelegate");
const mdkLanguageTypes_1 = require("../../mdkLanguageTypes");
const SchemaVersionAdapter_1 = require("../../tool/SchemaVersionAdapter");
const AppDataSegment_1 = require("../targetpath/segments/AppDataSegment");
const ApplicationSegment_1 = require("../targetpath/segments/ApplicationSegment");
const FilterValueSegment_1 = require("../targetpath/segments/FilterValueSegment");
const SelectedRowSegment_1 = require("../targetpath/segments/SelectedRowSegment");
const SelectedTargetSegment_1 = require("../targetpath/segments/SelectedTargetSegment");
const Context_1 = require("./../targetpath/Context");
const TargetPathInterpreter_1 = require("./../targetpath/TargetPathInterpreter");
const ActionResultsSegment_1 = require("./../targetpath/segments/ActionResultsSegment");
const ClientDataSegment_1 = require("./../targetpath/segments/ClientDataSegment");
const ControlSegment_1 = require("./../targetpath/segments/ControlSegment");
const CountSegment_1 = require("./../targetpath/segments/CountSegment");
const FirstSegment_1 = require("./../targetpath/segments/FirstSegment");
const IndexSegment_1 = require("./../targetpath/segments/IndexSegment");
const LastSegment_1 = require("./../targetpath/segments/LastSegment");
const PageSegment_1 = require("./../targetpath/segments/PageSegment");
const PropertySegment_1 = require("./../targetpath/segments/PropertySegment");
const SegmentFactory_1 = require("./../targetpath/segments/SegmentFactory");
const SelectedValueSegment_1 = require("./../targetpath/segments/SelectedValueSegment");
const ValueSegment_1 = require("./../targetpath/segments/ValueSegment");
const _ = require("lodash");
class TargetPathCompletion {
    constructor(documentProvider) {
        this._overwriteRange = null;
        this._documentProvider = documentProvider;
    }
    initContext(document) {
        return __awaiter(this, void 0, void 0, function* () {
            this._context = new Context_1.Context();
            let referenceApps;
            if (this._appContext) {
                referenceApps = this._appContext.referenceApps;
            }
            let pages = yield cache_1.cache.getPages(document.uri, this._documentProvider);
            if (!pages) {
                pages = yield LanguageHelper_1.LanguageHelper.getAllPages(document.uri, this._documentProvider, referenceApps);
            }
            this._context.pages = pages;
            let fragments = yield cache_1.cache.getFragments(document.uri, this._documentProvider);
            if (!fragments) {
                fragments = yield LanguageHelper_1.LanguageHelper.getAllFragments(document.uri, this._documentProvider, referenceApps);
            }
            this._context.fragments = fragments;
            let actionResults = yield cache_1.cache.getActionResults(document.uri, this._documentProvider);
            if (!actionResults) {
                actionResults = yield LanguageHelper_1.LanguageHelper.getAllActionResults(document.uri, this._documentProvider, referenceApps);
            }
            this._context.actionResults = actionResults;
            this._context.appContext = this._appContext;
            this._context.documentProvider = this._documentProvider;
        });
    }
    setup(document, context) {
        return __awaiter(this, void 0, void 0, function* () {
            this._overwriteRange = null;
            this._appContext = context;
        });
    }
    provideCompletionItemsForJS(document, position) {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            let found = false;
            let result;
            let esprima = require('esprima');
            esprima.parseModule(document.getText(), {
                loc: true,
                tokens: true,
                comment: true,
                tolerant: true
            }, function (node, loc) {
                if (!found && node.type === "Literal") {
                    let startPosition = RuleHelper_1.RuleHelper.getPositionFromEsprimaPosition(loc.start);
                    let endPosition = RuleHelper_1.RuleHelper.getPositionFromEsprimaPosition(loc.end);
                    if (LanguageHelper_1.LanguageHelper.Position.isAfter(position, startPosition) && LanguageHelper_1.LanguageHelper.Position.isBefore(position, endPosition)) {
                        found = true;
                        result = that.provideCompletionItems(document, position, node);
                    }
                }
            });
            if (result) {
                return result.then(items => {
                    return that._handleResultCompletionItems(items);
                });
            }
            return Promise.resolve([]);
        });
    }
    provideCompletionItemsForJSON(document, position, jsonDocument, matchingSchemas) {
        return __awaiter(this, void 0, void 0, function* () {
            let offset = document.offsetAt(position);
            let node = jsonDocument.getNodeFromOffset(offset);
            if (!LanguageHelper_1.LanguageHelper.isStringValue(node)) {
                return Promise.resolve([]);
            }
            let completions = yield this.provideCompletionItems(document, position, node);
            return this._handleResultCompletionItems(completions);
        });
    }
    _handleResultCompletionItems(completions) {
        if (!completions) {
            return [];
        }
        return completions.map((item) => {
            if (this._overwriteRange) {
                item.filterText = item.insertText;
                item.textEdit = mdkLanguageTypes_1.TextEdit.replace(this._overwriteRange, item.insertText);
            }
            return item;
        });
    }
    provideCompletionItems(document, position, node) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.initContext(document);
            let prefix = this.getCurrentWord(document, position);
            let lastChar = prefix[prefix.length - 1];
            if (lastChar === '#') {
                let segments = yield this.getAvailableSegments(document.uri, prefix);
                if (segments) {
                    let result = segments.map(segment => {
                        let completionItem = { label: segment };
                        if (segment === 'Index') {
                            completionItem.insertText = segment + ':${1:IndexNumber}';
                            completionItem.insertTextFormat = mdkLanguageTypes_1.InsertTextFormat.Snippet;
                        }
                        return completionItem;
                    });
                    return Promise.resolve(result);
                }
            }
            else if (lastChar === ':') {
                return this.getAvailableSpecifies(document.uri, prefix, node);
            }
            else if (prefix[0] === '{') {
                let value = prefix.slice(1, -1);
                return this.getBindingList(document.uri, node, value);
            }
            else if (prefix === "#Application/#AppData/") {
                let contextCopy = _.clone(this._context);
                contextCopy.currentNode = node;
                contextCopy.anchorDocumentUri = document.uri;
                let context = yield this.getContext(prefix.slice(0, -1), contextCopy);
                return this._getProperties(context.binding);
            }
            return Promise.resolve([]);
        });
    }
    getCurrentWord(document, position) {
        let offset = document.offsetAt(position);
        let text = document.getText();
        text = text.substring(0, offset);
        let doubleQuotePos = text.lastIndexOf('"');
        let singleQuotePos = text.lastIndexOf('\'');
        let doubleBracketPos = text.lastIndexOf('{{');
        let startPos = Math.max(doubleQuotePos, singleQuotePos);
        if (doubleBracketPos > startPos) {
            startPos = doubleBracketPos + 2;
        }
        else {
            startPos++;
        }
        return text.substring(startPos, offset);
    }
    getAvailableSegments(anchorDocumentUri, prefix) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = [];
            let targetPath = this.getTargetPath(prefix);
            if (targetPath === undefined) {
                return result;
            }
            let context = yield this.getContext(targetPath, this._context);
            let alternativeSegments = [
                [SegmentFactory_1.SegmentFactory.ACTION_RESULTS, new ActionResultsSegment_1.ActionResultsSegment('dummy', context)],
                [SegmentFactory_1.SegmentFactory.CLIENT_DATA, new ClientDataSegment_1.ClientDataSegment(null, context)],
                [SegmentFactory_1.SegmentFactory.CONTROL, new ControlSegment_1.ControlSegment('dummy', context)],
                [SegmentFactory_1.SegmentFactory.COUNT, new CountSegment_1.CountSegment(null, context)],
                [SegmentFactory_1.SegmentFactory.FIRST, new FirstSegment_1.FirstSegment(null, context)],
                [SegmentFactory_1.SegmentFactory.INDEX, new IndexSegment_1.IndexSegment('0', context)],
                [SegmentFactory_1.SegmentFactory.LAST, new LastSegment_1.LastSegment(null, context)],
                [SegmentFactory_1.SegmentFactory.PAGE, new PageSegment_1.PageSegment('dummy', context)],
                [SegmentFactory_1.SegmentFactory.PROPERTY, new PropertySegment_1.PropertySegment('dummy', context)],
                [SegmentFactory_1.SegmentFactory.SELECTED_VALUE, new SelectedValueSegment_1.SelectedValueSegment(null, context)],
                [SegmentFactory_1.SegmentFactory.SELECTED_TARGET, new SelectedTargetSegment_1.SelectedTargetSegment(null, context)],
                [SegmentFactory_1.SegmentFactory.SELECTED_ROW, new SelectedRowSegment_1.SelectedRowSegment(null, context)],
                [SegmentFactory_1.SegmentFactory.VALUE, new ValueSegment_1.ValueSegment(null, context)],
                [SegmentFactory_1.SegmentFactory.APPLICATION, new ApplicationSegment_1.ApplicationSegment(null, context)],
                [SegmentFactory_1.SegmentFactory.FILTER_VALUE, new FilterValueSegment_1.FilterValueSegment(null, context)],
                [SegmentFactory_1.SegmentFactory.APP_DATA, new AppDataSegment_1.AppDataSegment(null, context)],
            ];
            alternativeSegments.forEach(item => {
                let segment = item[1];
                let segmentName = item[0];
                try {
                    segment.validateContext();
                    result.push(segmentName.slice(1));
                }
                catch (e) { }
            });
            return Promise.resolve(result);
        });
    }
    getTargetPath(prefix) {
        if (prefix && prefix.startsWith('#')) {
            if (prefix.length === 1) {
                return "";
            }
            else if (prefix.endsWith('/#')) {
                return prefix.slice(0, -2);
            }
            else if (prefix.endsWith(':')) {
                let index = prefix.lastIndexOf('/');
                if (index > -1) {
                    return prefix.slice(0, index);
                }
                else {
                    return "";
                }
            }
        }
    }
    getAvailableSpecifies(anchorDocumentUri, prefix, node) {
        return __awaiter(this, void 0, void 0, function* () {
            let targetPath = this.getTargetPath(prefix);
            if (targetPath === undefined) {
                return [];
            }
            let contextCopy = _.clone(this._context);
            contextCopy.currentNode = node;
            contextCopy.anchorDocumentUri = anchorDocumentUri;
            let context = yield this.getContext(targetPath, contextCopy);
            let segments = prefix.split('/');
            let currentSegment = segments[segments.length - 1];
            if (currentSegment.startsWith(SegmentFactory_1.SegmentFactory.PROPERTY)) {
                let segment = new PropertySegment_1.PropertySegment('dummy', context);
                segment.validateContext();
                if (targetPath.startsWith(SegmentFactory_1.SegmentFactory.APPLICATION)) {
                    return this._getProperties(context.binding);
                }
                let entitySet = context.binding ? context.binding.entitySet : null;
                return this.getMetadataEntityProperties(anchorDocumentUri, node, prefix, entitySet);
            }
            else if (currentSegment.startsWith(SegmentFactory_1.SegmentFactory.PAGE)) {
                let segment = new PageSegment_1.PageSegment('dummy', context);
                segment.validateContext();
                return this.getAllPageNames(anchorDocumentUri);
            }
            else if (currentSegment.startsWith(SegmentFactory_1.SegmentFactory.CONTROL)) {
                let segment = new ControlSegment_1.ControlSegment('dummy', context);
                segment.validateContext();
                let controls;
                let result = [];
                if (segments.length > 1) {
                    let page = context.element;
                    controls = page.controls;
                    if (controls) {
                        controls.forEach(control => {
                            if (control) {
                                result.push({ label: control.name });
                            }
                        });
                    }
                    else if (!page.definition) { // page from #Page:-Previous
                        let pageControls = yield this.getAllPageControls();
                        let fragmentControls = yield this.getAllFragmentControls();
                        return pageControls.concat(fragmentControls);
                    }
                }
                else {
                    let pageControls = yield this.getAllPageControls();
                    let fragmentControls = yield this.getAllFragmentControls();
                    return pageControls.concat(fragmentControls);
                }
                return result;
            }
            else if (currentSegment.startsWith(SegmentFactory_1.SegmentFactory.ACTION_RESULTS)) {
                return this._getAllActionResults();
            }
            return Promise.resolve([]);
        });
    }
    getAllPageNames(anchorDocumentUri) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = [];
            let pages = this._context.pages;
            if (pages) {
                pages.forEach(page => {
                    result.push({ label: page.definition._Name });
                });
            }
            yield SchemaVersionAdapter_1.SchemaVersionHelper.init(anchorDocumentUri);
            result = result.concat(SchemaVersionAdapter_1.completion.getTargetPathPageNames());
            // result.push({label: "-Previous"});
            return result;
        });
    }
    getAllPageControls() {
        return __awaiter(this, void 0, void 0, function* () {
            let controlPageMap = [];
            let pages = this._context.pages;
            if (pages) {
                pages.forEach(page => {
                    let controls = page.controls;
                    if (controls) {
                        controls.forEach(control => {
                            if (!controlPageMap[control.name]) {
                                controlPageMap[control.name] = [];
                            }
                            controlPageMap[control.name].push(page.relativePath);
                        });
                    }
                });
            }
            return this._generateCompletionItems(controlPageMap, "Contained in the following pages:\n");
        });
    }
    getAllFragmentControls() {
        return __awaiter(this, void 0, void 0, function* () {
            let controlFragmentMap = [];
            let fragments = this._context.fragments;
            if (fragments) {
                fragments.forEach(fragment => {
                    let controls = fragment.controls;
                    if (controls) {
                        controls.forEach(control => {
                            if (!controlFragmentMap[control.name]) {
                                controlFragmentMap[control.name] = [];
                            }
                            controlFragmentMap[control.name].push(fragment.relativePath);
                        });
                    }
                });
            }
            return this._generateCompletionItems(controlFragmentMap, "Contained in the following fragments:\n");
        });
    }
    _getAllActionResults() {
        return __awaiter(this, void 0, void 0, function* () {
            let map = [];
            let actionResults = this._context.actionResults;
            if (actionResults) {
                actionResults.forEach(actionResult => {
                    if (!map[actionResult.name]) {
                        map[actionResult.name] = [];
                    }
                    map[actionResult.name].push(actionResult.relativePath);
                });
            }
            return this._generateCompletionItems(map, "Contained in the following actions:\n");
        });
    }
    _generateCompletionItems(map, detailTitle) {
        let result = [];
        for (let key in map) {
            if (map.hasOwnProperty(key)) {
                let values = map[key];
                let completionItem = mdkLanguageTypes_1.CompletionItem.create(key);
                completionItem.detail = detailTitle;
                values.forEach(value => {
                    completionItem.detail += '\n' + value;
                });
                result.push(completionItem);
            }
        }
        return result;
    }
    getBindingList(anchorDocumentUri, node, bindingValue, entitySet) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = [];
            if (LanguageHelper_1.LanguageHelper.isODataBindingValueContext(node)) {
                let target = LanguageHelper_1.LanguageHelper.getTargetObject(node);
                let expandedProperties;
                if (target && target.Service) {
                    expandedProperties = TargetHelper_1.TargetHelper.getExpandedProperties(target);
                }
                let bindingType = yield LanguageHelper_1.LanguageHelper.resolveBindingValue(bindingValue, anchorDocumentUri, node, this._documentProvider, this._appContext);
                if (bindingType && bindingType.properties) {
                    for (let key in bindingType.properties) {
                        if (bindingType.properties.hasOwnProperty(key)) {
                            let value = bindingType.properties[key];
                            let filterOut = false;
                            if (value.description === 'navigationProperty') {
                                let newBindingValue = bindingValue ? bindingValue + '/' + key : key;
                                filterOut = !LanguageHelper_1.LanguageHelper.inExpandedProperties(newBindingValue, expandedProperties);
                            }
                            if (!filterOut) {
                                result.push({ label: key });
                            }
                        }
                    }
                }
                else if (bindingType.type === 'array') {
                    let completionItem = mdkLanguageTypes_1.CompletionItem.create('index');
                    completionItem.insertText = '${1:0}';
                    completionItem.insertTextFormat = mdkLanguageTypes_1.InsertTextFormat.Snippet;
                    result.push(completionItem);
                }
            }
            return result;
        });
    }
    getMetadataEntityProperties(anchorDocumentUri, node, prefix, entitySet) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = [];
            if (LanguageHelper_1.LanguageHelper.isODataBindingValueContext(node)) {
                let target = LanguageHelper_1.LanguageHelper.getTargetObject(node);
                if (target && target.Service && target.EntitySet) {
                    let properties;
                    if (!entitySet) {
                        entitySet = target.EntitySet;
                    }
                    let referenceApps;
                    if (this._appContext) {
                        referenceApps = this._appContext.referenceApps;
                    }
                    let baseAppDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(anchorDocumentUri, this._documentProvider, referenceApps);
                    let serviceFullPath = yield baseAppDelegate.toFileFullPath(target.Service);
                    properties = yield ODataMetadataProvider_1.ODataMetadataProvider.instance.getNonNavigationEntityProperties(serviceFullPath, entitySet, anchorDocumentUri);
                    let expandedProperties = TargetHelper_1.TargetHelper.getExpandedProperties(target);
                    if (expandedProperties) {
                        let path = '';
                        let parts = prefix.split('/');
                        if (parts.length > 1) {
                            for (let i = 0; i < parts.length - 1; i++) {
                                path += parts[i].substring(10) + '/'; // 10 is the length of '#Property:'
                            }
                        }
                        let addedProperties = [];
                        if (!!path) {
                            expandedProperties.forEach(p => {
                                if (p.startsWith(path)) {
                                    let start = path.length;
                                    let end = p.indexOf('/', start);
                                    if (end < 0) {
                                        addedProperties.push(p.substring(start));
                                    }
                                    else {
                                        addedProperties.push(p.substring(start, end));
                                    }
                                }
                            });
                        }
                        else {
                            expandedProperties.forEach(p => {
                                let pos = p.indexOf('/');
                                if (pos < 0) {
                                    addedProperties.push(p);
                                }
                                else {
                                    addedProperties.push(p.substring(0, pos));
                                }
                            });
                        }
                        if (addedProperties.length > 0) {
                            properties.push(..._.uniq(addedProperties));
                        }
                    }
                    if (properties) {
                        properties.forEach(property => {
                            result.push({ label: property });
                        });
                    }
                }
            }
            return result;
        });
    }
    getContext(targetPath, context) {
        return __awaiter(this, void 0, void 0, function* () {
            let tpi = new TargetPathInterpreter_1.TargetPathInterpreter(context);
            if (targetPath) {
                let newContext = tpi.evaluateTargetPathForContext(targetPath);
                return newContext;
            }
            return context;
        });
    }
    _getProperties(target) {
        let result = [];
        for (let key in target) {
            if (target.hasOwnProperty(key)) {
                result.push({ label: key });
            }
        }
        return result;
    }
}
exports.TargetPathCompletion = TargetPathCompletion;
//# sourceMappingURL=TargetPathCompletion.js.map