"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileReferenceDefinition = void 0;
const vscode_uri_1 = require("vscode-uri");
const LanguageHelper_1 = require("../../common/LanguageHelper");
const LogUtil_1 = require("../../common/LogUtil");
const PathUtil_1 = require("../../common/PathUtil");
const MDKApplicationDelegate_1 = require("../../export/MDKApplicationDelegate");
const mdkLanguageTypes_1 = require("../../mdkLanguageTypes");
class FileReferenceDefinition {
    constructor(documentProvider, appContext) {
        this._documentProvider = documentProvider;
        this._appContext = appContext;
    }
    provideDefinition(textDocument, position) {
        let that = this;
        let fileReference = LanguageHelper_1.LanguageHelper.getFileReference(textDocument, position);
        if (fileReference) {
            let fileFullPath = PathUtil_1.PathUtil.tryParseUri(textDocument.uri);
            return that._getFileReferenceLocation(fileReference, fileFullPath).then((location) => __awaiter(this, void 0, void 0, function* () {
                if (!location && PathUtil_1.PathUtil.getMDKFileType(fileFullPath) === PathUtil_1.MDKFileType.CIM && that._appContext) {
                    let documentProvider = that._documentProvider;
                    let baseAppDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(fileFullPath, documentProvider);
                    let cimAppInfo = yield baseAppDelegate.getApplicationInfoFromCimAnchor(that._appContext);
                    return that._getFileReferenceLocation(fileReference, cimAppInfo.fullPath);
                }
                return location;
            }));
        }
        return Promise.resolve(undefined);
    }
    _getFileReferenceLocation(fileReference, anchorDocumentFullPath) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let referenceApps;
                if (this._appContext) {
                    referenceApps = this._appContext.referenceApps;
                }
                let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(anchorDocumentFullPath, this._documentProvider, referenceApps);
                let filePath = yield appDelegate.toFileFullPath(fileReference);
                let isExist = yield this._documentProvider.isExist(filePath);
                if (isExist) {
                    return mdkLanguageTypes_1.Location.create(vscode_uri_1.default.file(filePath).toString(), mdkLanguageTypes_1.Range.create(mdkLanguageTypes_1.Position.create(0, 0), mdkLanguageTypes_1.Position.create(0, 0)));
                }
            }
            catch (error) {
                LogUtil_1.Log.debug(error);
            }
        });
    }
}
exports.FileReferenceDefinition = FileReferenceDefinition;
//# sourceMappingURL=FileReferenceDefinition.js.map