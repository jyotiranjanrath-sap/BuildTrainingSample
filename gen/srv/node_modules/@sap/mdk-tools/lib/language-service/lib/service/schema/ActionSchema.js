"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActionSchema = void 0;
const LanguageHelper_1 = require("../../common/LanguageHelper");
const LogUtil_1 = require("../../common/LogUtil");
const ODataMetadataProvider_1 = require("../../common/ODataMetadataProvider");
const MDKApplicationDelegate_1 = require("../../export/MDKApplicationDelegate");
class ActionSchema {
    getSchema(doc, documentUri, actionType, actionSchema, documentProvider, context) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (documentUri && actionType && actionType.startsWith('Action.Type.ODataService')) {
                    yield this._handleODataSerivceAction(doc, documentUri, actionType, actionSchema, documentProvider, context);
                }
            }
            catch (error) {
                LogUtil_1.Log.error(`Failed to get schema of action ${documentUri} with the error: ${error}`);
            }
            return actionSchema;
        });
    }
    _handleODataSerivceAction(doc, documentUri, actionType, actionSchema, documentProvider, context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (actionSchema && actionSchema.properties && actionSchema.properties.Properties) {
                let propertiesSchema = actionSchema.properties.Properties;
                if (propertiesSchema.type === 'object') {
                    yield this._populateEntityPropertiesSchema(doc, documentUri, actionType, propertiesSchema, documentProvider, context);
                }
            }
            let functionSchema = this._getFunctionSchema(doc, actionSchema);
            if (functionSchema) {
                let serviceInfo = this._findServiceInfo(doc);
                if (serviceInfo) {
                    let referenceApps;
                    if (context) {
                        referenceApps = context.referenceApps;
                    }
                    let baseAppDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(documentUri, documentProvider, referenceApps);
                    let serviceFullPath = yield baseAppDelegate.toFileFullPath(serviceInfo[0]);
                    yield LanguageHelper_1.LanguageHelper.populateFunctionSchema(documentUri, functionSchema, this._findFunctionName(doc), serviceFullPath);
                }
            }
        });
    }
    _populateEntityPropertiesSchema(doc, documentUri, actionType, propertiesSchema, documentProvider, context) {
        return __awaiter(this, void 0, void 0, function* () {
            let serviceInfo = this._findServiceInfo(doc);
            if (serviceInfo) {
                let referenceApps;
                if (context) {
                    referenceApps = context.referenceApps;
                }
                let baseAppDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(documentUri, documentProvider, referenceApps);
                let serviceFullPath = yield baseAppDelegate.toFileFullPath(serviceInfo[0]);
                let serviceMetadata = yield documentProvider.getDocumentJson(serviceFullPath);
                let schema = yield ODataMetadataProvider_1.ODataMetadataProvider.instance.getEntityPropertiesSchema(serviceFullPath, serviceInfo[1], documentUri, serviceMetadata && serviceMetadata["OfflineEnabled"]);
                if (schema) {
                    if (actionType !== "Action.Type.ODataService.CreateEntity") {
                        schema = schema.filter(item => {
                            return item.isNavigation === false;
                        });
                    }
                    let newSchema = {};
                    schema.forEach(item => {
                        newSchema[item.name] = this._processType(item);
                    });
                    propertiesSchema['properties'] = newSchema;
                    propertiesSchema["additionalProperties"] = schema.length > 0 ? false : true;
                }
            }
        });
    }
    _findServiceInfo(doc) {
        if (doc && doc.root) {
            let targetNode = doc.root.properties.filter(p => p.keyNode.value === "Target" || p.keyNode.value === "DesignTimeTarget");
            if (targetNode && targetNode.length > 0) {
                let targetValueNode = targetNode[0].valueNode;
                if (targetValueNode && targetValueNode.properties) {
                    let service = this._findTargetPropertyValue(targetValueNode, "Service");
                    let entitySet = this._findTargetPropertyValue(targetValueNode, "EntitySet");
                    return [service, entitySet];
                }
            }
        }
    }
    _processType(item) {
        if (item) {
            if (typeof item.type === "object") {
                return item.type;
            }
            if (item.type === "object") {
                if (item.properties) {
                    for (let key in item.properties) {
                        if (item.properties.hasOwnProperty(key)) {
                            item.properties[key] = this._processType(item.properties[key]);
                        }
                    }
                }
                return {
                    "anyOf": [
                        { "type": "string" },
                        {
                            "type": item.type,
                            "properties": item.properties
                        }
                    ]
                };
            }
            else if (item.type === "array") {
                if (item.items && item.items.properties) {
                    for (let key in item.items.properties) {
                        if (item.items.properties.hasOwnProperty(key)) {
                            item.items.properties[key] = this._processType(item.items.properties[key]);
                        }
                    }
                }
                return {
                    "anyOf": [
                        { "type": "string" },
                        {
                            "type": item.type,
                            "items": item.items
                        }
                    ]
                };
            }
            return { "type": item.type };
        }
        return {};
    }
    _findTargetPropertyValue(targetValueNode, propertyName) {
        let propertyNode = targetValueNode.properties.filter(p => p.keyNode.value === propertyName);
        if (propertyNode && propertyNode.length > 0 && propertyNode[0].valueNode) {
            return propertyNode[0].valueNode.value;
        }
    }
    _findFunctionName(doc) {
        if (doc && doc.root) {
            let targetNode = doc.root.properties.filter(p => p.keyNode.value === "Target" || p.keyNode.value === "DesignTimeTarget");
            if (targetNode && targetNode.length > 0 && targetNode[0].valueNode) {
                let targetValueNode = targetNode[0].valueNode;
                let functionNode = targetValueNode.properties.find(p => p.keyNode.value === 'Function');
                if (functionNode && functionNode.valueNode) {
                    functionNode = functionNode.valueNode;
                    let nameNode = functionNode.properties.find(p => p.keyNode.value === 'Name');
                    if (nameNode && nameNode.valueNode) {
                        return nameNode.valueNode.value;
                    }
                }
            }
        }
    }
    _getFunctionSchema(doc, actionSchema) {
        let machtingSchema = doc.getMatchingSchemas(actionSchema);
        let functionSchema = machtingSchema.find(item => item.node.type === 'object' && item.node.parent && item.node.parent.type === 'property' && item.node.parent.keyNode.value === 'Function');
        if (functionSchema) {
            return functionSchema.schema;
        }
    }
}
exports.ActionSchema = ActionSchema;
//# sourceMappingURL=ActionSchema.js.map