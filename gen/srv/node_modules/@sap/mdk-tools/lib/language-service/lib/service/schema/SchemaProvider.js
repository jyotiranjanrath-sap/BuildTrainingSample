"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaProvider = void 0;
const Json = require("jsonc-parser");
const _ = require("lodash");
const path = require("path");
const ExtensionPointHelper_1 = require("../../common/ExtensionPointHelper");
const LanguageHelper_1 = require("../../common/LanguageHelper");
const LogUtil_1 = require("../../common/LogUtil");
const PathUtil_1 = require("../../common/PathUtil");
const ActionSchema_1 = require("./ActionSchema");
const BrandedSettingsSchema_1 = require("./BrandedSettingsSchema");
const MDKProjectSchema_1 = require("./MDKProjectSchema");
const PageSchema_1 = require("./PageSchema");
const SchemaFileProvider_1 = require("./SchemaFileProvider");
class SchemaProvider {
    constructor(documentProvider, version) {
        SchemaProvider._documentProvider = documentProvider;
        if (!version) {
            version = LanguageHelper_1.LanguageHelper.getDefaultSchemaVersion(documentProvider);
        }
        this._init(version);
    }
    static init(documentProvider, version) {
        SchemaProvider._documentProvider = documentProvider;
        let oSchemaProvider = new SchemaProvider(documentProvider, version);
        SchemaProvider._defSchemaVersion = oSchemaProvider.schemaVersion;
        SchemaProvider._instance.set(oSchemaProvider.schemaVersion, oSchemaProvider);
        // preloading for other schema versions
        let _supportSchemaVersion = LanguageHelper_1.LanguageHelper.getSupportSchemaVersion(documentProvider);
        if (_supportSchemaVersion) {
            // only preload 2 schema versions including the default schema version for performation consideration
            _supportSchemaVersion.slice(-2).filter(item => item !== SchemaProvider._defSchemaVersion).forEach(item => {
                let oSchemaProvider = new SchemaProvider(documentProvider, item);
                SchemaProvider._instance.set(oSchemaProvider.schemaVersion, oSchemaProvider);
            });
        }
    }
    // static init(documentProvider: IMDKDocumentProvider, version?: string) {
    // 	SchemaProvider._documentProvider = documentProvider;
    // 	SchemaProvider._instance = new SchemaProvider(documentProvider, version);
    // }
    // static get instance(): ISchemaProvider {
    // 	if (!SchemaProvider._instance) {
    // 		SchemaProvider._instance = new SchemaProvider(SchemaProvider._documentProvider);
    // 	}
    // 	return SchemaProvider._instance;
    // }
    static getInstance(schemaVer) {
        let _schemaVersion = SchemaProvider._defSchemaVersion;
        if (schemaVer) {
            // only when schemaVer is specified and it is one of the SupportSchemaVersion that defined in package.json
            let _supportSchemaVersion = LanguageHelper_1.LanguageHelper.getSupportSchemaVersion(SchemaProvider._documentProvider);
            if (_supportSchemaVersion && _supportSchemaVersion.indexOf(schemaVer) >= 0) {
                _schemaVersion = schemaVer;
            }
        }
        let oSchemaProvider = SchemaProvider._instance.get(_schemaVersion);
        if (!oSchemaProvider) {
            oSchemaProvider = new SchemaProvider(SchemaProvider._documentProvider, _schemaVersion);
            SchemaProvider._instance.set(oSchemaProvider.schemaVersion, oSchemaProvider);
        }
        return oSchemaProvider;
    }
    static getDefaultSchemaVersion() {
        return SchemaProvider._defSchemaVersion;
    }
    get schemaFileProvider() {
        return this._fileProvider;
    }
    get schemaVersion() {
        return this._fileProvider.getSchemaVersion();
    }
    set schemaVersion(version) {
        if (!this._fileProvider || version !== this._fileProvider.getSchemaVersion()) {
            this._init(version);
        }
    }
    _init(version) {
        try {
            this._fileProvider = new SchemaFileProvider_1.SchemaFileProvider(version);
        }
        catch (error) {
            let latestVersion = LanguageHelper_1.LanguageHelper.getDefaultSchemaVersion(SchemaProvider._documentProvider);
            LogUtil_1.Log.debug(`Use the default schema version ${latestVersion} due to fail to create SchemaFileProvider with schema version ${version} with the error is: ${error}. `);
            if (version !== latestVersion) {
                this._fileProvider = new SchemaFileProvider_1.SchemaFileProvider(latestVersion);
                LogUtil_1.Log.info(`Use the latest schema version ${latestVersion}`);
            }
            else {
                this._fileProvider = null;
            }
        }
        this._cache = {};
        this._pageSchema = new PageSchema_1.PageSchema();
        this._actionSchema = new ActionSchema_1.ActionSchema();
        this._extensionPointHelper = new ExtensionPointHelper_1.ExtensionPointHelper();
    }
    /**
     *
     * @param schemaPath the schema file path
     * @param doc the meatadata object of JSONDocument defined in the vscode-json-languageservice extension
     */
    getSchema(schemaPath, doc, documentUri, context) {
        return __awaiter(this, void 0, void 0, function* () {
            let fileType = _.toLower(path.basename(schemaPath, '.schema'));
            let documentType = this.getDocumentType(doc, fileType);
            let id = this.generateId(fileType, documentType);
            LogUtil_1.Log.debug(`fileType is ${fileType}, documentType is ${documentType}, id is ${id}`);
            if (documentUri && path.basename(documentUri).toLowerCase() === "mdkproject.json") {
                return Promise.resolve(JSON.stringify(MDKProjectSchema_1.MDKProjectSchema));
            }
            if (documentUri && path.basename(documentUri).toLowerCase() === "brandedsettings.json") {
                return Promise.resolve(JSON.stringify(BrandedSettingsSchema_1.BrandedSettingsSchema));
            }
            if (!this._cache[id]) {
                let _this = this;
                let promises = [];
                let relSchemaPath = schemaPath.substring(LanguageHelper_1.LanguageHelper.getSchemaRootPath().length + 1);
                promises.push(this._getSchemaByPath(relSchemaPath));
                promises.push(this.getSchemaByType(fileType, documentType));
                this._cache[id] = Promise.all(promises).then(function (schemas) {
                    let schema;
                    schemas = _this._extensionPointHelper.addExtensionPoints(fileType, schemas);
                    if (fileType === 'page') {
                        schema = _this.combineSchemas(schemas);
                        if (!documentType) {
                            schema = _this._pageSchema.addUnknowControlSchema(schema);
                        }
                    }
                    else if (fileType === 'action' && !schemas[1]) {
                        return _this.addUnknowActionSchema(schemas[0]).then(schema => {
                            LogUtil_1.Log.debug('The calculated schema for action is ' + JSON.stringify(schema));
                            return schema;
                        });
                    }
                    else if (fileType === 'app') {
                        schema = _this.combineSchemas(schemas);
                        schema = _this.addSchemaVersionSchemaForApplication(schema);
                    }
                    else {
                        schema = _this.combineSchemas(schemas);
                        LogUtil_1.Log.debug('The calculated schema is ' + JSON.stringify(schema));
                    }
                    return schema;
                }).catch(error => {
                    LogUtil_1.Log.error('Getting schema with error: ' + error.toString());
                    return Promise.reject(error);
                });
            }
            return this._cache[id].then((schema) => __awaiter(this, void 0, void 0, function* () {
                let resultSchema = schema;
                if (fileType === 'page') {
                    resultSchema = yield this._pageSchema.getSchema(doc, documentType, schema, documentUri, SchemaProvider._documentProvider, context);
                    LogUtil_1.Log.debug(`The calculated schema for page[${documentType}] is ` + JSON.stringify(resultSchema));
                }
                else if (fileType === 'action') {
                    resultSchema = yield this._actionSchema.getSchema(doc, documentUri, documentType, schema, SchemaProvider._documentProvider, context);
                    LogUtil_1.Log.debug(`The calculated schema for action is ` + JSON.stringify(resultSchema));
                }
                return JSON.stringify(resultSchema);
            }));
        });
    }
    /**
     *
     * @param metadataPath the metadata file path
     * @param doc the metadata object of JSONDocument defined in the vscode-json-languageservice extension
     */
    getSchemaForMetadata(metadataPath, doc, context) {
        return __awaiter(this, void 0, void 0, function* () {
            let schemaName = PathUtil_1.PathUtil.getSchemaNameByMDKFile(metadataPath);
            if (schemaName) {
                let rootPath = LanguageHelper_1.LanguageHelper.getSchemaRootPath();
                let schemaPath = path.join(rootPath, schemaName);
                return this.getSchema(schemaPath, doc, metadataPath, context);
            }
            LogUtil_1.Log.debug(metadataPath + ' is invalid metadat path');
            return Promise.reject('invalid metadata path');
        });
    }
    getDocumentType(document, fileType) {
        if (document && document.root && document.root.type === 'object') {
            let typeProperties = document.root.properties.filter(p => p.keyNode.value === "_Type");
            if (typeProperties.length > 0 && typeProperties[0].valueNode) {
                let typeValue = typeProperties[0].valueNode.value;
                if (fileType === 'page') {
                    if (typeValue === 'Page') {
                        let ControlsProperties = document.root.properties.filter(p => p.keyNode.value === "Controls");
                        if (ControlsProperties.length > 0 &&
                            ControlsProperties[0].valueNode &&
                            ControlsProperties[0].valueNode.type === 'array' &&
                            ControlsProperties[0].valueNode.items &&
                            ControlsProperties[0].valueNode.items.length > 0 &&
                            ControlsProperties[0].valueNode.items[0].properties) {
                            for (let i = 0; i < ControlsProperties[0].valueNode.items.length; i++) {
                                let subTypeProperties = ControlsProperties[0].valueNode.items[i].properties.filter(p => p.keyNode.value === "_Type");
                                if (subTypeProperties.length > 0 && subTypeProperties[0].valueNode) {
                                    let subTypeValue = subTypeProperties[0].valueNode.value;
                                    if (ControlsProperties[0].valueNode.items.length > 1) {
                                        if (subTypeValue === "Control.Type.Tabs") {
                                            return this._pageSchema.getControlType(subTypeValue, this.schemaVersion);
                                        }
                                    }
                                    else {
                                        return this._pageSchema.getControlType(subTypeValue, this.schemaVersion);
                                    }
                                }
                            }
                        }
                    }
                    LogUtil_1.Log.debug('Not found document type for the fileType ' + fileType);
                    return null;
                }
                return typeValue;
            }
        }
        LogUtil_1.Log.debug('Not found document type for the fileType ' + fileType);
        return null;
    }
    generateId(fileType, documentType) {
        let _schemaVersion = this.schemaVersion ? (this.schemaVersion + ":") : "";
        if (fileType === 'action') {
            return _schemaVersion + fileType + ':' + this.getActionTypeName(documentType);
        }
        else if (fileType === 'global') {
            return _schemaVersion + fileType + ':' + this.getGlobalTypeName(documentType);
        }
        else if (fileType === 'page') {
            return _schemaVersion + fileType + ':' + documentType;
        }
        return _schemaVersion + fileType + ':';
    }
    combineSchemas(schemas) {
        if (schemas[1]) {
            _.merge(schemas[0], schemas[1]);
        }
        return schemas[0];
    }
    getSchemaByType(fileType, documentType) {
        return __awaiter(this, void 0, void 0, function* () {
            if (fileType === 'action') {
                return this.getSchemaByActionType(documentType);
            }
            else if (fileType === 'global') {
                return this.getSchemaByGlobalType(documentType);
            }
            else if (fileType === 'page') {
                return this.getSchemaByPageType(documentType);
            }
            return Promise.resolve(null);
        });
    }
    getSchemaByActionType(documentType) {
        return __awaiter(this, void 0, void 0, function* () {
            let type = this.getActionTypeName(documentType);
            if (type) {
                let actionTypeSchemaPath = path.join('Action', type + '.schema');
                return this._getSchemaByPath(actionTypeSchemaPath);
            }
            return Promise.resolve(null);
        });
    }
    getSchemaByPath(path) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._getSchemaByPath(path);
        });
    }
    getActionTypeName(documentType) {
        if (documentType) {
            let segs = documentType.split('.');
            if (segs.length < 3 || segs[0] !== 'Action' || segs[1] !== 'Type') {
                return null;
            }
            return segs.slice(2).join('/');
        }
        return null;
    }
    addUnknowActionSchema(schema) {
        if (!this._fileProvider) {
            return Promise.reject('There is no schema file provider available.');
        }
        else {
            return this._fileProvider.getActionTypes().then(types => {
                schema.properties._Type.pattern = undefined;
                schema.properties._Type.enum = types;
                return schema;
            });
        }
    }
    getSchemaByGlobalType(documentType) {
        return __awaiter(this, void 0, void 0, function* () {
            let type = this.getGlobalTypeName(documentType);
            if (type) {
                return this._getSchemaByPath(path.join('Global', _.startCase(type) + 'Global.schema'));
            }
            return Promise.resolve(null);
        });
    }
    getGlobalTypeName(documentType) {
        if (documentType) {
            let type = _.toLower(documentType);
            if (type === 'boolean' || type === 'number' || type === 'string') {
                return type;
            }
            else {
                LogUtil_1.Log.warn('found the unsupported global type ' + type);
                return null;
            }
        }
        return null;
    }
    getSchemaByPageType(documentType) {
        return __awaiter(this, void 0, void 0, function* () {
            if (documentType) {
                return this._getSchemaByPath(path.join('Page', documentType + 'Page.schema'));
            }
            return Promise.resolve(null);
        });
    }
    _getSchemaByPath(path) {
        return __awaiter(this, void 0, void 0, function* () {
            let _this = this;
            return new Promise((resolve, reject) => {
                LogUtil_1.Log.debug('getting schema by path: ' + path);
                if (!_this._fileProvider) {
                    return reject(`Getting schema for ${path} due to no schema file provider available.`);
                }
                else {
                    _this._fileProvider.getSchema(path).then(schemaString => {
                        if (!!schemaString) {
                            let jsonErrors = [];
                            let schemaContent = Json.parse(schemaString, jsonErrors);
                            if (jsonErrors.length > 0) {
                                reject(jsonErrors);
                            }
                            else {
                                return _this.getFlatedSchema(schemaContent).then(function (flatedSchema) {
                                    return resolve(flatedSchema);
                                });
                            }
                        }
                        else {
                            return resolve(null);
                        }
                    }, error => {
                        LogUtil_1.Log.error(`Getting schema for ${path} with error: ${error.toString()}`);
                        return resolve(null);
                    });
                }
            }).catch(error => {
                LogUtil_1.Log.error(`Getting schema for ${path} with error: ${error.toString()}`);
                Promise.reject(error);
            });
        });
    }
    getFlatedSchema(schema) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hasRefDefinition(schema)) {
                return Promise.resolve(schema);
            }
            else {
                let _this = this;
                let promises = _this.collectSchemaRequest(schema);
                return Promise.all(promises).then(function (result) {
                    return _this.getFlatedSchema(schema);
                });
            }
        });
    }
    hasRefDefinition(schema) {
        let _this = this;
        return _.some(schema, function (val, key) {
            if (_.isObject(val)) {
                return _this.hasRefDefinition(val);
            }
            else {
                if (key === "$ref") {
                    return true;
                }
            }
        });
    }
    collectSchemaRequest(oSchema) {
        let _this = this;
        let promises = [];
        _.each(oSchema, function (val, key, wrappingObj) {
            if (_.isObject(val)) {
                promises = promises.concat(_this.collectSchemaRequest(val));
            }
            else {
                if (key === "$ref") {
                    var sRefUrl = _this.getUrlFromSchemaRef(val);
                    if (sRefUrl) {
                        promises.push(new Promise((resolve, reject) => {
                            LogUtil_1.Log.debug('get subschema by reference: ' + sRefUrl);
                            if (!_this._fileProvider) {
                                return reject(`Collecting schema for ${sRefUrl} due to no schema file provider available.`);
                            }
                            else {
                                _this._fileProvider.getSchema(sRefUrl).then(schemaString => {
                                    if (!!schemaString) {
                                        let jsonErrors = [];
                                        let schemaContent = Json.parse(schemaString, jsonErrors);
                                        if (jsonErrors.length > 0) {
                                            reject(jsonErrors);
                                        }
                                        else {
                                            let refValue = wrappingObj["$ref"];
                                            let sections = _.split(refValue, '/');
                                            sections = _.take(sections, sections.length - 1);
                                            let refPath = _.join(sections, '/') + '/';
                                            _this.changeSubSchemaPath(refPath, schemaContent);
                                            delete wrappingObj["$ref"];
                                            _.merge(wrappingObj, schemaContent);
                                            resolve(wrappingObj);
                                        }
                                    }
                                    else {
                                        return resolve(null);
                                    }
                                }, error => {
                                    LogUtil_1.Log.error(`Collecting schema for ${sRefUrl} with error: ${error.toString()}`);
                                    return resolve(null);
                                });
                            }
                        }).catch(error => {
                            LogUtil_1.Log.error(`Collecting schema for ${sRefUrl} with error: ${error.toString()}`);
                            Promise.reject(error);
                        }));
                    }
                }
            }
        });
        return promises;
    }
    changeSubSchemaPath(parentPath, subSchema) {
        let _this = this;
        _.each(subSchema, function (val, key, oWrappingObj) {
            if (_.isObject(val) || _.isArray(val)) {
                _this.changeSubSchemaPath(parentPath, val);
            }
            else {
                if (key === "$ref") {
                    oWrappingObj["$ref"] = _.replace(val, './', parentPath);
                }
            }
        });
    }
    getUrlFromSchemaRef(ref) {
        var url = "";
        if (ref && ref[0] === '#' && ref[1] === '/') {
            url = ref.substr(2);
        }
        if (!_.endsWith(url, '.json')) {
            url += '.json';
        }
        return url;
    }
    addSchemaVersionSchemaForApplication(schema) {
        if (schema && schema.properties) {
            if (!this._schemaVersionschema) {
                let supportVersions = '';
                let _supportSchemaVersion = LanguageHelper_1.LanguageHelper.getSupportSchemaVersion(SchemaProvider._documentProvider);
                if (_supportSchemaVersion) {
                    _supportSchemaVersion.forEach((key) => {
                        supportVersions += `"${key}",`;
                    });
                    supportVersions = _.trimEnd(supportVersions, ',');
                }
                this._schemaVersionschema = JSON.parse(`{
					"properties": {
						"_SchemaVersion": {
							"enum": [ 
								${supportVersions}
							],
							"type": "string"
						}
					},
					"type": "object"
				}`);
            }
            _.merge(schema, this._schemaVersionschema);
        }
        return schema;
    }
}
exports.SchemaProvider = SchemaProvider;
// private static _instance: ISchemaProvider = null;
SchemaProvider._instance = new Map();
//# sourceMappingURL=SchemaProvider.js.map