"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TargetPathInterpreter = exports.TargetPathError = void 0;
const ErrorMessage_1 = require("../../common/ErrorMessage");
const ISegmentFactory_1 = require("./segments/ISegmentFactory");
const SegmentIterator_1 = require("./segments/SegmentIterator");
class TargetPathError extends Error {
}
exports.TargetPathError = TargetPathError;
/**
 * The entry point of the target path evaluation.
 * Target paths are a critical part of a metadata driven application. They are used in many places: for example, when
 * biding controls to data or when biding action parameters to screen elements.
 * This class is capable to translate a valid target path into a {@link Context} object, which can contain the
 * result of the evaluation.
 * In order to start the interpretation of a target path {@link TargetPathInterpreter#evaluateTargetPath} must be
 * called with the target path passed on. The syntactic and semantic validation of the target path is done during
 * the evaluation of each segment. The signalig of an error is done through the registered error handler. It is
 * possible to register an external error handler by calling {@link TargetPathInterpreter#registerErrorHandler}.
 * If no error handler is provided, a default error handler {@link DefaultTargetPathErrorHandler} will be used to
 * communicate errors.
 * The very first step of processing a target path is to split it into segments. A segment is considered to be a
 * series of characters separated by '/'. {@link SegmentIterator} provides helper methods to split up the target
 * path into segments and loop through each part.
 * Each segment can be described with an {@link ISegment} object, depending on what that segment addresses. For example
 * this segment #Page:CustomerPage, can be translated into a {@link PageSegment}, or #Service:Northind can be befitted
 * into a {@link ServiceSegment}. To provide the right implementation of {@link ISegment} it's the responsibility of
 * {@link ISegmentFactory} class.
 * A {@link Context} can be considered as a value object, which holds all the required information in order
 * to successfully evaluate a target path segment.
 * Each {@link ISegment} implementor must provide their own specific implementation of
 * {@link ISegment#resolve}. The {@link ISegment#resolve} tries to evaluate the
 * segment using the provided {@link Context}. After the evaluation finished successfully, the result will be
 * persisted in a {@link Context}. Since a target path can have many segments, therefore the output of one
 * segment evaluation {@link Context} can be the input of the next segment evaluation.
 */
class TargetPathInterpreter {
    /**
       * @constructor
       * @param {IContext} _context - The starting context. Assigned as a private property
       */
    constructor(_context) {
        this._context = _context;
    }
    /**
     * Start the processing of the target path.
     * @param {string} targetPath - target path string, mustn't be undefined or empty.
     * @returns {IContext} - A context holding the result of target path evaluation,
     *                      which can vary from a simple string to a view representation.
     * Can be undefined.
     */
    evaluateTargetPathForContext(targetPath) {
        return __awaiter(this, void 0, void 0, function* () {
            this.throwIfBadTargetPath(targetPath);
            this.targetPath = targetPath;
            let iterator = new SegmentIterator_1.SegmentIterator(targetPath);
            return this.onResolve(this._context, iterator);
        });
    }
    /**
     * Evaluate the target path and return the value from the resulting context.
     * @param {string} targetPath - the target path to be evaluated
     */
    evaluateTargetPathForValue(targetPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const context = yield this.evaluateTargetPathForContext(targetPath);
            // If an element is on the context, consider that the final value. Otherwise use binding.
            return context.element || context.binding;
        });
    }
    throwIfBadTargetPath(targetPath) {
        if (!targetPath) {
            const msg = ErrorMessage_1.ErrorMessage.TARGET_PATH_CANNOT_BE_EMPTY;
            throw new Error(msg);
        }
    }
    onResolve(context, iterator) {
        return __awaiter(this, void 0, void 0, function* () {
            let currentContext = context;
            let position = 0;
            while (iterator.hasNext()) {
                const segmentString = iterator.next();
                try {
                    currentContext.position = position;
                    const segment = ISegmentFactory_1.ISegmentFactory.build(segmentString.value, currentContext);
                    if (!segment) {
                        throw new Error(ErrorMessage_1.ErrorMessage.format(ErrorMessage_1.ErrorMessage.INVALID_SEGMENT, segmentString.value));
                    }
                    currentContext = yield segment.resolve();
                }
                catch (err) {
                    if (err instanceof TargetPathError) {
                        throw (err);
                    }
                    let error = new TargetPathError(err);
                    if (!err.location) {
                        error.location = this.buildLocation(segmentString.value, position);
                    }
                    else {
                        error.location = err.location;
                    }
                    throw (error);
                }
                position += segmentString.value.length + 1;
            }
            return currentContext;
        });
    }
    buildLocation(segmentString, position) {
        let start = position;
        let location = { start: start, end: start + segmentString.length };
        return location;
    }
}
exports.TargetPathInterpreter = TargetPathInterpreter;
//# sourceMappingURL=TargetPathInterpreter.js.map