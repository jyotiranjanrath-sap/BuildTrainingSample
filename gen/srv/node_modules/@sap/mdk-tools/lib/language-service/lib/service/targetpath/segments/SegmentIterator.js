"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SegmentIterator = void 0;
/**
 * Provides an iterator
 */
class SegmentIterator {
    /**
     * @constructor
     * @param {string} targetPath - target path string, can be empty or undefined.
     */
    constructor(targetPath) {
        this.targetPath = targetPath;
    }
    /**
     * Check for the existance of next segment.
     * @returns {boolean} - True if we haven't reach the end of the path.
     */
    hasNext() {
        if (this.targetPath && this.targetPath.length !== 0) {
            return true;
        }
        return false;
    }
    /**
     * @returns {IteratorResult} - The result object if the next segment exists.
     */
    next() {
        const done = !this.hasNext();
        const currentSegment = this.splitTargetPath();
        return {
            done,
            value: currentSegment,
        };
    }
    [Symbol.iterator]() {
        return this;
    }
    /**
     * Split the target path path at the first occurence if '/' mark. Escaped slashes like '//'
     * are not taken into consideration.
     * @returns {string} - The first segment of the target path
     */
    splitTargetPath() {
        if (!this.targetPath) {
            return undefined;
        }
        const firstSeparatorPos = this.findFirstSegmentSeparator(this.targetPath);
        let firstSegment = '';
        if (firstSeparatorPos === -1) {
            // no separator found, it means this is the last part
            firstSegment = this.targetPath;
            this.targetPath = '';
        }
        else {
            firstSegment = this.targetPath.slice(0, firstSeparatorPos);
            this.targetPath = this.targetPath.slice(firstSeparatorPos + 1, this.targetPath.length);
        }
        return firstSegment.replace(/\/\//g, '/');
    }
    /**
     * Finds the position of the first segment separator character
     * @param {string} targetPath - The target path
     * @returns {number} - The index of the first segment separator
     */
    findFirstSegmentSeparator(targetPath) {
        // find the first segment separator character
        const firstSeparatorPos = targetPath.indexOf(SegmentIterator.SEGMENT_SEPARATOR);
        // need to check whether this separator was not escaped
        if ((targetPath.charAt(firstSeparatorPos + 1) !== SegmentIterator.SEGMENT_SEPARATOR) || firstSeparatorPos === -1) {
            return firstSeparatorPos;
        }
        else {
            // separator was escaped, must find next separator character
            return firstSeparatorPos + 2 +
                this.findFirstSegmentSeparator(targetPath.slice(firstSeparatorPos + 2, targetPath.length));
        }
    }
}
exports.SegmentIterator = SegmentIterator;
SegmentIterator.SEGMENT_SEPARATOR = '/';
SegmentIterator.SELECTOR = '#';
//# sourceMappingURL=SegmentIterator.js.map