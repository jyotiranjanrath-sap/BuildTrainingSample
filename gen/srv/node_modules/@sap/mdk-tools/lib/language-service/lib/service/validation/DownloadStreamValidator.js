"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DownloadStreamValidator = void 0;
const Json = require("jsonc-parser");
const LanguageHelper_1 = require("../../common/LanguageHelper");
const LogUtil_1 = require("../../common/LogUtil");
const PathUtil_1 = require("../../common/PathUtil");
const MDKDefinitions_1 = require("../../export/MDKDefinitions");
const mdkLanguageTypes_1 = require("../../mdkLanguageTypes");
class DownloadStreamValidator {
    constructor(documentProvider) {
        if (!documentProvider) {
            LogUtil_1.Log.error("undefined documentProvider provided for DownloadStreamValidator.");
        }
        this._documentProvider = documentProvider;
        this._context = {};
    }
    isSupportDocument(document) {
        if (PathUtil_1.PathUtil.getMDKFileType(document.uri) === PathUtil_1.MDKFileType.Action) {
            let jsonErrors = [];
            let jsonObj = Json.parse(document.getText(), jsonErrors);
            return jsonObj['_Type'] === 'Action.Type.ODataService.DownloadStream';
        }
        return false;
    }
    setup(document, context) {
        return __awaiter(this, void 0, void 0, function* () {
            this._context[document.uri] = Object.assign({}, context);
        });
    }
    validateJsonDocument(document, jsonDocument) {
        return __awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    checkJsonNodeSync(document, node) {
        // let jsonErrors: Json.ParseError[] = [];
        // let jsonObj = Json.parse(document.getText(), jsonErrors);
        // return LanguageHelper.isPropertiesStringValue(node) && jsonObj['_Type'] === 'Action.Type.ODataService.DownloadStream';
        return LanguageHelper_1.LanguageHelper.isPropertiesStringValue(node);
    }
    validateJsonNode(document, node, schema) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._validateJsonNodeDownloadStreamProperty(document, node, schema);
        });
    }
    checkJsNodeSync(document, node) {
        return false;
    }
    validateJsNode(document, node, loc) {
        return __awaiter(this, void 0, void 0, function* () {
            // tbd
            return [];
        });
    }
    cleanup(document, diagnostics) {
        return __awaiter(this, void 0, void 0, function* () {
            this._context[document.uri] = null;
            return diagnostics;
        });
    }
    _validateJsonNodeDownloadStreamProperty(document, node, schema) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = [];
            let streamProperties = yield LanguageHelper_1.LanguageHelper.getStreamProperties(document.uri, node, this._documentProvider, this._context[document.uri].referenceApps);
            if (streamProperties) {
                let existed = streamProperties.some(item => item === node.value);
                if (!existed) {
                    let errorMessage = `Invalid stream property ${node.value}`;
                    let range = mdkLanguageTypes_1.Range.create(document.positionAt(node.offset + 1), document.positionAt(node.offset + 1 + node.value.length));
                    result.push({
                        range: range,
                        severity: mdkLanguageTypes_1.DiagnosticSeverity.Error,
                        message: errorMessage
                    });
                }
            }
            result.forEach(item => item.source = MDKDefinitions_1.MDKValidator.DownloadStream);
            return result;
        });
    }
}
exports.DownloadStreamValidator = DownloadStreamValidator;
//# sourceMappingURL=DownloadStreamValidator.js.map