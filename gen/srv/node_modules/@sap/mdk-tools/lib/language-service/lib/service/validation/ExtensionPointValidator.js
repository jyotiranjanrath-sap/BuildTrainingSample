"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtensionPointValidator = void 0;
const fs = require("fs-extra");
const path = require("path");
const URL = require("url");
const vscode_uri_1 = require("vscode-uri");
const LogUtil_1 = require("../../common/LogUtil");
const PathUtil_1 = require("../../common/PathUtil");
const MDKApplicationDelegate_1 = require("../../export/MDKApplicationDelegate");
const MDKDefinitions_1 = require("../../export/MDKDefinitions");
const mdkLanguageTypes_1 = require("../../mdkLanguageTypes");
const ExtensionPointValidationHelper_1 = require("../../tool/ExtensionPointValidationHelper");
const SchemaVersionAdapter_1 = require("../../tool/SchemaVersionAdapter");
const SchemaProvider_1 = require("../schema/SchemaProvider");
const SchemaService_1 = require("../schema/SchemaService");
const BASE_PROJECT_IDENTIFIER = ".base";
const ROOT_EXTENSION_POINT = "__ROOT__EXTENSION__POINT__";
const START_POSTFIX = "_START";
const END_POSTFIX = "_END";
const KEY_NAME_METADATA = "_Name";
const KEY_ARRAY_INSERT_AFTER_NAME = "NameAfter";
const KEY_ARRAY_INSERT_AFTER_INDEX = "IndexAfter";
const KEY_ARRAY_INSERT_BEFORE_NAME = "NameBefore";
const KEY_ARRAY_INSERT_BEFORE_INDEX = "IndexBefore";
const KEY_ARRAY_REMOVE = "Remove";
const KEY_ARRAY_REORDER = "Reorder";
const KEY_ARRAY_ADD = "Add";
const KEY_ARRAY_INSERT_BEGIN = "InsertBegin";
const KEY_ARRAY_INSERT_END = "InsertEnd";
const KEY_ARRAY_INSERT_ANY = "InsertAny";
const KEY_SEP = "/";
const VALUE_REMOVED = "undefined";
const RegexJSExtContentStart = new RegExp(/\/\/ExtPt-(\w+):\s*==START==/, "g");
const RegexJSExtLineStart = new RegExp(/\/\/ExtPt-(\w+):\s*==START==/, "m");
const RegexJSExtContentEnd = new RegExp(/\/\/ExtPt-(\w+):\s*==END==/, "g");
const RegexJSExtLineEnd = new RegExp(/\/\/ExtPt-(\w+):\s*==END==/, "m");
const JSONValidation = require('vscode-json-languageservice/lib/umd/services/jsonValidation.js').JSONValidation;
const WorkspaceContext = {
    resolveRelativePath: (relativePath, resource) => {
        return URL.resolve(resource, relativePath);
    }
};
let _appContext;
class ExtensionPointValidator {
    constructor(documentProvider) {
        if (!documentProvider) {
            LogUtil_1.Log.error("undefined documentProvider provided for ExtensionPointValidator.");
        }
        this._documentProvider = documentProvider;
        _appContext = {};
    }
    isSupportDocument(document) {
        return PathUtil_1.PathUtil.getMDKFileType(document.uri) === PathUtil_1.MDKFileType.MergeMap;
    }
    setup(document, context) {
        return __awaiter(this, void 0, void 0, function* () {
            _appContext[document.uri] = Object.assign({}, context);
            _appContext[document.uri].allControlNames = [];
            _appContext[document.uri].ExtensionPointMap = new Map();
            let baseAppDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(document.uri, this._documentProvider);
            let appInfo = yield baseAppDelegate.getApplicationInfo();
            if (appInfo) {
                const basePath = appInfo.basePath;
                let baseFilePath = this._getBaseFilePath(basePath, vscode_uri_1.default.parse(document.uri).fsPath);
                if (baseFilePath) {
                    const baseFileType = PathUtil_1.PathUtil.getMDKFileType(baseFilePath);
                    const sFileContent = yield this._documentProvider.getDocumentText(baseFilePath);
                    _appContext[document.uri].baseFilePath = baseFilePath;
                    _appContext[document.uri].baseFileType = baseFileType;
                    if ([PathUtil_1.MDKFileType.Page, PathUtil_1.MDKFileType.Action, PathUtil_1.MDKFileType.App, PathUtil_1.MDKFileType.Fragment, PathUtil_1.MDKFileType.Global, PathUtil_1.MDKFileType.Service].includes(baseFileType)) {
                        try {
                            _appContext[document.uri].baseFileObject = JSON.parse(sFileContent);
                        }
                        catch (error) {
                            console.error(error);
                        }
                        this._getAllNames(document, _appContext[document.uri].baseFileObject);
                        if (_appContext[document.uri].baseFileObject["_ExtensionPoint"]) {
                            _appContext[document.uri].ExtensionPointMap.set(ROOT_EXTENSION_POINT, _appContext[document.uri].baseFileObject["_ExtensionPoint"]);
                            if (_appContext[document.uri].baseFileObject[KEY_NAME_METADATA]) {
                                _appContext[document.uri].ExtensionPointMap.set(_appContext[document.uri].baseFileObject[KEY_NAME_METADATA], _appContext[document.uri].baseFileObject["_ExtensionPoint"]);
                            }
                        }
                        this._getExtensionPointsFromJsonFile(document, _appContext[document.uri].baseFileObject);
                    }
                    else if (baseFileType === PathUtil_1.MDKFileType.Rule) {
                        this._getExtensionPointsFromJsFile(document, sFileContent);
                    }
                }
            }
        });
    }
    validateJsonDocument(document, jsonDocument) {
        return __awaiter(this, void 0, void 0, function* () {
            let diagnostics = [];
            if (jsonDocument.root.type === "array") {
                jsonDocument.root.items.forEach(node => {
                    if (_appContext[document.uri].baseFileType === PathUtil_1.MDKFileType.Rule) {
                        this._validateForJsFile(document, node, diagnostics);
                    }
                    else {
                        this._validateForJsonFile(document, node, diagnostics);
                    }
                });
            }
            //<-- validate mergemap content
            // if (diagnostics.length === 0) {
            if (_appContext[document.uri].baseFileType !== PathUtil_1.MDKFileType.Rule && _appContext[document.uri].baseFilePath) {
                let validationHelper = new ExtensionPointValidationHelper_1.ExtensionPointValidationHelper(_appContext[document.uri].baseFilePath);
                yield validationHelper.resolve(document, jsonDocument);
                let mdkSchemaService = new SchemaService_1.MDKSchemaService(_schemaRequestCallback.bind({
                    'document': validationHelper.document,
                    'jsonDocument': validationHelper.jsonDocument
                }), WorkspaceContext, Promise);
                let mdkSchemaValidator = new JSONValidation(mdkSchemaService, Promise);
                mdkSchemaValidator.configure({ validate: true, allowComments: false });
                const _rstDiagnostics = yield mdkSchemaValidator.doValidation(validationHelper.document, validationHelper.jsonDocument);
                if (_rstDiagnostics) {
                    _rstDiagnostics.forEach((diagnostic) => {
                        let diagnosticNew;
                        diagnosticNew = validationHelper.convertDiagnosticRange(document, jsonDocument, diagnostic);
                        if (diagnosticNew) {
                            if (diagnosticNew.severity === mdkLanguageTypes_1.DiagnosticSeverity.Warning) {
                                diagnosticNew.severity = mdkLanguageTypes_1.DiagnosticSeverity.Error;
                            }
                            diagnostics.push(diagnosticNew);
                        }
                    });
                }
            }
            // }
            //-->
            diagnostics.forEach(item => item.source = MDKDefinitions_1.MDKValidator.ExtensionPoint);
            return diagnostics;
        });
    }
    _getBaseFilePath(basePath, mergeFilePath) {
        const fileName = path.basename(mergeFilePath);
        const fileFirstName = fileName.substring(0, fileName.lastIndexOf("."));
        let sPath = mergeFilePath.replace(basePath, path.join(basePath, BASE_PROJECT_IDENTIFIER));
        let relativePath = path.dirname(sPath);
        if (fs.existsSync(relativePath)) {
            let files = fs.readdirSync(relativePath);
            for (let i = 0; i < files.length; i++) {
                const _file = files[i];
                const _fileName = _file.substring(0, _file.lastIndexOf("."));
                if (_fileName === fileFirstName) {
                    return path.join(relativePath, _file);
                }
            }
        }
        return "";
    }
    _validateForJsonFile(document, node, diagnostics) {
        let _name = "";
        const nameNode = node.properties.find(prop => { var _a; return ((_a = prop.keyNode) === null || _a === void 0 ? void 0 : _a.value) === KEY_NAME_METADATA; });
        _name = nameNode === null || nameNode === void 0 ? void 0 : nameNode.valueNode.value;
        const _tarExtensionPoint = _appContext[document.uri].ExtensionPointMap.get(_name || ROOT_EXTENSION_POINT);
        node.properties.forEach(prop => {
            let range, problem;
            if (prop.keyNode.value === KEY_NAME_METADATA) {
                // validate _Name
                if (!_appContext[document.uri].ExtensionPointMap.get(prop.valueNode.value)) {
                    range = this._getJSONNodeRange(document, prop.valueNode);
                    problem = this._buildProblem(range, `"${prop.valueNode.value}" does not exist or does not have _ExtensionPoint.`);
                    diagnostics.push(problem);
                }
            }
            else {
                // validate ExtensionPoint
                let sMessage = `Cannot find _ExtensionPoint "${prop.keyNode.value}"${_name ? " in \"" + _name + "\"" : ""}.`;
                if (!_tarExtensionPoint) {
                    range = this._getJSONNodeRange(document, prop.keyNode);
                    problem = this._buildProblem(range, sMessage);
                    diagnostics.push(problem);
                }
                else {
                    const _objExtPointItem = typeof _tarExtensionPoint === "object" ? _tarExtensionPoint[prop.keyNode.value] : {};
                    if (!_objExtPointItem) {
                        let pass = false;
                        range = this._getJSONNodeRange(document, prop.keyNode);
                        problem = this._buildProblem(range, sMessage);
                        const _objObjectExtPointItem = this._getExtensionPointForObject(prop.keyNode.value, _tarExtensionPoint);
                        if (_objObjectExtPointItem && Array.isArray(_objObjectExtPointItem)) {
                            // for Object property:
                            // Add, Remove
                            let _problem = this._validateObjectExtensionPoint(document, prop, _name, _objObjectExtPointItem);
                            if (_problem) {
                                problem = _problem;
                            }
                            else {
                                pass = true;
                            }
                        }
                        if (!pass) {
                            diagnostics.push(problem);
                        }
                    }
                    else if (prop.valueNode.type === "object" && Array.isArray(_objExtPointItem)) {
                        // for Array property:
                        // Reorder, Remove, InsertBegin, InsertEnd, InsertAny
                        let arrOri;
                        let tarObj = this._findObjectByName(_appContext[document.uri].baseFileObject, _name);
                        let oRet = this._getSourceObjectByKey(tarObj, prop.keyNode.value);
                        if (oRet.parent && oRet.parent.hasOwnProperty(oRet.key)) {
                            arrOri = oRet.parent[oRet.key]; // source array
                        }
                        if (!Array.isArray(arrOri)) {
                            arrOri = [];
                        }
                        prop.valueNode.properties.forEach(prop2 => {
                            if (prop2.keyNode.value === KEY_ARRAY_REMOVE && arrOri.length > 0) {
                                arrOri.pop();
                            }
                            problem = this._validateArrayExtensionPoint(document, prop2, _name, prop.keyNode.value, _objExtPointItem);
                            if (problem) {
                                diagnostics.push(problem);
                            }
                            else {
                                if (prop2.keyNode.value === KEY_ARRAY_ADD) {
                                    const _problems = this._validateInsertExtensionPoints(document, prop2.valueNode, _name, prop.keyNode.value, arrOri, _objExtPointItem);
                                    diagnostics.push(..._problems);
                                }
                            }
                        });
                    }
                }
            }
        });
    }
    _validateForJsFile(document, node, diagnostics) {
        node.properties.forEach(prop => {
            if (prop.keyNode && prop.keyNode.value === "Name") {
                const _tarExtensionPoint1 = _appContext[document.uri].ExtensionPointMap.get(prop.valueNode.value + START_POSTFIX);
                const _tarExtensionPoint2 = _appContext[document.uri].ExtensionPointMap.get(prop.valueNode.value + END_POSTFIX);
                if (!_tarExtensionPoint1 || !_tarExtensionPoint2) {
                    let range = this._getJSONNodeRange(document, prop.valueNode);
                    let problem = this._buildProblem(range, `"${prop.valueNode.value}" does not exist.`);
                    diagnostics.push(problem);
                }
            }
        });
    }
    _validateArrayExtensionPoint(document, node, name, extensionKey, extensionPoint) {
        let problem;
        let sMessage = `"${node.keyNode.value}" is not allowed in _ExtensionPoint "${extensionKey}"${name ? " of \"" + name + "\"" : ""}.`;
        const range = this._getJSONNodeRange(document, node.keyNode);
        switch (node.keyNode.value) {
            case KEY_ARRAY_REMOVE:
                if (!extensionPoint.includes(KEY_ARRAY_REMOVE)) {
                    problem = this._buildProblem(range, sMessage);
                }
                break;
            case KEY_ARRAY_REORDER:
                if (!extensionPoint.includes(KEY_ARRAY_REORDER)) {
                    problem = this._buildProblem(range, sMessage);
                }
                break;
            case KEY_ARRAY_ADD:
                if (!extensionPoint.includes(KEY_ARRAY_INSERT_BEGIN) &&
                    !extensionPoint.includes(KEY_ARRAY_INSERT_END) &&
                    !extensionPoint.includes(KEY_ARRAY_INSERT_ANY)) {
                    problem = this._buildProblem(range, sMessage);
                }
                break;
            default:
                sMessage = `"${node.keyNode.value}" is not recognized in _ExtensionPoint "${extensionKey}"${name ? " of \"" + name + "\"" : ""}.`;
                problem = this._buildProblem(range, sMessage);
                break;
        }
        return problem;
    }
    _validateInsertExtensionPoints(document, node, name, extensionKey, arrOri, extensionPoint) {
        let diagnostics = [];
        let range, problem;
        let iStart = 0, iEnd = arrOri.length > 0 ? (arrOri.length - 1) : 0;
        if (arrOri.length > 0 && node && node.type === "array") {
            node.items.forEach(item => {
                let _tarKeyNode, _tarValueNode;
                for (let i = 0; i < item.properties.length; i++) {
                    const prop = item.properties[i];
                    if ([KEY_ARRAY_INSERT_AFTER_NAME,
                        KEY_ARRAY_INSERT_AFTER_INDEX,
                        KEY_ARRAY_INSERT_BEFORE_NAME,
                        KEY_ARRAY_INSERT_BEFORE_INDEX].indexOf(prop.keyNode.value) >= 0) {
                        _tarKeyNode = prop;
                    }
                    else if (prop.keyNode.value === "Value") {
                        _tarValueNode = prop;
                    }
                }
                if (!extensionPoint.includes(KEY_ARRAY_INSERT_ANY) && arrOri.length > 0 && _tarKeyNode) {
                    // validate NameAfter, IndexAfter, NameBefore, IndexBefore
                    const sMessage = `"${_tarKeyNode.keyNode.value}" with value "${_tarKeyNode.valueNode.value}" is not allowed in _ExtensionPoint "${extensionKey}"${name ? " of \"" + name + "\"" : ""}.`;
                    const value = _tarKeyNode.valueNode.value;
                    let iIndex;
                    if (_tarKeyNode.keyNode.value === KEY_ARRAY_INSERT_AFTER_NAME ||
                        _tarKeyNode.keyNode.value === KEY_ARRAY_INSERT_BEFORE_NAME) {
                        // NameAfter, NameBefore
                        iIndex = arrOri.findIndex(oItem => { return oItem._Name === value; });
                        if (_tarKeyNode.keyNode.value === KEY_ARRAY_INSERT_AFTER_NAME) {
                            iIndex = iIndex + 1;
                        }
                        else {
                            iIndex = iIndex - 1;
                        }
                        arrOri.splice(iIndex, 0, { _Name: value }); // add fake value
                    }
                    else if (_tarKeyNode.keyNode.value === KEY_ARRAY_INSERT_AFTER_INDEX ||
                        _tarKeyNode.keyNode.value === KEY_ARRAY_INSERT_BEFORE_INDEX) {
                        // IndexAfter, IndexBefore
                        if (_tarKeyNode.keyNode.value === KEY_ARRAY_INSERT_AFTER_INDEX) {
                            iIndex = value + 1;
                        }
                        else {
                            //the index is from end
                            iIndex = arrOri.length - value - 1;
                        }
                        arrOri.splice(iIndex, 0, {}); // add fake value
                    }
                    if (iIndex <= iStart) {
                        iStart++;
                    }
                    if (iIndex <= iEnd) {
                        iEnd++;
                    }
                    if ((iIndex > iEnd && !extensionPoint.includes(KEY_ARRAY_INSERT_END)) ||
                        (iIndex < iStart && !extensionPoint.includes(KEY_ARRAY_INSERT_BEGIN)) ||
                        (iIndex > iStart && iIndex < iEnd)) {
                        range = this._getJSONNodeRange(document, _tarKeyNode);
                        problem = this._buildProblem(range, sMessage);
                        diagnostics.push(problem);
                    }
                }
                if (_tarValueNode && _tarValueNode.valueNode.type === "object") {
                    // validate "_Name" in "Value" properties
                    _tarValueNode.valueNode.properties.forEach(prop => {
                        if (prop.keyNode.value === KEY_NAME_METADATA && _appContext[document.uri].allControlNames.includes(prop.valueNode.value)) {
                            range = this._getJSONNodeRange(document, prop.valueNode);
                            problem = this._buildProblem(range, `_Name "${prop.valueNode.value}" in _ExtensionPoint "${extensionKey}"${name ? " of \"" + name + "\"" : ""} is duplicate with the one in base project.`);
                            diagnostics.push(problem);
                        }
                    });
                }
            });
        }
        return diagnostics;
    }
    _validateObjectExtensionPoint(document, node, name, extensionPoint) {
        let problem;
        if (node.valueNode.value === VALUE_REMOVED && extensionPoint.includes("Remove")) {
            return problem;
        }
        else if (extensionPoint.includes("Add")) {
            // try to find Object property in source
            const tarObj = this._findObjectByName(_appContext[document.uri].baseFileObject, name);
            const oRet = this._getSourceObjectByKey(tarObj, node.keyNode.value);
            if (oRet.parent && oRet.parent.hasOwnProperty(oRet.key)) {
                const sMessage = `"${node.keyNode.value}" is not allowed in _ExtensionPoint${name ? " of \"" + name + "\"" : ""}.`;
                const range = this._getJSONNodeRange(document, node.keyNode);
                problem = this._buildProblem(range, sMessage);
            }
            return problem;
        }
    }
    _getExtensionPointsFromJsonFile(document, obj) {
        Object.keys(obj).forEach(key => {
            let value = obj[key];
            if (typeof value === "object" && value) {
                if (value[KEY_NAME_METADATA] && value._ExtensionPoint) {
                    _appContext[document.uri].ExtensionPointMap.set(value[KEY_NAME_METADATA], value._ExtensionPoint);
                }
                this._getExtensionPointsFromJsonFile(document, value);
            }
        });
    }
    _getExtensionPointsFromJsFile(document, sContent) {
        const linesWithStart = sContent.match(RegexJSExtContentStart);
        const linesWithEnd = sContent.match(RegexJSExtContentEnd);
        linesWithStart === null || linesWithStart === void 0 ? void 0 : linesWithStart.forEach(line => {
            const startNamers = line.match(RegexJSExtLineStart);
            _appContext[document.uri].ExtensionPointMap.set((startNamers === null || startNamers === void 0 ? void 0 : startNamers[1]) + START_POSTFIX, true);
        });
        linesWithEnd === null || linesWithEnd === void 0 ? void 0 : linesWithEnd.forEach(line => {
            const endNames = line.match(RegexJSExtLineEnd);
            _appContext[document.uri].ExtensionPointMap.set((endNames === null || endNames === void 0 ? void 0 : endNames[1]) + END_POSTFIX, true);
        });
    }
    _getExtensionPointForObject(sKey, extensionPoint) {
        if (typeof extensionPoint === "object" && sKey.indexOf(KEY_SEP) > 0) {
            const aKey = sKey.split(KEY_SEP);
            let tarKey = [];
            for (let i = 0; i < aKey.length - 1; i++) {
                tarKey.push(aKey[i]);
                let oVal = extensionPoint[tarKey.join(KEY_SEP)];
                if (oVal) {
                    return oVal;
                }
            }
        }
        return null;
    }
    _getSourceObjectByKey(oSource, sKey) {
        if (sKey.indexOf(KEY_SEP) <= 0) {
            return { parent: oSource, key: sKey };
        }
        else {
            let aKey = sKey.split(KEY_SEP);
            let oParent = oSource;
            for (let i = 0; i < aKey.length - 1; i++) {
                oParent = oParent[aKey[i]];
            }
            return { parent: oParent, key: aKey[aKey.length - 1] };
        }
    }
    _findObjectByName(obj, name) {
        if (!name) {
            return obj;
        }
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                const value = obj[key];
                if (key === '_Name' && value === name) {
                    return obj;
                }
                if (typeof value === 'object' && value !== null) {
                    const foundObject = this._findObjectByName(value, name);
                    if (foundObject !== null) {
                        return foundObject;
                    }
                }
                if (Array.isArray(value)) {
                    for (const item of value) {
                        if (typeof item === 'object' && item !== null) {
                            const foundObject = this._findObjectByName(item, name);
                            if (foundObject !== null) {
                                return foundObject;
                            }
                        }
                    }
                }
            }
        }
        return null;
    }
    _getAllNames(document, obj) {
        Object.keys(obj).forEach(key => {
            const value = obj[key];
            if (key === '_Name') {
                _appContext[document.uri].allControlNames.push(value);
            }
            else if (typeof value === 'object' && value !== null) {
                this._getAllNames(document, value);
            }
        });
    }
    _getJSONNodeRange(document, node) {
        return mdkLanguageTypes_1.Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));
    }
    _buildProblem(range, message) {
        let problem = mdkLanguageTypes_1.Diagnostic.create(range, message, mdkLanguageTypes_1.DiagnosticSeverity.Error);
        // problem.code = "NotFoundInExtensionPoint";
        return problem;
    }
    checkJsonNodeSync(document, node) {
        return false;
    }
    validateJsonNode(document, node, schema) {
        return __awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    checkJsNodeSync(document, node) {
        return false;
    }
    validateJsNode(document, node, loc) {
        return __awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    cleanup(document, diagnostics) {
        return __awaiter(this, void 0, void 0, function* () {
            _appContext[document.uri] = null;
            return diagnostics;
        });
    }
}
exports.ExtensionPointValidator = ExtensionPointValidator;
function _schemaRequestCallback(fsPath) {
    return SchemaVersionAdapter_1.SchemaVersionHelper.getApplicationSchemaVersion(this.document.uri).then(schemaVersion => {
        return SchemaProvider_1.SchemaProvider.getInstance(schemaVersion).getSchema(fsPath, this.jsonDocument, this.document.uri, _appContext);
    });
}
//# sourceMappingURL=ExtensionPointValidator.js.map