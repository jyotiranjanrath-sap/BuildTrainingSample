"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformRiskValidator = void 0;
const LanguageHelper_1 = require("../../common/LanguageHelper");
const PathUtil_1 = require("../../common/PathUtil");
const MDKDefinitions_1 = require("../../export/MDKDefinitions");
const mdkLanguageTypes_1 = require("../../mdkLanguageTypes");
const PLATFORM_IOS = 'iOS';
const PLATFORM_ANDORI = 'Android';
const PLATFORM_WEB = 'Web';
const PLATFORM_NOT_SUPPORT = 'Not supported';
const PLATFORM_NOT_SUPPORT_IOS = 'not supported in iOS';
const PLATFORM_NOT_SUPPORT_ANDROI = 'not supported in Android';
const PLATFORM_NOT_SUPPORT_WEB = 'not supported in Web';
class PlatformRiskValidator {
    constructor() {
        this._context = {};
    }
    isSupportDocument(document) {
        let fileType = PathUtil_1.PathUtil.getMDKFileType(document.uri);
        return [
            PathUtil_1.MDKFileType.Action,
            PathUtil_1.MDKFileType.Page
        ].some(eachType => eachType === fileType);
    }
    setup(document, context) {
        return __awaiter(this, void 0, void 0, function* () {
            this._context[document.uri] = Object.assign({}, context);
        });
    }
    validateJsonDocument(document, jsonDocument) {
        return __awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    checkJsonNodeSync(document, node) {
        return (document && node && (LanguageHelper_1.LanguageHelper.isStringValue(node) || node.type === 'object'));
    }
    validateJsonNode(document, node, schema) {
        return __awaiter(this, void 0, void 0, function* () {
            let diagnostics = [];
            let that = this;
            let targetPlatform = that._context[document.uri].platform;
            if (targetPlatform === 'None') {
                return [];
            }
            if (schema) {
                if (node.type === 'object') {
                    if (node.properties && schema.properties) {
                        node.properties.forEach(propertyNode => {
                            if (propertyNode && propertyNode.keyNode && propertyNode.keyNode.value) {
                                let propertySchema = schema.properties[propertyNode.keyNode.value];
                                if (propertySchema) {
                                    let targetPlatform = that._context[document.uri].platform;
                                    let platform = that._findPlatformIndication(propertySchema.description);
                                    if ((platform === PLATFORM_IOS || platform === PLATFORM_ANDORI || platform === PLATFORM_WEB) &&
                                        (!targetPlatform || targetPlatform.toLowerCase() !== platform.toLowerCase())) {
                                        node = propertyNode.keyNode;
                                        let valueNode = propertyNode.valueNode;
                                        let range = mdkLanguageTypes_1.Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));
                                        let message;
                                        if (node.value === '_Type') {
                                            message = `The control type ${valueNode.value} is only used on the ${platform} platform`;
                                        }
                                        else {
                                            message = `The property ${node.value} is only used on the ${platform} platform`;
                                        }
                                        diagnostics.push(mdkLanguageTypes_1.Diagnostic.create(range, message, mdkLanguageTypes_1.DiagnosticSeverity.Information));
                                    }
                                    else if ((platform === PLATFORM_NOT_SUPPORT_IOS || platform === PLATFORM_NOT_SUPPORT_ANDROI || platform === PLATFORM_NOT_SUPPORT_WEB) &&
                                        (!targetPlatform || this._checkTargetPlatform(platform, targetPlatform))) {
                                        node = propertyNode.keyNode;
                                        let valueNode = propertyNode.valueNode;
                                        let range = mdkLanguageTypes_1.Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));
                                        let message;
                                        if (node.value === '_Type') {
                                            message = `The control type ${valueNode.value} is ${platform}`;
                                        }
                                        else {
                                            message = `The property ${node.value} is ${platform}`;
                                        }
                                        diagnostics.push(mdkLanguageTypes_1.Diagnostic.create(range, message, mdkLanguageTypes_1.DiagnosticSeverity.Information));
                                    }
                                }
                            }
                        });
                    }
                }
                else if (schema.enum && schema.enum.indexOf(node.value) >= 0) {
                    let targetPlatform = this._context[document.uri].platform;
                    let platform = this._findPlatformIndication(schema.description);
                    if ((platform === PLATFORM_IOS || platform === PLATFORM_ANDORI || platform === PLATFORM_WEB) &&
                        (!targetPlatform || targetPlatform.toLowerCase() !== platform.toLowerCase())) {
                        let range = mdkLanguageTypes_1.Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));
                        let message = `The property ${node.value} is only used on the ${platform} platform`;
                        diagnostics.push(mdkLanguageTypes_1.Diagnostic.create(range, message, mdkLanguageTypes_1.DiagnosticSeverity.Information));
                    }
                    else if ((platform === PLATFORM_NOT_SUPPORT_IOS || platform === PLATFORM_NOT_SUPPORT_ANDROI || platform === PLATFORM_NOT_SUPPORT_WEB) &&
                        (!targetPlatform || this._checkTargetPlatform(platform, targetPlatform))) {
                        let range = mdkLanguageTypes_1.Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));
                        let message = `The property ${node.value} is ${platform}`;
                        diagnostics.push(mdkLanguageTypes_1.Diagnostic.create(range, message, mdkLanguageTypes_1.DiagnosticSeverity.Information));
                    }
                }
                else if (!schema.enum) {
                    let targetPlatform = this._context[document.uri].platform;
                    let platform = this._findPlatformIndication(schema.description);
                    if ((platform === PLATFORM_IOS || platform === PLATFORM_ANDORI || platform === PLATFORM_WEB) &&
                        (!targetPlatform || targetPlatform.toLowerCase() !== platform.toLowerCase())) {
                        node = node.parent.keyNode;
                        let valueNode = node.parent.valueNode;
                        let range = mdkLanguageTypes_1.Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));
                        let message;
                        if (node.value === '_Type') {
                            message = `The control type ${valueNode.value} is only used on the ${platform} platform`;
                        }
                        else {
                            message = `The property ${node.value} is only used on the ${platform} platform`;
                        }
                        diagnostics.push(mdkLanguageTypes_1.Diagnostic.create(range, message, mdkLanguageTypes_1.DiagnosticSeverity.Information));
                    }
                    else if ((platform === PLATFORM_NOT_SUPPORT_IOS || platform === PLATFORM_NOT_SUPPORT_ANDROI || platform === PLATFORM_NOT_SUPPORT_WEB) &&
                        (!targetPlatform || this._checkTargetPlatform(platform, targetPlatform))) {
                        node = node.parent.keyNode;
                        let valueNode = node.parent.valueNode;
                        let range = mdkLanguageTypes_1.Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));
                        let message;
                        if (node.value === '_Type') {
                            message = `The control type ${valueNode.value} is ${platform}`;
                        }
                        else {
                            message = `The property ${node.value} is ${platform}`;
                        }
                        diagnostics.push(mdkLanguageTypes_1.Diagnostic.create(range, message, mdkLanguageTypes_1.DiagnosticSeverity.Information));
                    }
                }
            }
            diagnostics.forEach(item => item.source = MDKDefinitions_1.MDKValidator.PlatformRisk);
            return diagnostics;
        });
    }
    checkJsNodeSync(document, node) {
        return false;
    }
    validateJsNode(document, node, loc) {
        return __awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    cleanup(document, diagnostics) {
        return __awaiter(this, void 0, void 0, function* () {
            this._context[document.uri] = null;
            return diagnostics;
        });
    }
    _findPlatformIndication(description) {
        if (!!description) {
            let prefix = 'platform:';
            description = description.toLowerCase();
            let pos = description.indexOf(prefix);
            if (pos >= 0) {
                pos += prefix.length;
                if (description.toLowerCase().indexOf(PLATFORM_NOT_SUPPORT.toLowerCase(), pos) !== -1) {
                    if (description.toLowerCase().indexOf(PLATFORM_IOS.toLowerCase(), pos) !== -1) {
                        return PLATFORM_NOT_SUPPORT_IOS;
                    }
                    else if (description.toLowerCase().indexOf(PLATFORM_ANDORI.toLowerCase(), pos) !== -1) {
                        return PLATFORM_NOT_SUPPORT_ANDROI;
                    }
                    else if (description.toLowerCase().indexOf(PLATFORM_WEB.toLowerCase(), pos) !== -1) {
                        return PLATFORM_NOT_SUPPORT_WEB;
                    }
                }
                else if (description.toLowerCase().indexOf(PLATFORM_IOS.toLowerCase(), pos) !== -1) {
                    return PLATFORM_IOS;
                }
                else if (description.toLowerCase().indexOf(PLATFORM_ANDORI.toLowerCase(), pos) !== -1) {
                    return PLATFORM_ANDORI;
                }
                else if (description.toLowerCase().indexOf(PLATFORM_WEB.toLowerCase(), pos) !== -1) {
                    return PLATFORM_WEB;
                }
            }
        }
        return null;
    }
    _checkTargetPlatform(platform, targetPlatform) {
        let newPlatform;
        if (platform === PLATFORM_NOT_SUPPORT_IOS) {
            newPlatform = PLATFORM_IOS;
        }
        else if (platform === PLATFORM_NOT_SUPPORT_ANDROI) {
            newPlatform = PLATFORM_ANDORI;
        }
        else if (platform === PLATFORM_NOT_SUPPORT_WEB) {
            newPlatform = PLATFORM_WEB;
        }
        if (targetPlatform === 'iOS & Android & Web') {
            return true;
        }
        else if (targetPlatform.toLowerCase().indexOf(newPlatform.toLowerCase()) !== -1) {
            return true;
        }
        else {
            return false;
        }
    }
}
exports.PlatformRiskValidator = PlatformRiskValidator;
//# sourceMappingURL=PlatformRiskValidator.js.map