"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServiceValidator = void 0;
const Json = require("jsonc-parser");
const path = require("path");
const vscode_uri_1 = require("vscode-uri");
const LanguageHelper_1 = require("../../common/LanguageHelper");
const LogUtil_1 = require("../../common/LogUtil");
const PathUtil_1 = require("../../common/PathUtil");
const MDKDefinitions_1 = require("../../export/MDKDefinitions");
const mdkLanguageTypes_1 = require("../../mdkLanguageTypes");
class ServiceValidator {
    constructor(documentProvider) {
        if (!documentProvider) {
            LogUtil_1.Log.error("undefined documentProvider provided for ServiceValidator.");
        }
        this._documentProvider = documentProvider;
        this._context = {};
    }
    isSupportDocument(document) {
        return PathUtil_1.PathUtil.getMDKFileType(document.uri) === PathUtil_1.MDKFileType.Service;
    }
    setup(document, context) {
        return __awaiter(this, void 0, void 0, function* () {
            this._context[document.uri] = Object.assign({}, context);
        });
    }
    validateJsonDocument(document, jsonDocument, schemas) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = [];
            // if (PathUtil.getMDKFileType(document.uri) === MDKFileType.Service) {
            let service;
            try {
                let jsonErrors = [];
                service = Json.parse(document.getText(), jsonErrors);
            }
            catch (e) {
            }
            if (service) {
                if (service.PathSuffix && (service.OfflineEnabled === true || service.OfflineEnabled === undefined)) {
                    if ((!service.OfflineOptions || !service.OfflineOptions.StoreParameters || !service.OfflineOptions.StoreParameters.StoreName)) {
                        result.push({
                            range: mdkLanguageTypes_1.Range.create(mdkLanguageTypes_1.Position.create(0, 1), mdkLanguageTypes_1.Position.create(0, 2)),
                            severity: mdkLanguageTypes_1.DiagnosticSeverity.Error,
                            message: "StoreName should be set for Offline mode when PathSuffix is set"
                        });
                    }
                    else {
                        let storeNameValueNode = _getPropertyValueNode(jsonDocument.root, "OfflineOptions.StoreParameters.StoreName");
                        let result1 = yield this._validateStoreName(document, storeNameValueNode, null);
                        result.push(...result1);
                    }
                }
            }
            // }
            result.forEach(item => item.source = MDKDefinitions_1.MDKValidator.Service);
            return result;
        });
    }
    checkJsonNodeSync(document, node) {
        return LanguageHelper_1.LanguageHelper.isPathSuffixValueNode(document.uri, node);
    }
    validateJsonNode(document, node, schema) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._validatePathSuffix(document, node, schema);
        });
    }
    checkJsNodeSync(document, node) {
        return false;
    }
    validateJsNode(document, node, loc) {
        return __awaiter(this, void 0, void 0, function* () {
            // tbd
            return [];
        });
    }
    cleanup(document, diagnostics) {
        return __awaiter(this, void 0, void 0, function* () {
            this._context[document.uri] = null;
            return diagnostics;
        });
    }
    _validatePathSuffix(document, node, schema) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = [];
            if (node.value && !node.value.startsWith('/')) {
                let errorMessage = "PathSuffix should start with /";
                let range = mdkLanguageTypes_1.Range.create(document.positionAt(node.offset + 1), document.positionAt(node.offset + 1 + node.value.length));
                result.push({
                    range: range,
                    severity: mdkLanguageTypes_1.DiagnosticSeverity.Error,
                    message: errorMessage
                });
            }
            result.forEach(item => item.source = MDKDefinitions_1.MDKValidator.Service);
            return result;
        });
    }
    _validateStoreName(document, node, schema) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = [];
            let serviceFolder = path.dirname(vscode_uri_1.default.parse(document.uri).fsPath);
            let serviceFileFullPaths = yield this._documentProvider.getChildrenFullPaths(serviceFolder, true);
            let storeNames = {};
            serviceFileFullPaths.forEach(serviceFileFullPath => {
                if (PathUtil_1.PathUtil.getMDKFileType(serviceFileFullPath) === PathUtil_1.MDKFileType.Service) {
                    let service = this._documentProvider.getDocumentJsonSync(serviceFileFullPath);
                    if (service && (service.OfflineEnabled === true || service.OfflineEnabled === undefined) && service.OfflineOptions && service.OfflineOptions.StoreParameters && service.OfflineOptions.StoreParameters && service.OfflineOptions.StoreParameters.StoreName) {
                        storeNames[serviceFileFullPath] = service.OfflineOptions.StoreParameters.StoreName;
                    }
                }
            });
            let duplicate = false;
            let count = 0;
            for (let key in storeNames) {
                if (storeNames.hasOwnProperty(key)) {
                    let storeName = storeNames[key];
                    if (storeName === node.value) {
                        count++;
                        if (count > 1) {
                            duplicate = true;
                            break;
                        }
                    }
                }
            }
            if (duplicate) {
                let range = mdkLanguageTypes_1.Range.create(document.positionAt(node.offset + 1), document.positionAt(node.offset + 1 + node.value.length));
                let diag = _buildNotUniqueStoreNameProblem(node.value, range);
                result.push(diag);
            }
            return result;
        });
    }
}
exports.ServiceValidator = ServiceValidator;
function _getPropertyValueNode(objectNode, propertyPath) {
    let propertyNames = propertyPath.split('.');
    let propertyName = propertyNames.shift();
    let valueNode;
    for (let property of objectNode.properties) {
        if (property.keyNode.value === propertyName) {
            valueNode = property.valueNode;
            break;
        }
    }
    ;
    if (propertyNames && propertyNames.length > 0) {
        return _getPropertyValueNode(valueNode, propertyNames.join('.'));
    }
    return valueNode;
}
function _buildNotUniqueStoreNameProblem(storeName, range) {
    let problem = mdkLanguageTypes_1.Diagnostic.create(range, "Not unique store name: " + storeName, mdkLanguageTypes_1.DiagnosticSeverity.Error);
    problem.code = "NotUniqueStoreName";
    return problem;
}
//# sourceMappingURL=ServiceValidator.js.map