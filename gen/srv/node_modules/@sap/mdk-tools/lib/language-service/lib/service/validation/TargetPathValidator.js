"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TargetPathValidator = void 0;
const _ = require("lodash");
const vscode_uri_1 = require("vscode-uri");
const cache_1 = require("../../cache");
const LanguageHelper_1 = require("../../common/LanguageHelper");
const LogUtil_1 = require("../../common/LogUtil");
const PathUtil_1 = require("../../common/PathUtil");
const TargetHelper_1 = require("../../common/TargetHelper");
const MDKApplicationDelegate_1 = require("../../export/MDKApplicationDelegate");
const MDKDefinitions_1 = require("../../export/MDKDefinitions");
const mdkLanguageTypes_1 = require("../../mdkLanguageTypes");
const SchemaVersionAdapter_1 = require("../../tool/SchemaVersionAdapter");
const Context_1 = require("../targetpath/Context");
const TargetPathInterpreter_1 = require("../targetpath/TargetPathInterpreter");
const PropertySegment_1 = require("../targetpath/segments/PropertySegment");
class TargetPathValidator {
    constructor(documentProvider) {
        if (!documentProvider) {
            LogUtil_1.Log.error("undefined documentProvider provided for TargetPathValidator.");
        }
        this._documentProvider = documentProvider;
        this._context = {};
    }
    isSupportDocument(document) {
        let fileType = PathUtil_1.PathUtil.getMDKFileType(document.uri);
        return [
            PathUtil_1.MDKFileType.Action,
            PathUtil_1.MDKFileType.Page
        ].some(eachType => eachType === fileType);
    }
    setup(document, context) {
        return __awaiter(this, void 0, void 0, function* () {
            this._context[document.uri] = Object.assign({
                'resolveContext': new Context_1.Context()
            }, context);
            this._context[document.uri].resolveContext.appContext = context;
            this._context[document.uri].resolveContext.documentProvider = this._documentProvider;
            let appPages = yield cache_1.cache.getPages(document.uri, this._documentProvider);
            if (!appPages) {
                appPages = yield LanguageHelper_1.LanguageHelper.getAllPages(document.uri, this._documentProvider, this._context[document.uri].referenceApps);
            }
            this._context[document.uri].resolveContext.pages = appPages;
            let appFragments = yield cache_1.cache.getFragments(document.uri, this._documentProvider);
            if (!appFragments) {
                appFragments = yield LanguageHelper_1.LanguageHelper.getAllFragments(document.uri, this._documentProvider, this._context[document.uri].referenceApps);
            }
            this._context[document.uri].resolveContext.fragments = appFragments;
            let actionResults = yield cache_1.cache.getActionResults(document.uri, this._documentProvider);
            if (!actionResults) {
                actionResults = yield LanguageHelper_1.LanguageHelper.getAllActionResults(document.uri, this._documentProvider, this._context[document.uri].referenceApps);
            }
            this._context[document.uri].resolveContext.actionResults = actionResults;
            this._context[document.uri].resolveContext.element = yield this._findpage(document, appPages);
        });
    }
    validateJsonDocument(document, jsonDocument) {
        return __awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    checkJsonNodeSync(document, node) {
        if (!LanguageHelper_1.LanguageHelper.isStringValue(node)) {
            return false;
            // } else if (PathUtil.getMDKFileType(document.uri) === MDKFileType.Global) {
            // 	return false;
        }
        else if (/^#[a-fA-F0-9]+$/.test(node.value)) {
            return false;
        }
        const bCheck = LanguageHelper_1.LanguageHelper.checkExcludeValidationConfig(this._context[document.uri].resolveContext.appContext, node.value);
        return !bCheck;
    }
    validateJsonNode(document, node, schema) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._validateJsonNodeTargetPath(document, node, schema);
        });
    }
    checkJsNodeSync(document, node) {
        return false;
    }
    validateJsNode(document, node, loc) {
        return __awaiter(this, void 0, void 0, function* () {
            // tbd
            return [];
        });
    }
    cleanup(document, diagnostics) {
        return __awaiter(this, void 0, void 0, function* () {
            this._context[document.uri] = null;
            return diagnostics;
        });
    }
    _validateJsonNodeTargetPath(document, node, schema) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = [];
            let that = this;
            if (node.parent && node.parent.type === 'property' && node.parent.keyNode.value === 'EntitySet') {
                return result;
            }
            let targetPathsOrBindings = that._getTargetPathsAndBindings(node.value);
            let targetPaths = targetPathsOrBindings.filter(item => item.targetPath.startsWith('#'));
            let bindings = targetPathsOrBindings.filter(item => !item.targetPath.startsWith('#'));
            yield SchemaVersionAdapter_1.SchemaVersionHelper.init(document.uri);
            if (targetPaths && targetPaths.length > 0) {
                yield Promise.all(targetPaths.map((element) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        let context = _.clone(this._context[document.uri].resolveContext);
                        context.currentNode = node;
                        context.anchorDocumentUri = document.uri;
                        if (element.targetPath && !element.targetPath.startsWith('#Control')) {
                            context.element = null;
                        }
                        let tpi = new TargetPathInterpreter_1.TargetPathInterpreter(context);
                        context = yield tpi.evaluateTargetPathForContext(element.targetPath);
                        let path = '';
                        let parts = element.targetPath.split('/');
                        let indexLastPropertySegement = 0;
                        for (let i = parts.length - 1; i >= 0; i--) {
                            if (parts[i].startsWith('#Property:')) {
                                indexLastPropertySegement = i;
                                break;
                            }
                        }
                        let target = LanguageHelper_1.LanguageHelper.getTargetObject(node);
                        if (target) {
                            if (indexLastPropertySegement > 0) {
                                let position = 0;
                                let expandedProperties = TargetHelper_1.TargetHelper.getExpandedProperties(target);
                                if (expandedProperties) {
                                    for (let i = 0; i < indexLastPropertySegement; i++) {
                                        if (!parts[i].startsWith('#Property:')) {
                                            position += parts[i].length + 1;
                                            continue;
                                        }
                                        if (i > 0) {
                                            path += '/';
                                        }
                                        path += parts[i].substring(10); //10 is the length of '#Property:'
                                        if (!expandedProperties.some(property => {
                                            if (property.startsWith(path)) {
                                                return true;
                                            }
                                        })) {
                                            let error = new TargetPathInterpreter_1.TargetPathError(`The navigation property ${path} cannot be found in QueryOptions of the target.`);
                                            error.location = {
                                                start: position,
                                                end: position + parts[i].length
                                            };
                                            throw error;
                                        }
                                        position += parts[i].length + 1;
                                    }
                                }
                            }
                            if (indexLastPropertySegement >= 0) {
                                if (context && context.binding && context.binding.isNavigationProperty) {
                                    let path = parts[indexLastPropertySegement];
                                    let position = element.targetPath.indexOf(path);
                                    let error = new TargetPathInterpreter_1.TargetPathError(`The navigation property ${path.substring(10)} should be followed by a property.`);
                                    error.location = {
                                        start: position,
                                        end: position + path.length
                                    };
                                    throw error;
                                }
                            }
                        }
                    }
                    catch (error) {
                        result.push(this._convertErrorToDiagnostic(error, document, node, element));
                    }
                })));
            }
            if (node.parent && node.parent.type === 'property' && node.parent.keyNode.value === 'QueryOptions') {
                return result;
            }
            if (bindings && bindings.length > 0) {
                yield Promise.all(bindings.map((element) => __awaiter(this, void 0, void 0, function* () {
                    let diagnostic = yield that._validateJsonNodeODataBinding(document, element, node, schema);
                    if (diagnostic) {
                        result.push(diagnostic);
                    }
                })));
            }
            result.forEach(item => item.source = MDKDefinitions_1.MDKValidator.TargetPath);
            return result;
        });
    }
    _convertErrorToDiagnostic(error, document, node, element) {
        let errorMessage;
        if (error.description) {
            errorMessage = error.description;
        }
        else {
            errorMessage = error.message;
        }
        LogUtil_1.Log.error(`Error while parsing ${element.targetPath} : ${errorMessage}`);
        let range, code;
        if (error instanceof TargetPathInterpreter_1.TargetPathError) {
            range = mdkLanguageTypes_1.Range.create(document.positionAt(node.offset + element.index + error.location.start + 1), document.positionAt(node.offset + element.index + error.location.end + 1));
        }
        else {
            range = mdkLanguageTypes_1.Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));
        }
        if (errorMessage.startsWith("Error: Could not find control ")) {
            code = "ControlNotFound";
        }
        else if (errorMessage.startsWith("Error: Failed to find page ")) {
            code = "PageNotFound";
        }
        return {
            range: range,
            severity: mdkLanguageTypes_1.DiagnosticSeverity.Error,
            message: errorMessage,
            code: code
        };
    }
    _validateJsonNodeODataBinding(document, binding, node, schema) {
        return __awaiter(this, void 0, void 0, function* () {
            if (schema) {
                let property = binding.targetPath;
                if (!property.startsWith('@')) {
                    if (PathUtil_1.PathUtil.getMDKFileType(document.uri) === PathUtil_1.MDKFileType.Action) {
                        let root = node;
                        while (root.parent) {
                            root = root.parent;
                        }
                        if (root && root.properties) {
                            let typeProperty = root.properties.find(p => p.keyNode && p.keyNode.value === '_Type');
                            if (typeProperty && typeProperty.valueNode && typeProperty.valueNode.value && typeProperty.valueNode.value.startsWith("Action.Type.ODataService")) {
                                return;
                            }
                        }
                    }
                    let target = LanguageHelper_1.LanguageHelper.getTargetObject(node);
                    if (target && target.Service) {
                        if (target.EntitySet && !TargetHelper_1.TargetHelper.isSupportEntityString(target.EntitySet)) {
                            return;
                        }
                        if (target.EntitySet && target.EntitySet.indexOf('@odata.readLink') > -1) {
                            let designTimeTarget = LanguageHelper_1.LanguageHelper.getDesignTimeTargetObject(node);
                            if (!designTimeTarget || !designTimeTarget.Service || !designTimeTarget.EntitySet) {
                                return;
                            }
                        }
                        let targetType;
                        if (property) {
                            targetType = yield LanguageHelper_1.LanguageHelper.resolveBindingValue(property, document.uri, node, this._documentProvider, this._context[document.uri].resolveContext.appContext);
                        }
                        let message;
                        if (!targetType) {
                            message = "invalid binding";
                        }
                        else if (targetType.type === 'object' || targetType.type === 'array') {
                            message = "incomplete binding";
                        }
                        if (message) {
                            let range = mdkLanguageTypes_1.Range.create(document.positionAt(node.offset + 1 + binding.index), document.positionAt(node.offset + 1 + binding.index + binding.targetPath.length));
                            return {
                                range: range,
                                severity: mdkLanguageTypes_1.DiagnosticSeverity.Error,
                                message: message
                            };
                        }
                    }
                    return;
                }
                let context = _.clone(this._context[document.uri].resolveContext);
                context.currentNode = node;
                context.anchorDocumentUri = document.uri;
                try {
                    let propSegement = new PropertySegment_1.PropertySegment(property, context);
                    yield propSegement.resolve();
                }
                catch (error) {
                    return this._convertErrorToDiagnostic(error, document, node, binding);
                }
            }
        });
    }
    _getTargetPathsAndBindings(value) {
        let TargetPathState;
        (function (TargetPathState) {
            TargetPathState[TargetPathState["INITIAL"] = 0] = "INITIAL";
            TargetPathState[TargetPathState["DOUBLE_CURLY_BRACKET_BEGIN"] = 1] = "DOUBLE_CURLY_BRACKET_BEGIN";
            TargetPathState[TargetPathState["SINGLE_CURLY_BRACKET_BEGIN"] = 2] = "SINGLE_CURLY_BRACKET_BEGIN";
            TargetPathState[TargetPathState["DOUBLE_CURLY_BRACKET_VALUE"] = 3] = "DOUBLE_CURLY_BRACKET_VALUE";
            TargetPathState[TargetPathState["SINGLE_CURLY_BRACKET_VALUE"] = 4] = "SINGLE_CURLY_BRACKET_VALUE";
            TargetPathState[TargetPathState["ESCAPE"] = 5] = "ESCAPE";
        })(TargetPathState || (TargetPathState = {}));
        ;
        if (value[0] === '#') {
            return [{
                    targetPath: value,
                    index: 0
                }];
        }
        let result = [];
        let state = TargetPathState.INITIAL;
        let posStart = -1;
        for (let i = 0; i < value.length; i++) {
            if (value[i] === '{') {
                if (state === TargetPathState.INITIAL) {
                    state = TargetPathState.SINGLE_CURLY_BRACKET_BEGIN;
                    posStart = i;
                }
                else if (state === TargetPathState.SINGLE_CURLY_BRACKET_BEGIN) {
                    state = TargetPathState.DOUBLE_CURLY_BRACKET_BEGIN;
                    posStart = i;
                }
            }
            else if (value[i] === '}') {
                if ([TargetPathState.DOUBLE_CURLY_BRACKET_BEGIN, TargetPathState.DOUBLE_CURLY_BRACKET_VALUE, TargetPathState.SINGLE_CURLY_BRACKET_BEGIN, TargetPathState.SINGLE_CURLY_BRACKET_VALUE].includes(state)) {
                    let j = i;
                    while (value[j] === '}' && j < value.length) {
                        j++;
                    }
                    let numBrackets = j - i;
                    if ([TargetPathState.SINGLE_CURLY_BRACKET_BEGIN, TargetPathState.SINGLE_CURLY_BRACKET_VALUE].includes(state)) {
                        if (numBrackets >= 1) {
                            let targetPathOrBinding = value.slice(posStart + 1, j - 1);
                            result.push({
                                targetPath: targetPathOrBinding,
                                index: posStart + 1
                            });
                            state = TargetPathState.INITIAL;
                        }
                    }
                    else if (state === TargetPathState.DOUBLE_CURLY_BRACKET_BEGIN || state === TargetPathState.DOUBLE_CURLY_BRACKET_VALUE) {
                        if (numBrackets >= 2) {
                            let targetPathOrBinding = value.slice(posStart + 1, j - 2);
                            result.push({
                                targetPath: targetPathOrBinding,
                                index: posStart + 1
                            });
                            state = TargetPathState.INITIAL;
                        }
                        else {
                            let targetPathOrBinding = value.slice(posStart, j - 1);
                            result.push({
                                targetPath: targetPathOrBinding,
                                index: posStart
                            });
                            state = TargetPathState.INITIAL;
                        }
                    }
                    i = j;
                }
            }
            else if (value[i] === '`') {
                if (state !== TargetPathState.ESCAPE) {
                    state = TargetPathState.ESCAPE;
                }
                else {
                    state = TargetPathState.INITIAL;
                }
            }
            else {
                if (state === TargetPathState.DOUBLE_CURLY_BRACKET_BEGIN) {
                    state = TargetPathState.DOUBLE_CURLY_BRACKET_VALUE;
                }
                else if (state === TargetPathState.SINGLE_CURLY_BRACKET_BEGIN) {
                    state = TargetPathState.SINGLE_CURLY_BRACKET_VALUE;
                }
            }
        }
        for (let i = result.length - 1; i >= 0; i--) {
            let targetPathOrBinding = result[i].targetPath;
            if (this._isI18nIndicatorOption(targetPathOrBinding)) {
                result.splice(i, 1);
            }
        }
        return result;
    }
    _isI18nIndicatorOption(str) {
        const OPTIONS = [
            "minimumIntegerDigits",
            "minimumFractionDigits",
            "maximumFractionDigits",
            "useGrouping",
            "format"
        ];
        let result = OPTIONS.some(option => str.includes(option));
        return result;
    }
    _findpage(document, pages) {
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            if (PathUtil_1.PathUtil.getMDKFileType(document.uri) !== PathUtil_1.MDKFileType.Action) {
                return;
            }
            const fullPath = vscode_uri_1.default.parse(document.uri).fsPath;
            let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(fullPath, this._documentProvider);
            let fileReference = yield appDelegate.toFileReference(fullPath);
            result = pages.find(page => {
                // return JSON.stringify(page.definition).indexOf(fileReference) > -1;
                return page.content.indexOf(fileReference) > -1;
            });
            return result;
        });
    }
}
exports.TargetPathValidator = TargetPathValidator;
//# sourceMappingURL=TargetPathValidator.js.map