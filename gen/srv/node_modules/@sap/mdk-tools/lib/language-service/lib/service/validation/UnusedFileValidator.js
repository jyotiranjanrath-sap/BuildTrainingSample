"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnusedFileValidator = void 0;
const Json = require("jsonc-parser");
const _ = require("lodash");
const LanguageHelper_1 = require("../../common/LanguageHelper");
const LogUtil_1 = require("../../common/LogUtil");
const PathUtil_1 = require("../../common/PathUtil");
const RuleHelper_1 = require("../../common/RuleHelper");
const MDKApplicationDelegate_1 = require("../../export/MDKApplicationDelegate");
class UnusedFileValidator {
    constructor(documentProvider) {
        if (!documentProvider) {
            LogUtil_1.Log.error("undefined documentProvider provided for FileReferenceValidator.");
        }
        this._documentProvider = documentProvider;
        this._context = {};
        this._currentAppInfo = null;
    }
    setup(document, context) {
        return __awaiter(this, void 0, void 0, function* () {
            this._context[document.uri] = Object.assign({}, context);
            if (this._currentAppInfo == null) {
                let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(document.uri, this._documentProvider);
                this._currentAppInfo = yield appDelegate.getApplicationInfo();
            }
        });
    }
    validateJsonDocument(document, jsonDocument) {
        return __awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    checkJsonNodeSync(document, node) {
        if (PathUtil_1.PathUtil.getMDKFileType(document.uri) === PathUtil_1.MDKFileType.App && LanguageHelper_1.LanguageHelper.isStringValue(node) && node.parent && node.parent.keyNode && node.parent.keyNode.value === "Path") {
            return false;
        }
        if (LanguageHelper_1.LanguageHelper.isPathSuffixValueNode(document.uri, node)) {
            return false;
        }
        if (PathUtil_1.PathUtil.getMDKFileType(document.uri) === PathUtil_1.MDKFileType.Service && node && node.parent && node.parent.keyNode && node.parent.keyNode.value === "ServiceUrl") {
            return false;
        }
        if (node && node.type === 'string' && !LanguageHelper_1.LanguageHelper.isKey(node)) {
            let jsonErrors = [];
            let jsonObj = Json.parse(document.getText(), jsonErrors);
            if (jsonObj['_Type'] === 'Action.Type.RestService.SendRequest' && node.parent && node.parent.keyNode && (node.parent.keyNode.value === 'Path' || node.parent.keyNode.value === 'OutputPath')) {
                return false;
            }
            return true;
        }
        return false;
    }
    validateJsonNode(document, node, schema) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._validateJsonNodeFileReference(document, node);
        });
    }
    checkJsNodeSync(document, node) {
        return node && node.type === "Literal" || node.type === 'ImportDeclaration' ||
            RuleHelper_1.RuleHelper.checkEsprimaNode(node, "executeAction") ||
            RuleHelper_1.RuleHelper.checkEsprimaNode(node, "getGlobalDefinition");
    }
    validateTypeScriptNode(document, action) {
        return __awaiter(this, void 0, void 0, function* () {
            let results = [];
            let loc = {
                start: { line: 1, column: 1 },
                end: { line: 1, column: 1 }
            };
            results.push({
                range: RuleHelper_1.RuleHelper.getRangeFromEsprimaLocation(loc),
                path: action
            });
            return this._validateTypeScriptFileReference(document, results);
        });
    }
    validateJsNode(document, node, loc) {
        return __awaiter(this, void 0, void 0, function* () {
            let results = [];
            if (node && loc) {
                if (node.type === "Literal") {
                    let literalValue = _.trim(node.value, '"\'');
                    if (PathUtil_1.PathUtil.isMDKFile(literalValue)) {
                        results.push({
                            range: RuleHelper_1.RuleHelper.getRangeFromEsprimaLocation(loc),
                            path: literalValue
                        });
                    }
                }
                else if (node.type === 'ImportDeclaration') {
                    let importPath = node.source.value;
                    if (importPath.lastIndexOf('.js') < 0) {
                        importPath += '.js';
                    }
                    let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(document.uri, this._documentProvider, this._context[document.uri].referenceApps);
                    let fileReference = yield appDelegate.toFileReferenceFromImport(importPath);
                    if (PathUtil_1.PathUtil.isMDKFile(fileReference)) {
                        results.push({
                            range: RuleHelper_1.RuleHelper.getRangeFromEsprimaLocation(loc),
                            path: fileReference
                        });
                    }
                }
                else {
                    let loc = node.arguments[0].loc;
                    results.push({
                        range: RuleHelper_1.RuleHelper.getRangeFromEsprimaLocation(loc),
                        path: node.arguments[0].value
                    });
                }
            }
            return this._validateJsNodeFileReference(document, results);
        });
    }
    cleanup(document, diagnostics) {
        return __awaiter(this, void 0, void 0, function* () {
            this._context[document.uri] = null;
            return diagnostics;
        });
    }
    _validateJsNodeFileReference(document, results) {
        return __awaiter(this, void 0, void 0, function* () {
            let promises = [];
            results.forEach(result => {
                if (!!result.path) {
                    let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(document.uri, this._documentProvider, this._context[document.uri].referenceApps);
                    promises.push(appDelegate.checkUnusedFileReference(result.path));
                }
            });
            return Promise.all(promises).then(fileReferenceCheckArray => {
                let results = [];
                fileReferenceCheckArray.forEach(result => {
                    if (result !== '') {
                        results.push(result);
                    }
                });
                return results;
            }).catch(error => {
                LogUtil_1.Log.debug(error);
                return [];
            });
        });
    }
    _validateTypeScriptFileReference(document, results) {
        return __awaiter(this, void 0, void 0, function* () {
            let promises = [];
            results.forEach(result => {
                if (!!result.path) {
                    let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(document.uri, this._documentProvider, this._context[document.uri].referenceApps);
                    promises.push(appDelegate.checkExtensionUnusedFileReference(result.path, this._currentAppInfo.basePath));
                }
            });
            return Promise.all(promises).then(fileReferenceCheckArray => {
                let results = [];
                fileReferenceCheckArray.forEach(result => {
                    if (result !== '') {
                        results.push(result);
                    }
                });
                return results;
            }).catch(error => {
                LogUtil_1.Log.debug(error);
                return [];
            });
        });
    }
    _validateJsonNodeFileReference(document, node) {
        return __awaiter(this, void 0, void 0, function* () {
            let _this = this;
            if (node.value.startsWith("/")) {
                let anchorDocumentuRIs = [document.uri];
                if (PathUtil_1.PathUtil.getMDKFileType(document.uri) === PathUtil_1.MDKFileType.CIM && this._context[document.uri].allAppFullPaths) {
                    anchorDocumentuRIs = anchorDocumentuRIs.concat(this._context[document.uri].allAppFullPaths);
                }
                let promises = [];
                anchorDocumentuRIs.forEach(anchorDocumentUri => {
                    let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(anchorDocumentUri, _this._documentProvider, this._context[document.uri].referenceApps);
                    promises.push(appDelegate.checkUnusedFileReference(node.value));
                });
                return Promise.all(promises).then((fileReferenceCheckArray) => __awaiter(this, void 0, void 0, function* () {
                    let results = [];
                    fileReferenceCheckArray.forEach(result => {
                        if (result !== '') {
                            results.push(result);
                        }
                    });
                    return results;
                }), (error) => {
                    LogUtil_1.Log.debug(error);
                    return [];
                });
            }
            return [];
        });
    }
}
exports.UnusedFileValidator = UnusedFileValidator;
//# sourceMappingURL=UnusedFileValidator.js.map