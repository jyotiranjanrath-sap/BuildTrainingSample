"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidationFacade = void 0;
const path = require("path");
const jsonParser_1 = require("vscode-json-languageservice/lib/umd/parser/jsonParser");
const LogUtil_1 = require("../../common/LogUtil");
const PathUtil_1 = require("../../common/PathUtil");
const UnusedFileValidator_1 = require("../../service/validation/UnusedFileValidator");
const SchemaVersionAdapter_1 = require("../../tool/SchemaVersionAdapter");
const SchemaProvider_1 = require("../schema/SchemaProvider");
class ValidationFacade {
    constructor(documentProvider) {
        this._registeredValidators = [];
        this._unusedFileChecker = new UnusedFileValidator_1.UnusedFileValidator(documentProvider);
    }
    register(validator) {
        if (validator) {
            if (this._registeredValidators.indexOf(validator) >= 0) {
                LogUtil_1.Log.error("validator registered more than one time.");
            }
            else {
                this._registeredValidators.push(validator);
            }
        }
        else {
            LogUtil_1.Log.error("a undefined validator is trying to register.");
        }
    }
    validate(document, context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!document) {
                LogUtil_1.Log.error("No document specified to validate.");
                return [];
            }
            let diagnostics = [];
            try {
                let fileType = PathUtil_1.PathUtil.getMDKFileType(document.uri);
                if (this._filterFiles(document.uri)) {
                    return [];
                }
                let _matchedValidators = this._resetValidators(document);
                yield this._setup(_matchedValidators, document, context);
                let fileName = path.basename(document.uri);
                if (_isMetadataFile(fileType) || fileType === PathUtil_1.MDKFileType.MergeMap || ["mdkproject.json", "brandedsettings.json"].includes(fileName.toLowerCase())) {
                    diagnostics = yield this._validateMetadata(_matchedValidators, document, context);
                }
                else if (_isRuleFile(fileType)) {
                    diagnostics = yield this._validateRule(_matchedValidators, document);
                }
                else {
                    // Log.error(`Not recoginzed file type '${fileType}' to validate.`);
                }
                diagnostics = yield this._cleanup(_matchedValidators, document, diagnostics);
            }
            catch (error) {
                LogUtil_1.Log.error(error);
            }
            return diagnostics;
        });
    }
    checkUnused(document, context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!document) {
                LogUtil_1.Log.error("No document specified to validate.");
                return [];
            }
            let diagnostics = [];
            try {
                yield this._unusedFileChecker.setup(document, context);
                let fileType = PathUtil_1.PathUtil.getMDKFileType(document.uri);
                if (this._filterFiles(document.uri)) {
                    return [];
                }
                if (_isMetadataFile(fileType)) {
                    diagnostics = yield this._checkMetadata(document, context);
                }
                else if (_isRuleFile(fileType)) {
                    diagnostics = yield this._checkRule(document);
                }
                else if (_isExtensionFile(fileType)) {
                    diagnostics = yield this._checkExtension(document);
                }
                else {
                    // Log.error(`Not recoginzed file type '${fileType}' to validate.`);
                }
                //diagnostics = await this._cleanup(document, diagnostics);
            }
            catch (error) {
                LogUtil_1.Log.error(error);
            }
            return diagnostics;
        });
    }
    _resetValidators(document) {
        let _matchedValidators = [];
        this._registeredValidators.forEach(validator => {
            if (validator.isSupportDocument(document)) {
                _matchedValidators.push(validator);
            }
        });
        return _matchedValidators;
    }
    _checkMetadata(document, context) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let jsonDocument = (0, jsonParser_1.parse)(document);
                let schemaVersion = yield SchemaVersionAdapter_1.SchemaVersionHelper.getApplicationSchemaVersion(document.uri);
                let schemaString = yield SchemaProvider_1.SchemaProvider.getInstance(schemaVersion).getSchemaForMetadata(document.uri, jsonDocument, context);
                let schema = JSON.parse(schemaString);
                let matchingSchemas = jsonDocument.getMatchingSchemas(schema);
                let promises = [];
                jsonDocument.visit(node => {
                    if (node) {
                        let matchingSchema = matchingSchemas.find(ms => {
                            if (ms.node === node && !ms.inverted && ms.schema) {
                                return true;
                            }
                        });
                        if (this._unusedFileChecker.checkJsonNodeSync(document, node)) {
                            let schema = matchingSchema ? matchingSchema.schema : undefined;
                            promises.push(this._unusedFileChecker.validateJsonNode(document, node, schema));
                        }
                    }
                    return true;
                });
                return Promise.all(promises).then(allNodeDiagnostics => {
                    let ret = [];
                    allNodeDiagnostics.forEach(item => {
                        if (item.length > 0) {
                            ret = ret.concat(item);
                        }
                    });
                    return ret;
                });
            }
            catch (error) {
                LogUtil_1.Log.debug(error);
                return [];
            }
        });
    }
    _checkRule(document) {
        return __awaiter(this, void 0, void 0, function* () {
            let promises = [];
            try {
                let self = this;
                let esprima = require('esprima');
                esprima.parseModule(document.getText(), {
                    loc: true,
                    tolerant: true,
                    comment: true
                }, function (node, loc) {
                    if (self._unusedFileChecker.checkJsNodeSync(document, node)) {
                        promises.push(self._unusedFileChecker.validateJsNode(document, node, loc));
                    }
                });
            }
            catch (error) {
                LogUtil_1.Log.debug(error);
            }
            return Promise.all(promises).then(allDiagnostics => {
                let ret = [];
                allDiagnostics.forEach(item => {
                    if (item.length > 0) {
                        ret = ret.concat(item);
                    }
                });
                return ret;
            }).catch(error => {
                LogUtil_1.Log.error(error);
                return [];
            });
        });
    }
    _checkExtension(document) {
        return __awaiter(this, void 0, void 0, function* () {
            let promises = [];
            try {
                const actions = document.getText().match(/\.executeAction\((\s*(".+"|'.+'|`.+`)\s*\)|{\s*Name\s*:\s*(".+"|'.+'|`.+`)\s*,)/gm);
                if (actions.length > 0) {
                    actions.forEach(action => {
                        const path = action.match(/"(.+)"|'(.+)'|`(.+)`/);
                        if (path.length > 1) {
                            const path2 = path[1] != undefined ? path[1] : (path[2] != undefined ? path[2] : path[3]);
                            promises.push(this._unusedFileChecker.validateTypeScriptNode(document, path2));
                        }
                    });
                }
            }
            catch (error) {
                LogUtil_1.Log.debug(error);
            }
            return Promise.all(promises).then(allDiagnostics => {
                let ret = [];
                allDiagnostics.forEach(item => {
                    if (item.length > 0) {
                        ret = ret.concat(item);
                    }
                });
                return ret;
            }).catch(error => {
                LogUtil_1.Log.error(error);
                return [];
            });
        });
    }
    _filterFiles(sFilePath) {
        if (sFilePath.split('/').some(sPathComponent => {
            return sPathComponent.length > 1 && sPathComponent[0] === '.';
        })) {
            return true;
        }
    }
    _setup(validators, document, context) {
        return __awaiter(this, void 0, void 0, function* () {
            let promises = [];
            validators.forEach(validator => {
                promises.push(validator.setup(document, context));
            });
            yield Promise.all(promises);
        });
    }
    _validateMetadata(validators, document, context) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // let self = this;
                let jsonDocument = (0, jsonParser_1.parse)(document, {
                    collectComments: true
                });
                if (jsonDocument.syntaxErrors && jsonDocument.syntaxErrors.length > 0) {
                    return jsonDocument.syntaxErrors;
                }
                let schemaVersion = yield SchemaVersionAdapter_1.SchemaVersionHelper.getApplicationSchemaVersion(document.uri);
                let schemaString = yield SchemaProvider_1.SchemaProvider.getInstance(schemaVersion).getSchemaForMetadata(document.uri, jsonDocument, context);
                let schema = JSON.parse(schemaString);
                let matchingSchemas = jsonDocument.getMatchingSchemas(schema);
                return this._validateJsonDocument(validators, document, jsonDocument, matchingSchemas).then(documentDiagnostics => {
                    let promises = [];
                    if (validators.length > 0) {
                        jsonDocument.visit(node => {
                            if (node) {
                                let matchingSchema = matchingSchemas.find(ms => {
                                    if (ms.node === node && !ms.inverted && ms.schema) {
                                        return true;
                                    }
                                });
                                validators.forEach(validator => {
                                    if (validator.checkJsonNodeSync(document, node)) {
                                        let schema = matchingSchema ? matchingSchema.schema : undefined;
                                        promises.push(validator.validateJsonNode(document, node, schema));
                                    }
                                });
                            }
                            return true;
                        });
                    }
                    return Promise.all(promises).then(allNodeDiagnostics => {
                        return documentDiagnostics.concat(_flatDiagnostics(allNodeDiagnostics));
                    });
                }).catch(error => {
                    LogUtil_1.Log.debug(error);
                    return [];
                });
            }
            catch (error) {
                LogUtil_1.Log.debug(error);
                return [];
            }
        });
    }
    _validateRule(validators, document) {
        return __awaiter(this, void 0, void 0, function* () {
            let promises = [];
            try {
                // let self = this;
                let esprima = require('esprima');
                esprima.parseModule(document.getText(), {
                    loc: true,
                    tolerant: true,
                    comment: true
                }, function (node, loc) {
                    validators.forEach(validator => {
                        if (validator.checkJsNodeSync(document, node)) {
                            promises.push(validator.validateJsNode(document, node, loc));
                        }
                    });
                });
            }
            catch (error) {
                LogUtil_1.Log.debug(error);
            }
            return Promise.all(promises).then(allDiagnostics => {
                return _flatDiagnostics(allDiagnostics);
            }).catch(error => {
                LogUtil_1.Log.error(error);
                return [];
            });
        });
    }
    _validateJsonDocument(validators, document, jsonDocument, matchingSchemas) {
        return __awaiter(this, void 0, void 0, function* () {
            let promises = [];
            validators.forEach(validator => {
                promises.push(validator.validateJsonDocument(document, jsonDocument, matchingSchemas));
            });
            return Promise.all(promises).then(allDiagnostics => {
                return _flatDiagnostics(allDiagnostics);
            }).catch(error => {
                LogUtil_1.Log.error(error);
                return [];
            });
        });
    }
    _cleanup(validators, document, diagnostics) {
        return __awaiter(this, void 0, void 0, function* () {
            let promises = [];
            validators.forEach(validator => {
                promises.push(validator.cleanup(document, diagnostics));
            });
            return Promise.all(promises).then(allDiagnostics => {
                return _removeDuplicated(_flatDiagnostics(allDiagnostics));
            });
        });
    }
}
exports.ValidationFacade = ValidationFacade;
function _isExtensionFile(fileType) {
    return PathUtil_1.MDKFileType.Extension === fileType;
}
function _isMetadataFile(fileType) {
    return [
        PathUtil_1.MDKFileType.Action,
        PathUtil_1.MDKFileType.Page,
        PathUtil_1.MDKFileType.Global,
        PathUtil_1.MDKFileType.Service,
        PathUtil_1.MDKFileType.App,
        PathUtil_1.MDKFileType.CIM,
        PathUtil_1.MDKFileType.Fragment,
        PathUtil_1.MDKFileType.ExtensionMetadata
    ].some(eachType => eachType === fileType);
}
function _isRuleFile(fileType) {
    return PathUtil_1.MDKFileType.Rule === fileType;
}
function _flatDiagnostics(allDiagnostics) {
    let newDiagnostics = [];
    allDiagnostics.forEach(diagnostics => {
        if (diagnostics && diagnostics.length > 0) {
            newDiagnostics = newDiagnostics.concat(diagnostics);
        }
    });
    return newDiagnostics;
}
function _removeDuplicated(diagnostics) {
    let newDiagnostics = [];
    if (diagnostics) {
        diagnostics.forEach(diagnostic => {
            if (diagnostic) {
                let duplicatedOne = newDiagnostics.find(newDiagnostic => {
                    return newDiagnostic.range && newDiagnostic.range.start.line === diagnostic.range.start.line &&
                        newDiagnostic.range.start.character === diagnostic.range.start.character &&
                        newDiagnostic.message === diagnostic.message;
                });
                if (!duplicatedOne) {
                    newDiagnostics.push(diagnostic);
                }
            }
        });
    }
    return newDiagnostics;
}
//# sourceMappingURL=ValidationFacade.js.map