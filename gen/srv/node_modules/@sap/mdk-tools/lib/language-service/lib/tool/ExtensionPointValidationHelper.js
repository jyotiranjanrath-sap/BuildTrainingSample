"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtensionPointValidationHelper = void 0;
const Json = require("jsonc-parser");
const _ = require("lodash");
const MDKDocumentProvider_1 = require("../export/MDKDocumentProvider");
const mdkLanguageService_1 = require("../mdkLanguageService");
const mdkLanguageTypes_1 = require("../mdkLanguageTypes");
let jsonParser = require('vscode-json-languageservice/lib/umd/parser/jsonParser.js');
const KEY_NAME_METADATA = "_Name";
const KEY_ARRAY_INSERT_AFTER_NAME = "NameAfter";
const KEY_ARRAY_INSERT_AFTER_INDEX = "IndexAfter";
const KEY_ARRAY_INSERT_BEFORE_NAME = "NameBefore";
const KEY_ARRAY_INSERT_BEFORE_INDEX = "IndexBefore";
const KEY_ARRAY_REMOVE = "Remove";
const KEY_ARRAY_REORDER = "Reorder";
const KEY_ARRAY_ADD = "Add";
const KEY_SEP = "/";
const VALUE_REMOVED = "undefined";
const MAX_DIFF_COUNT = 2046;
class ExtensionPointValidationHelper {
    constructor(sBaseFilePath) {
        this.mergePathMap = new Map();
        this.baseFilePath = sBaseFilePath;
        this.documentProvider = new MDKDocumentProvider_1.MDKFileSystemDocumentProvider();
    }
    resolve(document, jsonDocument) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.baseFilePath) {
                const sBaseFileContent = yield this.documentProvider.getDocumentText(this.baseFilePath);
                let mergeContent = document.getText();
                mergeContent = this._mergeMetadata(sBaseFileContent, mergeContent);
                this.document = mdkLanguageTypes_1.TextDocument.create(document.uri, 'com.sap.mdk', 1.0, mergeContent);
                this.jsonDocument = jsonParser.parse(this.document);
            }
            else {
                this.document = document;
                this.jsonDocument = jsonDocument;
            }
        });
    }
    convertDiagnosticRange(document, jsonDocument, diagnostic) {
        let offsetNew = this.document.offsetAt(diagnostic.range.start);
        let nodeNew = this.jsonDocument.getNodeFromOffset(offsetNew);
        let jsonPath = jsonParser.getNodePath(nodeNew);
        let jsonPathStr = jsonPath.join('|');
        if (this.mergePathMap.has(jsonPathStr)) {
            jsonPath = this.mergePathMap.get(jsonPathStr);
        }
        let node = Json.findNodeAtLocation(jsonDocument.root, jsonPath);
        if (node) {
            let range = mdkLanguageTypes_1.Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));
            diagnostic.range = range;
            return diagnostic;
        }
        return null;
    }
    _mergeMetadata(sSource, sMap) {
        const baseFileType = mdkLanguageService_1.PathUtil.getMDKFileType(this.baseFilePath);
        if (baseFileType !== mdkLanguageService_1.MDKFileType.Rule) {
            if (sMap) {
                let oSource = JSON.parse(sSource);
                let oMap = JSON.parse(sMap);
                let targetObj;
                if (Array.isArray(oMap)) {
                    if (oMap.length > MAX_DIFF_COUNT) {
                        throw Error(`Changes number is ${oMap.length}, it exceeds max allowed number ${MAX_DIFF_COUNT}.`);
                    }
                    else {
                        oMap.forEach((item, index) => {
                            //if no Name, it will be applied to root object. this is a patch for .fragment.
                            if (!item[KEY_NAME_METADATA] && oSource[KEY_NAME_METADATA]) {
                                item[KEY_NAME_METADATA] = oSource[KEY_NAME_METADATA];
                            }
                            targetObj = this._findObjectByName(oSource, item[KEY_NAME_METADATA]);
                            if (targetObj) {
                                this._mergeOneExtension(targetObj.obj, item, targetObj.jsonPath, [index]);
                            }
                            else {
                                // throw Error(`No object with _Name ${item[KEY_NAME_METADATA]} in base file` );
                            }
                        });
                    }
                }
                else {
                    if (!oMap[KEY_NAME_METADATA] && oSource[KEY_NAME_METADATA]) {
                        oMap[KEY_NAME_METADATA] = oSource[KEY_NAME_METADATA];
                    }
                    targetObj = this._findObjectByName(oSource, oMap[KEY_NAME_METADATA]);
                    if (targetObj) {
                        this._mergeOneExtension(targetObj.obj, oMap, targetObj.jsonPath);
                    }
                    else {
                        // throw Error(`No object with _Name ${oMap[KEY_NAME_METADATA]} in base file` );
                    }
                }
                return JSON.stringify(oSource, null, "\t");
            }
            else {
                return sSource;
            }
        }
    }
    _mergeOneExtension(oSource, oItem, sourcePath = [], mergePath = []) {
        for (let key in oItem) {
            if (oItem.hasOwnProperty(key) && key !== KEY_NAME_METADATA) {
                let oRet = this._getParentWithKey(oSource, key, sourcePath);
                let oSourceParent = oRet.parent;
                let sSourceKey = oRet.key;
                if (this._isArrayChange(oItem[key])) {
                    if (oSourceParent[sSourceKey] === undefined) {
                        oSourceParent[sSourceKey] = [];
                    }
                    if (oSourceParent[sSourceKey] && Array.isArray(oSourceParent[sSourceKey])) {
                        //remove
                        if (oItem[key][KEY_ARRAY_REMOVE]) {
                            oItem[key][KEY_ARRAY_REMOVE].forEach((item) => {
                                const sourceIndex = oSourceParent[sSourceKey].findIndex(souceItem => { return item.Name ? item.Name === souceItem._Name : _.isEqual(souceItem, item); });
                                oSourceParent[sSourceKey].splice(sourceIndex, 1);
                            });
                            // for remove, no need to set mergePathMap
                        }
                        //reorder
                        if (oItem[key][KEY_ARRAY_REORDER]) {
                            let newArr = [];
                            for (let i = 0; i < oItem[key][KEY_ARRAY_REORDER].length; i++) {
                                let index = oItem[key][KEY_ARRAY_REORDER][i];
                                let value = oSourceParent[sSourceKey][index];
                                newArr.push(value);
                                // for reorder, no need to set mergePathMap
                            }
                            oSourceParent[sSourceKey] = newArr;
                        }
                        //add
                        if (oItem[key][KEY_ARRAY_ADD]) {
                            sourcePath = oRet.jsonPath.concat(sSourceKey);
                            mergePath = mergePath.concat([key, KEY_ARRAY_ADD]);
                            oItem[key][KEY_ARRAY_ADD].forEach((item, index) => {
                                const targetName = item[KEY_ARRAY_INSERT_AFTER_NAME] !== undefined ? item[KEY_ARRAY_INSERT_AFTER_NAME] : item[KEY_ARRAY_INSERT_BEFORE_NAME];
                                const targetIndex = item[KEY_ARRAY_INSERT_AFTER_INDEX] !== undefined ? item[KEY_ARRAY_INSERT_AFTER_INDEX] : item[KEY_ARRAY_INSERT_BEFORE_INDEX];
                                if (targetName !== undefined && item.Value !== undefined) {
                                    const iIndex = oSourceParent[sSourceKey].findIndex(souceItem => { return souceItem._Name === targetName; });
                                    if (item[KEY_ARRAY_INSERT_AFTER_NAME]) {
                                        oSourceParent[sSourceKey].splice(iIndex + 1, 0, item.Value);
                                        // set mergePathMap
                                        this.setValuePathMap(item.Value, sourcePath.concat(iIndex + 1), mergePath.concat([index, "Value"]));
                                    }
                                    else {
                                        oSourceParent[sSourceKey].splice(iIndex - 1, 0, item.Value);
                                        // set mergePathMap
                                        this.setValuePathMap(item.Value, sourcePath.concat(iIndex - 1), mergePath.concat([index, "Value"]));
                                    }
                                }
                                else if (targetIndex !== undefined && item.Value !== undefined) { //add after index
                                    if (item[KEY_ARRAY_INSERT_AFTER_INDEX] !== undefined) {
                                        oSourceParent[sSourceKey].splice(item[KEY_ARRAY_INSERT_AFTER_INDEX] + 1, 0, item.Value);
                                        // set mergePathMap
                                        this.setValuePathMap(item.Value, sourcePath.concat(item[KEY_ARRAY_INSERT_AFTER_INDEX] + 1), mergePath.concat([index, "Value"]));
                                    }
                                    else {
                                        //the index is from end
                                        const realIndex = oSourceParent[sSourceKey].length - item[KEY_ARRAY_INSERT_BEFORE_INDEX] - 1;
                                        oSourceParent[sSourceKey].splice(realIndex, 0, item.Value);
                                        // set mergePathMap
                                        this.setValuePathMap(item.Value, sourcePath.concat(realIndex), mergePath.concat([index, "Value"]));
                                    }
                                }
                                else {
                                    // vscode.window.showErrorMessage(`Failed to merge ${oSourceParent[KEY_NAME_METADATA]} ${sSourceKey}`);
                                }
                            });
                        }
                    }
                    else {
                        //unsupport array operation, it may caused by base changed arrary into
                        // throw Error(`Failed to merge array into another type: ${oItem[KEY_NAME_METADATA]}.${sSourceKey}`);
                    }
                }
                else {
                    if (oItem[key] === VALUE_REMOVED) {
                        delete oSourceParent[sSourceKey];
                        // for remove, no need to set mergePathMap
                    }
                    else {
                        oSourceParent[sSourceKey] = oItem[key]; //simple
                        // set mergePathMap
                        this.setValuePathMap(oItem[key], oRet.jsonPath.concat(sSourceKey), mergePath.concat(key));
                    }
                }
            }
        }
    }
    keyToSegment(key) {
        let type = Number(key);
        return isNaN(type) ? key : type;
    }
    _isArrayChange(oChange) {
        return oChange && (oChange[KEY_ARRAY_ADD] || oChange[KEY_ARRAY_REORDER] || oChange[KEY_ARRAY_REMOVE]);
    }
    _findObjectByName(obj, name, sourcePath = []) {
        if (name === undefined) {
            return { obj: obj, jsonPath: sourcePath };
        }
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                const value = obj[key];
                if (key === '_Name' && value === name) {
                    return { obj: obj, jsonPath: sourcePath };
                }
                if (typeof value === 'object' && value !== null) {
                    const foundObject = this._findObjectByName(value, name, sourcePath.concat(key));
                    if (foundObject !== null) {
                        return { obj: foundObject.obj, jsonPath: foundObject.jsonPath };
                    }
                }
                if (Array.isArray(value)) {
                    for (const item of value) {
                        if (typeof item === 'object' && item !== null) {
                            const foundObject = this._findObjectByName(item, name, sourcePath.concat(key));
                            if (foundObject !== null) {
                                return { obj: foundObject.obj, jsonPath: foundObject.jsonPath };
                            }
                        }
                    }
                }
            }
        }
        return null;
    }
    _getParentWithKey(oSource, key, jsonPath = []) {
        if (key.indexOf(KEY_SEP) === 0) {
            return { parent: oSource, key: key, jsonPath: jsonPath.concat(key) };
        }
        else {
            let aKey = key.split(KEY_SEP);
            let oParent = oSource;
            for (let i = 0; i < aKey.length - 1; i++) {
                if (!oParent[aKey[i]]) {
                    oParent[aKey[i]] = {};
                }
                oParent = oParent[aKey[i]];
                jsonPath = jsonPath.concat(aKey[i]);
            }
            return { parent: oParent, key: aKey[aKey.length - 1], jsonPath: jsonPath };
        }
    }
    setValuePathMap(value, sourcePath, mergePath) {
        if (typeof value === "object") {
            Object.keys(value).forEach(key => {
                let s = value[key];
                let mapKey = sourcePath.concat(key).join('|');
                this.mergePathMap.set(mapKey, mergePath.concat(this.keyToSegment(key)));
                if (s && typeof s === "object") {
                    this.setValuePathMap(s, sourcePath.concat(key), mergePath.concat(this.keyToSegment(key)));
                }
            });
        }
        else {
            this.mergePathMap.set(sourcePath.join('|'), mergePath);
        }
    }
}
exports.ExtensionPointValidationHelper = ExtensionPointValidationHelper;
//# sourceMappingURL=ExtensionPointValidationHelper.js.map