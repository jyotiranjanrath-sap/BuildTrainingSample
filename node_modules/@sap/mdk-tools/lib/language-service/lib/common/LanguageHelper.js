"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LanguageHelper = void 0;
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const _ = require("lodash");
const path = require("path");
const jsonParser_1 = require("vscode-json-languageservice/lib/umd/parser/jsonParser");
const MDKApplicationDelegate_1 = require("../export/MDKApplicationDelegate");
const mdkLanguageTypes_1 = require("../mdkLanguageTypes");
const SchemaProvider_1 = require("../service/schema/SchemaProvider");
const IControl_1 = require("../service/targetpath/IControl");
const SchemaVersionAdapter_1 = require("../tool/SchemaVersionAdapter");
const ODataMetadataProvider_1 = require("./ODataMetadataProvider");
const PathUtil_1 = require("./PathUtil");
const RuleHelper_1 = require("./RuleHelper");
const TargetHelper_1 = require("./TargetHelper");
const utils= require('../../../utils');
var LanguageHelper;
(function (LanguageHelper) {
    function isPathSuffixValueNode(anchorDocumentUri, node) {
        return (PathUtil_1.PathUtil.getMDKFileType(anchorDocumentUri) === PathUtil_1.MDKFileType.Service && LanguageHelper.isStringValue(node) && node && node.parent && node.parent.keyNode && node.parent.keyNode.value === "PathSuffix" && node.parent.parent && node.parent.parent.parent === null);
    }
    LanguageHelper.isPathSuffixValueNode = isPathSuffixValueNode;
    function inExpandedProperties(bindingValue, expandedProperties) {
        if (expandedProperties) {
            return expandedProperties.some(p => p.startsWith(bindingValue));
        }
        return false;
    }
    LanguageHelper.inExpandedProperties = inExpandedProperties;
    /**
     * Return the type of bindingValue, in the format of {type: 'xxx'}
     * @param bindingValue
     * @param anchorDocumentUri
     * @param node
     * @param documentProvider
     * @param appContext
     */
    function resolveBindingValue(bindingValue, anchorDocumentUri, node, documentProvider, appContext) {
        return __awaiter(this, void 0, void 0, function* () {
            let target = LanguageHelper.getTargetObject(node);
            if (target && target.Service) {
                let expandedProperties = TargetHelper_1.TargetHelper.getExpandedProperties(target);
                let referenceApps;
                if (appContext) {
                    referenceApps = appContext.referenceApps;
                }
                let baseAppDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(anchorDocumentUri, documentProvider, referenceApps);
                let serviceFullPath = yield baseAppDelegate.toFileFullPath(target.Service);
                if (target.Function) {
                    let functionName;
                    let namePropertyNode = target.Function.properties.find(propertyNode => propertyNode.keyNode.value === 'Name');
                    if (namePropertyNode && namePropertyNode.valueNode) {
                        functionName = namePropertyNode.valueNode.value;
                    }
                    if (functionName) {
                        let schema = yield ODataMetadataProvider_1.ODataMetadataProvider.instance.getTypeInSchema(serviceFullPath, anchorDocumentUri, functionName, false, true);
                        if (schema && schema.type === 'array') {
                            schema = yield ODataMetadataProvider_1.ODataMetadataProvider.instance.getTypeInSchema(serviceFullPath, anchorDocumentUri, schema.items.type, false, true);
                            return getBindingType(bindingValue, schema, serviceFullPath, anchorDocumentUri, target.QueryOptions, expandedProperties);
                        }
                    }
                }
                else if (target.EntitySet) {
                    let entitySet = target.EntitySet;
                    if (entitySet.indexOf('@odata.readLink') > -1) {
                        const propertyName = entitySet.slice(entitySet.lastIndexOf("/") + 1);
                        if (propertyName) {
                            const designTimeTarget = LanguageHelper.getDesignTimeTargetObject(node);
                            if (designTimeTarget && designTimeTarget.EntitySet) {
                                serviceFullPath = yield baseAppDelegate.toFileFullPath(designTimeTarget.Service);
                                entitySet = yield ODataMetadataProvider_1.ODataMetadataProvider.instance.getEntityByNavigationProperty(serviceFullPath, designTimeTarget.EntitySet, propertyName, anchorDocumentUri);
                                if (entitySet && entitySet.startsWith("Collection(")) {
                                    entitySet = entitySet.slice('Collection('.length, -1);
                                }
                            }
                            else {
                                return;
                            }
                        }
                    }
                    let schema = yield ODataMetadataProvider_1.ODataMetadataProvider.instance.getTypeInSchema(serviceFullPath, anchorDocumentUri, entitySet, true, false);
                    return getBindingType(bindingValue, schema, serviceFullPath, anchorDocumentUri, target.QueryOptions, expandedProperties);
                }
            }
        });
    }
    LanguageHelper.resolveBindingValue = resolveBindingValue;
    function isPropertiesStringValue(node) {
        if (node && node.type === 'string' && node.parent && node.parent.type === 'array' && node.parent.parent && node.parent.parent.type === 'property' && node.parent.parent.keyNode && node.parent.parent.keyNode.value === 'Properties') {
            return true;
        }
        return false;
    }
    LanguageHelper.isPropertiesStringValue = isPropertiesStringValue;
    function getStreamProperties(anchorDocumentUri, node, documentProvider, appContext) {
        return __awaiter(this, void 0, void 0, function* () {
            let target = LanguageHelper.getTargetObject(node);
            if (target && target.Service && target.EntitySet) {
                let referenceApps;
                if (appContext) {
                    referenceApps = appContext.referenceApps;
                }
                let baseAppDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(anchorDocumentUri, documentProvider, referenceApps);
                let serviceFullPath = yield baseAppDelegate.toFileFullPath(target.Service);
                let properties = yield ODataMetadataProvider_1.ODataMetadataProvider.instance.getEntityPropertiesByType(serviceFullPath, target.EntitySet, anchorDocumentUri, 'Edm.Stream');
                return properties;
            }
        });
    }
    LanguageHelper.getStreamProperties = getStreamProperties;
    function getFileReference(textDocument, position) {
        function _detectFileReferenceInRule(textDocument, position) {
            let fileReference = "";
            let esprima = require('esprima');
            esprima.parseModule(textDocument.getText(), {
                loc: true,
                tolerant: true
            }, function (node, loc) {
                if (node.type === "Literal") {
                    let startPosition = RuleHelper_1.RuleHelper.getPositionFromEsprimaPosition(loc.start);
                    let endPosition = RuleHelper_1.RuleHelper.getPositionFromEsprimaPosition(loc.end);
                    if (LanguageHelper.Position.isAfter(position, startPosition) && LanguageHelper.Position.isBefore(position, endPosition)) {
                        let literalValue = _.trim(node.value, '"\'');
                        if (PathUtil_1.PathUtil.isMDKFile(literalValue)) {
                            fileReference = literalValue;
                        }
                    }
                }
            });
            return fileReference;
        }
        function _detectFileReferenceInJSON(textDocument, position) {
            let jsonDocument = (0, jsonParser_1.parse)(textDocument);
            let offset = textDocument.offsetAt(position);
            let node = jsonDocument.getNodeFromOffset(offset, false);
            // let nodeOffset = node.offset;
            // let absolutePosition = offset - nodeOffset;
            if (node && node.type === "string" && !LanguageHelper.isKey(node)) {
                let nodeOffset = node.offset;
                let absolutePosition = offset - nodeOffset;
                let value = node.value;
                let parseValue = PathUtil_1.PathUtil.parseFileReference(node.value, absolutePosition);
                if (parseValue !== -1) {
                    value = parseValue;
                }
                if (PathUtil_1.PathUtil.isMDKFile(value)) {
                    return value;
                }
            }
        }
        let fileReference;
        let fileType = PathUtil_1.PathUtil.getMDKFileType(textDocument.uri);
        if (fileType === PathUtil_1.MDKFileType.Rule) {
            fileReference = _detectFileReferenceInRule(textDocument, position);
        }
        else {
            fileReference = _detectFileReferenceInJSON(textDocument, position);
        }
        return fileReference;
    }
    LanguageHelper.getFileReference = getFileReference;
    /**
     *
     * @param bindingValue in the format of 'a/b/c'
     * @param targetType { type: "", properties: {}}
     */
    function getBindingType(bindingValue, targetType, serviceFullPath, anchorDocumentUri, queryOptions, expandedProperties, prefix) {
        return __awaiter(this, void 0, void 0, function* () {
            if (bindingValue === '') {
                return targetType;
            }
            if (!targetType) {
                return;
            }
            let propertyName = bindingValue;
            let remainingBindingValue;
            let slashIndex = bindingValue.indexOf('/');
            if (slashIndex > -1) {
                propertyName = bindingValue.slice(0, slashIndex);
                remainingBindingValue = bindingValue.slice(slashIndex + 1);
                if (!remainingBindingValue) {
                    return;
                }
            }
            let propertySchema;
            let newSchemaType;
            if (targetType.type === 'array') {
                if (!/^[0-9]+$/.test(propertyName)) {
                    return;
                }
                propertySchema = yield ODataMetadataProvider_1.ODataMetadataProvider.instance.getTypeInSchema(serviceFullPath, anchorDocumentUri, targetType.items.type, false, false);
                newSchemaType = propertySchema;
            }
            else if (targetType.properties && targetType.properties.hasOwnProperty(propertyName)) {
                propertySchema = targetType.properties[propertyName];
                if (propertySchema.description === 'navigationProperty') {
                    let npPath = prefix ? prefix + '/' + propertyName : propertyName;
                    if ((!queryOptions || !queryOptions.startsWith("/")) && !LanguageHelper.inExpandedProperties(npPath, expandedProperties)) {
                        return;
                    }
                }
                newSchemaType = yield ODataMetadataProvider_1.ODataMetadataProvider.instance.getTypeInSchema(serviceFullPath, anchorDocumentUri, propertySchema.type, false, false);
            }
            else {
                return;
            }
            if (remainingBindingValue) {
                return getBindingType(remainingBindingValue, newSchemaType, serviceFullPath, anchorDocumentUri, queryOptions, expandedProperties, prefix ? prefix + '/' + propertyName : propertyName);
            }
            return newSchemaType;
        });
    }
    function populateFunctionSchema(documentUri, functionSchema, functionName, serviceFullPath, filter) {
        return __awaiter(this, void 0, void 0, function* () {
            functionSchema.properties.Name.enum = null;
            functionSchema.properties.Parameters.properties = {};
            functionSchema.properties.Parameters.required = null;
            if (serviceFullPath) {
                let functions = yield ODataMetadataProvider_1.ODataMetadataProvider.instance.getFunctionsandActions(serviceFullPath, documentUri);
                if (filter) {
                    functions = functions.filter((item) => item.returnType && item.returnType.type === 'array');
                }
                if (functions && functions.length > 0) {
                    functionSchema.properties.Name.enum = [];
                    let schemaVersion = yield SchemaVersionAdapter_1.SchemaVersionHelper.getApplicationSchemaVersion(documentUri);
                    let _bindableReferenceSchema = yield SchemaProvider_1.SchemaProvider.getInstance(schemaVersion).getSchemaByPath("definitions/BindableReference.json");
                    functions.forEach((functionItem) => {
                        functionSchema.properties.Name.enum.push(functionItem.name);
                    });
                    let functionFound = functions.find((item) => item.name === functionName);
                    if (functionFound && functionFound.parameter) {
                        functionFound.parameter.forEach(parameter => {
                            let _type = parameter.type;
                            if (_type.type !== "object") {
                                _type = ODataMetadataProvider_1.ODataMetadataProvider.instance.convertTypeToBindable(parameter.type.type, _bindableReferenceSchema);
                                if (typeof _type === "string") {
                                    _type = { "type": _type };
                                }
                            }
                            functionSchema.properties.Parameters.properties[parameter.name] = _type;
                            if (!parameter.nullable) {
                                if (!functionSchema.properties.Parameters.required) {
                                    functionSchema.properties.Parameters.required = [];
                                }
                                functionSchema.properties.Parameters.required.push(parameter.name);
                            }
                        });
                    }
                }
            }
        });
    }
    LanguageHelper.populateFunctionSchema = populateFunctionSchema;
    function isQueryOptionProperty(node) {
        if (node && node.parent && node.parent.keyNode && node === node.parent.valueNode && node.parent.keyNode.value === 'QueryOptions' && node.parent.parent && node.parent.parent.parent && node.parent.parent.parent.keyNode && ["Target", "DesignTimeTarget"].indexOf(node.parent.parent.parent.keyNode.value) > -1) {
            return true;
        }
        return false;
    }
    LanguageHelper.isQueryOptionProperty = isQueryOptionProperty;
    function isListControl(sType) {
        let aListControls = ['Control.Type.List', 'Control.Type.FormCell.SegmentedControl', 'Control.Type.FormCell.ListPicker', 'Control.Type.FormCell.ObjectCellListPicker'];
        if (aListControls.indexOf(sType) > -1) {
            return true;
        }
        else {
            return false;
        }
    }
    LanguageHelper.isListControl = isListControl;
    function getAllActionResults(anchorDocumentUri, documentProvider, referenceApps) {
        return __awaiter(this, void 0, void 0, function* () {
            // console.warn("!!! ---------- getAllActionResults ----------- !!!");
            let result = [];
            let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(anchorDocumentUri, documentProvider, referenceApps);
            let actionFileFullPaths = yield appDelegate.getMDKTypeFileFullPaths(PathUtil_1.MDKFileType.Action);
            for (const actionFileFullPath of actionFileFullPaths) {
                let metadata = yield documentProvider.getDocumentJson(actionFileFullPath);
                if (metadata && metadata['ActionResult']) {
                    result.push({
                        name: metadata['ActionResult']['_Name'],
                        relativePath: yield appDelegate.getMDKTypeFileRelativeReference(PathUtil_1.MDKFileType.Action, actionFileFullPath)
                    });
                }
            }
            return result;
        });
    }
    LanguageHelper.getAllActionResults = getAllActionResults;
    function getAllPages(anchorDocumentUri, documentProvider, referenceApps) {
        return __awaiter(this, void 0, void 0, function* () {
            // console.warn("!!! ---------- getAllPages ----------- !!!");
            let result = [];
            let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(anchorDocumentUri, documentProvider, referenceApps);
            let pageFileFullPaths = yield appDelegate.getMDKTypeFileFullPaths(PathUtil_1.MDKFileType.Page, [PathUtil_1.MDKFileType.Fragment]);
            for (const pageFileFullPath of pageFileFullPaths) {
                let text = yield documentProvider.getDocumentText(pageFileFullPath);
                let fileType = PathUtil_1.PathUtil.getMDKFileType(pageFileFullPath);
                // let metadata = await documentProvider.getDocumentJson(pageFileFullPath);
                let metadata = {};
                try {
                    metadata = JSON.parse(text);
                    if (fileType === PathUtil_1.MDKFileType.Fragment) {
                        metadata = {
                            "fragment": metadata
                        };
                    }
                }
                catch (error) {
                    console.error(error);
                }
                let controls = [];
                getControls(metadata, controls);
                result.push({
                    content: text,
                    definition: metadata,
                    fullPath: pageFileFullPath,
                    relativePath: yield appDelegate.getMDKTypeFileRelativeReference(PathUtil_1.MDKFileType.Page, pageFileFullPath),
                    controls: controls,
                    isMDKPage: fileType === PathUtil_1.MDKFileType.Page
                });
            }
            return result;
        });
    }
    LanguageHelper.getAllPages = getAllPages;
    function getAllFragments(anchorDocumentUri, documentProvider, referenceApps) {
        return __awaiter(this, void 0, void 0, function* () {
            // console.warn("!!! ---------- getAllFragments ----------- !!!");
            let result = [];
            let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(anchorDocumentUri, documentProvider, referenceApps);
            let fragmentFileFullPaths = yield appDelegate.getMDKTypeFileFullPaths(PathUtil_1.MDKFileType.Fragment);
            for (const fragmentFileFullPath of fragmentFileFullPaths) {
                let text = yield documentProvider.getDocumentText(fragmentFileFullPath);
                let metadata = {};
                try {
                    metadata = JSON.parse(text);
                    metadata = {
                        "fragment": metadata
                    };
                }
                catch (error) {
                    console.error(error);
                }
                let controls = [];
                getControls(metadata, controls);
                result.push({
                    content: text,
                    definition: metadata,
                    fullPath: fragmentFileFullPath,
                    relativePath: yield appDelegate.getMDKTypeFileRelativeReference(PathUtil_1.MDKFileType.Fragment, fragmentFileFullPath),
                    controls: controls,
                    isMDKPage: false
                });
            }
            return result;
        });
    }
    LanguageHelper.getAllFragments = getAllFragments;
    function getControls(obj, controls) {
        for (let key in obj) {
            if (obj.hasOwnProperty(key)) {
                let value = obj[key];
                if (typeof value === "object" && value) {
                    if (value._Name) {
                        let control = new IControl_1.IControl();
                        control.name = value._Name;
                        if (value._Type) {
                            control.type = value._Type;
                        }
                        controls.push(control);
                    }
                    getControls(value, controls);
                }
            }
        }
    }
    function getI18nKeyNode(i18nIndicator) {
        let esprima = require('esprima');
        let tokens = esprima.tokenize(i18nIndicator, { loc: true, tolerant: false, tokens: true });
        if (tokens && tokens.length >= 5 && tokens[0].value === '$' && tokens[1].value === '(' && tokens[2].value === 'L' && tokens[3].value === ',') {
            return tokens[4];
        }
        return null;
    }
    LanguageHelper.getI18nKeyNode = getI18nKeyNode;
    function getTargetObject(node) {
        while (node) {
            node = node.parent;
            if (node && node.type === 'object' && node.properties) {
                for (let i = 0; i < node.properties.length; i++) {
                    let property = node.properties[i];
                    let isMatchNode = isStringASTNodeWithName(property.keyNode, 'Target');
                    if (!isMatchNode && !node.parent) {
                        isMatchNode = isStringASTNodeWithName(property.keyNode, 'DesignTimeTarget');
                    }
                    if (isMatchNode) {
                        return _parseTargetObject(property);
                    }
                }
            }
        }
        return null;
    }
    LanguageHelper.getTargetObject = getTargetObject;
    function getDesignTimeTargetObject(node) {
        while (node) {
            node = node.parent;
            if (node && node.type === 'object' && node.properties) {
                for (let i = 0; i < node.properties.length; i++) {
                    let property = node.properties[i];
                    let isMatchNode = isStringASTNodeWithName(property.keyNode, 'DesignTimeTarget');
                    if (isMatchNode && !node.parent) {
                        return _parseTargetObject(property);
                    }
                }
            }
        }
        return null;
    }
    LanguageHelper.getDesignTimeTargetObject = getDesignTimeTargetObject;
    function _parseTargetObject(property) {
        if (property && property.valueNode && property.valueNode.type === 'object' && property.valueNode.properties) {
            let result = {};
            property.valueNode.properties.forEach(propNodeValue => {
                if (isStringASTNodeWithName(propNodeValue.keyNode, 'Service')) {
                    result.Service = propNodeValue.valueNode ? propNodeValue.valueNode.value : null;
                }
                else if (isStringASTNodeWithName(propNodeValue.keyNode, 'EntitySet')) {
                    result.EntitySet = propNodeValue.valueNode ? propNodeValue.valueNode.value : null;
                }
                else if (isStringASTNodeWithName(propNodeValue.keyNode, 'QueryOptions')) {
                    result.QueryOptions = propNodeValue.valueNode ? propNodeValue.valueNode.value : null;
                }
                else if (isStringASTNodeWithName(propNodeValue.keyNode, 'Function')) {
                    result.Function = propNodeValue.valueNode;
                }
            });
            if (!_.isEmpty(result)) {
                return result;
            }
        }
        return null;
    }
    function isStringASTNodeWithName(node, name) {
        if (node && node.type === 'string' && node.value === name) {
            return true;
        }
        return false;
    }
    function getI18nIndicators(value) {
        let result = [];
        let matches = value.match(/\$\([^\)]+\)/g) || [];
        let offset = 0;
        matches.forEach(item => {
            offset = value.indexOf(item, offset);
            result.push({
                indicator: item,
                index: offset
            });
            offset += item.length;
        });
        return result;
    }
    LanguageHelper.getI18nIndicators = getI18nIndicators;
    function getNumOfParms(message) {
        return (message.match(/{/g) || []).length;
    }
    LanguageHelper.getNumOfParms = getNumOfParms;
    function getNumOfCamma(message) {
        return (message.match(/,/g) || []).length;
    }
    LanguageHelper.getNumOfCamma = getNumOfCamma;
    function getI18nIndicatorPrefix(document, position) {
        function getCurrentWord(document, offset) {
            let text = document.getText();
            text = text.substring(0, offset);
            let doubleQuotePos = text.lastIndexOf('"');
            let startPos = doubleQuotePos + 1;
            return text.substring(startPos, offset);
        }
        let result;
        let offset = document.offsetAt(position);
        let prefix = getCurrentWord(document, offset);
        let startSearchPos = 0;
        let i18nIndicators = LanguageHelper.getI18nIndicators(prefix);
        if (i18nIndicators.length > 0) {
            let lastI18nIndicator = i18nIndicators[i18nIndicators.length - 1];
            startSearchPos = lastI18nIndicator.index + lastI18nIndicator.indicator.length;
        }
        let esprima = require('esprima');
        let tokens = esprima.tokenize(prefix, { loc: true, tolerant: true, tokens: true });
        if (tokens) {
            for (let i = tokens.length - 1; i >= 0; i--) {
                let token = tokens[i];
                if (token.loc.start.column >= startSearchPos) {
                    if (token.value === "$") {
                        result = prefix.substr(token.loc.start.column);
                        break;
                    }
                }
                else {
                    break;
                }
            }
        }
        return result;
    }
    LanguageHelper.getI18nIndicatorPrefix = getI18nIndicatorPrefix;
    function isKey(node) {
        return (node && node.parent && node.parent.keyNode === node);
    }
    LanguageHelper.isKey = isKey;
    function isStringValue(node) {
        return (node && node.type === 'string' && !isKey(node));
    }
    LanguageHelper.isStringValue = isStringValue;
    let _maxSchemaVersion = null;
    function _getMaxSchemaVersion(documentProvider) {
        let version = 0.0;
        let schemaRootPath = getSchemaRootPath();
        if (!_maxSchemaVersion) {
            let items = documentProvider.getChildrenFullPathsSync(schemaRootPath, false);
            for (let item of items) {
                if (documentProvider.isFolderSync(item)) {
                    let folderName = path.basename(item);
                    let n = parseFloat(folderName);
                    if (n > version) {
                        version = n;
                    }
                }
            }
            _maxSchemaVersion = version.toFixed(1).toString();
        }
        return _maxSchemaVersion;
    }
    LanguageHelper._getMaxSchemaVersion = _getMaxSchemaVersion;
    let _defaultSchemaVersion = null;
    function getDefaultSchemaVersion(documentProvider) {
        if (!_defaultSchemaVersion) {
            let packageJson = documentProvider.getDocumentJsonSync(path.join(utils.getRootPath(), 'language-service',  'package.json'));
            _defaultSchemaVersion = packageJson['defaultSchemaVersion'];
        }
        return _defaultSchemaVersion;
    }
    LanguageHelper.getDefaultSchemaVersion = getDefaultSchemaVersion;
    let _supportSchemaVersion = null;
    function getSupportSchemaVersion(documentProvider) {
        if (!_supportSchemaVersion) {
            let packageJson = documentProvider.getDocumentJsonSync(path.join(utils.getRootPath(), 'language-service',  'package.json'));
            _supportSchemaVersion = packageJson['supportSchemaVersion'];
        }
        return _supportSchemaVersion;
    }
    LanguageHelper.getSupportSchemaVersion = getSupportSchemaVersion;
    function getSchemaVersion(sdkVersion, documentProvider) {
        let schemaVersion = sdkVersion;
        if (schemaVersion) {
            let versionSegs = sdkVersion.split('.');
            if (versionSegs.length > 1) {
                schemaVersion = `${versionSegs[0]}.${versionSegs[1]}`;
            }
            if (isODataV4PoCVersion(sdkVersion)) {
                if (!schemaVersion.endsWith(_ODataV4_PoC_Suffix)) {
                    schemaVersion += _ODataV4_PoC_Suffix;
                }
            }
            else {
                schemaVersion = _convertSchemaVersion(schemaVersion, documentProvider);
            }
        }
        return schemaVersion;
    }
    LanguageHelper.getSchemaVersion = getSchemaVersion;
    function _convertSchemaVersion(scheamVersion, documentProvider) {
        let result;
        try {
            let maxSchemaVersion = _getMaxSchemaVersion(documentProvider);
            let segs = maxSchemaVersion.split('.');
            let maxMajorVersion = parseInt(segs[0]);
            let maxMinorVersion = parseInt(segs[1]);
            segs = scheamVersion.split('.');
            if (segs.length > 1) {
                let majorVersion = parseInt(segs[0]);
                let minorVersion = parseInt(segs[1]);
                if (majorVersion >= maxMajorVersion) {
                    if (minorVersion >= maxMinorVersion) {
                        result = maxSchemaVersion;
                    }
                    else {
                        result = scheamVersion;
                    }
                }
                else if (majorVersion === 2) {
                    if (minorVersion >= 2) {
                        result = '3.0';
                    }
                    else {
                        result = '2.1';
                    }
                }
                else {
                    result = scheamVersion;
                }
            }
        }
        catch (error) {
        }
        return result ? result : '';
    }
    let _ODataV4_PoC_Suffix = '-odatav4-poc';
    function isODataV4PoCVersion(version) {
        if (version.endsWith(_ODataV4_PoC_Suffix)) {
            return true;
        }
        return false;
    }
    LanguageHelper.isODataV4PoCVersion = isODataV4PoCVersion;
    function getSchemaRootPath() {
        return path.join(utils.getRootPath(),"language-service" ,"/res/versions");
    }
    LanguageHelper.getSchemaRootPath = getSchemaRootPath;
    function findNodeSchema(node, matchingSchemas) {
        let resultSchemas = [];
        while (node) {
            if (matchingSchemas) {
                for (let i = 0; i < matchingSchemas.length; i++) {
                    let s = matchingSchemas[i];
                    if (s.node === node && !s.inverted && s.schema) {
                        resultSchemas.push(s.schema);
                    }
                }
                if (resultSchemas.length > 0) {
                    return resultSchemas;
                }
            }
            node = node.parent;
        }
        return resultSchemas;
    }
    LanguageHelper.findNodeSchema = findNodeSchema;
    function getAvailablePatterns(node, matchingSchemas) {
        let availablePatterns = [];
        let propertyName = null;
        let propertyNode;
        if (node.parent.keyNode) {
            propertyNode = node.parent;
        }
        else if (node.parent.parent.keyNode) {
            propertyNode = node.parent.parent;
        }
        if (propertyNode) {
            propertyName = propertyNode.keyNode.value;
        }
        matchingSchemas.forEach(s => {
            if ((s.node === node || s.node === propertyNode) && !s.inverted && s.schema) {
                _getAlternativePatterns(s.schema, availablePatterns, propertyName);
            }
        });
        availablePatterns = _.uniq(availablePatterns);
        return availablePatterns;
    }
    LanguageHelper.getAvailablePatterns = getAvailablePatterns;
    function _getAlternativePatterns(s, alternativePatterns, propertyName) {
        if (!s) {
            return;
        }
        if (Array.isArray(s.anyOf)) {
            s.anyOf.forEach((schema) => {
                _getAlternativePatterns(schema, alternativePatterns, propertyName);
            });
        }
        else if (s.pattern) {
            alternativePatterns.push(s.pattern);
        }
        else if (s.properties) {
            _getAlternativePatterns(s.properties[propertyName], alternativePatterns, propertyName);
        }
    }
    function getType(pattern) {
        let fileReferenceSamples = [
            ["/DummyApp/Rules/test.js", PathUtil_1.MDKFileType.Rule],
            ["/DummyApp/Actions/test.action", PathUtil_1.MDKFileType.Action],
            ["/DummyApp/Pages/test.page", PathUtil_1.MDKFileType.Page],
            ["/DummyApp/Globals/test.global", PathUtil_1.MDKFileType.Global],
            ["/DummyApp/Styles/SDKStyles.nss", PathUtil_1.MDKFileType.Style],
            ["/DummyApp/Styles/Styles.css", PathUtil_1.MDKFileType.Style],
            ["/DummyApp/Styles/LessStyles.less", PathUtil_1.MDKFileType.Style],
            ["/DummyApp/Services/test.service", PathUtil_1.MDKFileType.Service],
            ["/DummyApp/i18n/i18n.properties", PathUtil_1.MDKFileType.i18n],
            ["/DummyApp/Images/test.png", PathUtil_1.MDKFileType.Image],
            ["/DummyApp/Extensions/test.ts", PathUtil_1.MDKFileType.Extension],
            ["/DummyApp/Extensions/test.js", PathUtil_1.MDKFileType.Extension],
            ["/DummyApp/Application.app", PathUtil_1.MDKFileType.App],
            ["/DummyApp/Fragments/test.fragment", PathUtil_1.MDKFileType.Fragment]
        ];
        let regExp = new RegExp(pattern);
        let itemFound = fileReferenceSamples.find(([fileReference, type]) => regExp.test(fileReference));
        if (itemFound) {
            return itemFound[1];
        }
    }
    LanguageHelper.getType = getType;
    let Position;
    (function (Position) {
        function isEqual(first, second) {
            return first.line === second.line && first.character === second.character;
        }
        Position.isEqual = isEqual;
        function isBefore(first, second) {
            if (first.line < second.line) {
                return true;
            }
            if (second.line < first.line) {
                return false;
            }
            return first.character < second.character;
        }
        Position.isBefore = isBefore;
        function isBeforeOrEqual(first, second) {
            if (first.line < second.line) {
                return true;
            }
            if (second.line < first.line) {
                return false;
            }
            return first.character <= second.character;
        }
        Position.isBeforeOrEqual = isBeforeOrEqual;
        function isAfter(first, second) {
            return !isBeforeOrEqual(first, second);
        }
        Position.isAfter = isAfter;
    })(Position = LanguageHelper.Position || (LanguageHelper.Position = {}));
    let Range;
    (function (Range) {
        function isEqual(first, second) {
            return Position.isEqual(first.start, second.start) && Position.isEqual(first.end, second.end);
        }
        Range.isEqual = isEqual;
    })(Range = LanguageHelper.Range || (LanguageHelper.Range = {}));
    /**
     * check whether the node is in the oData binding value context
     * the following scenarios should be not are:
     * 1. OData Action children property values
     * 2. Target children property values, neither Action or Page
     *
     * @param node json metadata ast node
     */
    function isODataBindingValueContext(node) {
        if (node) {
            while (node && node.parent) {
                let parent = node.parent;
                if (parent.properties) {
                    for (const property of parent.properties) {
                        if (property.keyNode && property.keyNode.value) {
                            let keyNodeValue = property.keyNode.value;
                            if (keyNodeValue === "_Type") {
                                if (property.valueNode && property.valueNode.value.startsWith('Action.Type.ODataService')) {
                                    return false;
                                }
                            }
                            else if (keyNodeValue === "EntitySet" ||
                                keyNodeValue === "QueryOptions" ||
                                keyNodeValue === "ReadLink") {
                                return false;
                            }
                        }
                    }
                }
                node = parent;
            }
            return true;
        }
        else {
            return false;
        }
    }
    LanguageHelper.isODataBindingValueContext = isODataBindingValueContext;
    function isODataAnnotationValue(value) {
        if (value) {
            return value.startsWith('@odata.');
        }
        else {
            return false;
        }
    }
    LanguageHelper.isODataAnnotationValue = isODataAnnotationValue;
    function checkExcludeValidationConfig(context, value, configType = mdkLanguageTypes_1.ExcludeValidationConfigType.ControlName) {
        if (value && context && context.validationConfig && context.validationConfig.exclude) {
            let found = null;
            if (configType === mdkLanguageTypes_1.ExcludeValidationConfigType.I18nKey && Array.isArray(context.validationConfig.exclude.i18n)) {
                found = context.validationConfig.exclude.i18n.find((item) => {
                    if (item && item === value) {
                        return true;
                    }
                    return false;
                });
            }
            else if (configType === mdkLanguageTypes_1.ExcludeValidationConfigType.ControlName && Array.isArray(context.validationConfig.exclude.ui)) {
                if (!value.endsWith("/")) {
                    value += "/";
                }
                found = context.validationConfig.exclude.ui.find((item) => {
                    if (item && !item.endsWith("/")) {
                        item += "/";
                    }
                    if (item && value.indexOf(item) >= 0) {
                        return true;
                    }
                    return false;
                });
            }
            if (found) {
                return true;
            }
        }
        return false;
    }
    LanguageHelper.checkExcludeValidationConfig = checkExcludeValidationConfig;
})(LanguageHelper = exports.LanguageHelper || (exports.LanguageHelper = {}));
//# sourceMappingURL=LanguageHelper.js.map