"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ODataMetadataV4Service = void 0;
const _ = require("lodash");
const ts_odatajs_1 = require("ts-odatajs");
const LogUtil_1 = require("./LogUtil");
class ODataMetadataV4Service {
    constructor(xmlContent) {
        this._load(xmlContent);
    }
    getEntities() {
        let entities = [];
        if (this._metadataObject && this._metadataObject.dataServices && this._metadataObject.dataServices.schema) {
            this._metadataObject.dataServices.schema.forEach(schema => {
                let entityContainers = schema.entityContainer;
                if (entityContainers) {
                    let entitySets = entityContainers.entitySet;
                    if (entitySets) {
                        entitySets.forEach(entitySet => {
                            let entityName = entitySet.name;
                            if (entityName && entities.indexOf(entityName) < 0) {
                                entities.push(entityName);
                            }
                        });
                    }
                }
            });
        }
        return entities;
    }
    getEntityByNavigationProperty(entity, navigationProperty) {
        entity = this.removeCollectionFromEntityName(entity);
        let resultEntity = this._findEntityType(entity);
        if (resultEntity && resultEntity.navigationProperty) {
            for (let property of resultEntity.navigationProperty) {
                if (property.name === navigationProperty) {
                    return property.type;
                }
            }
        }
    }
    removeCollectionFromEntityName(entity) {
        if (entity && entity.startsWith("Collection(")) {
            entity = entity.slice('Collection('.length, -1);
        }
        return entity;
    }
    getEntityProperties(entity) {
        entity = this.removeCollectionFromEntityName(entity);
        let resultProperties = [];
        let resultEntity = this._findEntityType(entity);
        if (resultEntity) {
            if (resultEntity.property) {
                resultEntity.property.forEach(p => {
                    resultProperties.push({
                        name: p.name,
                        isNavigation: false,
                        type: p.type
                    });
                });
            }
            if (resultEntity.navigationProperty) {
                resultEntity.navigationProperty.forEach(np => {
                    resultProperties.push({
                        name: np.name,
                        isNavigation: true,
                        type: np.type
                    });
                });
            }
        }
        return resultProperties;
    }
    getFunctionsandActions() {
        let actions = [];
        if (this._metadataObject && this._metadataObject.dataServices && this._metadataObject.dataServices.schema) {
            this._metadataObject.dataServices.schema.forEach(schema => {
                let entityContainers = schema.entityContainer;
                if (entityContainers) {
                    let pendingItems = {};
                    let findItem = (items, type) => {
                        if (items) {
                            items.forEach(item => {
                                let internalName = this._stripPrefix(item[type], schema);
                                let actionFound = schema[type].find(action => action.name === internalName);
                                if (actionFound) {
                                    pendingItems[item.name] = actionFound;
                                }
                            });
                        }
                    };
                    findItem(entityContainers.actionImport, 'action');
                    findItem(entityContainers.functionImport, 'function');
                    for (let key in pendingItems) {
                        if (pendingItems.hasOwnProperty(key)) {
                            let value = pendingItems[key];
                            let actionToadd = { name: key };
                            if (value.returnType) {
                                actionToadd.returnType = this._getComplexType(value.returnType.type, true);
                            }
                            if (value.parameter) {
                                actionToadd.parameter = [];
                                value.parameter.forEach(parameter => {
                                    let parameterToadd = { name: parameter.name, type: undefined, nullable: parameter.nullable !== 'false' };
                                    parameterToadd.type = this._getComplexType(parameter.type, true);
                                    actionToadd.parameter.push(parameterToadd);
                                });
                            }
                            actions.push(actionToadd);
                        }
                    }
                }
            });
        }
        return actions;
    }
    getComplexType(type, recursive) {
        return this._getComplexType(type, recursive);
    }
    _getComplexType(type, recursive) {
        if (type.startsWith('Edm.')) {
            return { type: this._ODataTypeToJsonType(type) };
        }
        if (type.startsWith('Collection(')) {
            let elementType = type.slice('Collection('.length, -1);
            let jsonType;
            if (recursive) {
                jsonType = this._getComplexType(elementType, true);
            }
            else {
                jsonType = { type: elementType };
            }
            let result = {};
            result.type = 'array';
            result.items = jsonType;
            return result;
        }
        let result = { type: 'object', properties: {} };
        if (this._metadataObject && this._metadataObject.dataServices && this._metadataObject.dataServices.schema) {
            let schema = this._metadataObject.dataServices.schema.find(schema => {
                const _alias = schema.alias ? (schema.alias + ".") : undefined;
                const _ns = schema.namespace ? (schema.namespace + ".") : undefined;
                return type.startsWith(_alias) || type.startsWith(_ns);
            });
            let shortTypeName = this._stripPrefix(type, schema);
            if (schema && schema.enumType) {
                let enumType = schema.enumType.find(item => item.name === shortTypeName);
                if (enumType) {
                    let result = {};
                    result.type = "string";
                    result.enum = [];
                    enumType.member.forEach(item => {
                        result.enum.push(item.name);
                    });
                    return result;
                }
            }
            let complexType;
            if (schema && schema.complexType) {
                complexType = schema.complexType.find(item => item.name === shortTypeName);
            }
            if (!complexType && schema.entityType) {
                complexType = schema.entityType.find(item => item.name === shortTypeName);
            }
            if (complexType) {
                if (complexType.baseType) {
                    let baseType = this._getComplexType(complexType.baseType, recursive);
                    _.merge(result.properties, baseType.properties);
                }
                if (complexType.property) {
                    complexType.property.forEach(property => {
                        if (recursive) {
                            result.properties[property.name] = this._getComplexType(property.type, true);
                        }
                        else {
                            result.properties[property.name] = { type: property.type };
                        }
                        if (!result.properties[property.name]) {
                            console.error("error with property " + property.name);
                        }
                        if (property.nullable === 'false') {
                            if (!result.required) {
                                result.required = [];
                            }
                            result.required.push(property.name);
                        }
                    });
                }
                if (complexType.navigationProperty) {
                    complexType.navigationProperty.forEach(property => {
                        if (recursive) {
                            // result.properties[property.name] = {type: 'object'};
                        }
                        else {
                            result.properties[property.name] = { type: property.type, description: 'navigationProperty' };
                            if (!result.properties[property.name]) {
                                console.error("error with property " + property.name);
                            }
                        }
                    });
                }
                return result;
            }
        }
    }
    getTypeInSchema(type, bEntitySet, bFunction) {
        if (bEntitySet) {
            let entitySet;
            if (this._metadataObject && this._metadataObject.dataServices) {
                let schemas = this._metadataObject.dataServices.schema;
                if (schemas) {
                    for (let schema of schemas) {
                        if (schema.entityContainer && schema.entityContainer.entitySet) {
                            entitySet = schema.entityContainer.entitySet.find(item => item.name === type || item.entityType === type);
                            if (entitySet) {
                                break;
                            }
                        }
                    }
                }
            }
            if (entitySet) {
                return this._getComplexType(entitySet.entityType, false);
            }
            else {
                return;
            }
        }
        else if (bFunction) {
            let result;
            if (this._metadataObject && this._metadataObject.dataServices) {
                let schemas = this._metadataObject.dataServices.schema;
                if (schemas) {
                    for (let schema of schemas) {
                        let findItem = (items, type, name) => {
                            if (items) {
                                let result = items.find(item => item.name === name);
                                if (result) {
                                    let internalName = this._stripPrefix(result[type], schema);
                                    result = schema[type].find(action => action.name === internalName);
                                    return result;
                                }
                            }
                        };
                        if (schema.entityContainer && schema.entityContainer.functionImport) {
                            result = findItem(schema.entityContainer.functionImport, 'function', type);
                        }
                        if (!result && schema.entityContainer && schema.entityContainer.actionImport) {
                            result = findItem(schema.entityContainer.actionImport, 'action', type);
                        }
                        if (result) {
                            break;
                        }
                    }
                }
            }
            if (result && result.returnType && result.returnType.type) {
                return this._getComplexType(result.returnType.type, false);
            }
        }
        return this._getComplexType(type, false);
    }
    _ODataTypeToJsonType(odataType) {
        switch (odataType) {
            case 'Edm.Boolean':
                return 'boolean';
            case 'Edm.Decimal':
            case 'Edm.Double':
                return 'number';
            case 'Edm.Int16':
            case 'Edm.Int32':
            case 'Edm.Int64':
                return 'integer';
            default:
                return 'string';
        }
    }
    _stripPrefix(type, schema) {
        const _alias = schema.alias ? (schema.alias + ".") : undefined;
        const _ns = schema.namespace ? (schema.namespace + ".") : undefined;
        if (type.startsWith(_alias)) {
            return type.slice(_alias.length);
        }
        else if (type.startsWith(_ns)) {
            return type.slice(_ns.length);
        }
        return type;
    }
    _findEntityTypeInEntityContainer(entityContainer, entityType, findEntityType) {
        let resultEntity;
        if (entityContainer && entityContainer.entitySet) {
            entityContainer.entitySet.some(entity => {
                if (entity.name === entityType) {
                    let entityNS = entity.entityType;
                    if (entityNS) {
                        let parts = entityNS.split('.');
                        let tmpEntityType = parts.pop();
                        let tmpNamespace = parts.join('.');
                        resultEntity = findEntityType(tmpEntityType, tmpNamespace);
                    }
                    if (resultEntity) {
                        return true;
                    }
                }
            });
        }
        return resultEntity;
    }
    _findEntityTypeInSchema(schemas, entityType, namespace) {
        let resultEntity;
        for (let schema of schemas) {
            if (schema && (schema.namespace === namespace || schema.alias === namespace)) {
                let entities = schema.entityType;
                if (entities) {
                    entities.some(e => {
                        if (e.name === entityType) {
                            resultEntity = e;
                            return true;
                        }
                    });
                }
                break;
            }
        }
        return resultEntity;
    }
    _load(xmlContent) {
        try {
            if (xmlContent) {
                xmlContent = xmlContent.replace('<Edmx', '<edmx:Edmx');
                xmlContent = xmlContent.replace('</Edmx', '</edmx:Edmx');
                xmlContent = xmlContent.replace('<DataServices', '<edmx:DataServices');
                xmlContent = xmlContent.replace('</DataServices', '</edmx:DataServices');
                this._metadataObject = ts_odatajs_1.oData.parseMetadata(xmlContent);
            }
        }
        catch (error) {
            LogUtil_1.Log.error('Failed to parse odata v4 metadata: ' + xmlContent.substring(0, 256));
            LogUtil_1.Log.error('The error is: ' + error);
        }
    }
    _findResultEntry(entity) {
        let _this = this;
        let resultEntity;
        if (this._metadataObject && this._metadataObject.dataServices) {
            let schemas = this._metadataObject.dataServices.schema;
            if (schemas) {
                for (let schema of schemas) {
                    resultEntity = this._findEntityTypeInEntityContainer(schema.entityContainer, entity, (enityType, namespace) => {
                        if (namespace) {
                            return _this._findEntityTypeInSchema(schemas, enityType, namespace);
                        }
                        return _this._findEntityTypeInSchema(schemas, enityType, schema.namespace);
                    });
                    if (resultEntity) {
                        break;
                    }
                }
            }
        }
        return resultEntity;
    }
    _findEntityType(entity) {
        let resultEntity = this._findResultEntry(entity);
        if (!resultEntity) {
            let parts = entity.split('.');
            let entityType = parts.pop();
            let namespace = parts.join('.');
            if (this._metadataObject && this._metadataObject.dataServices) {
                let schemas = this._metadataObject.dataServices.schema;
                if (schemas) {
                    resultEntity = this._findEntityTypeInSchema(schemas, entityType, namespace);
                }
            }
        }
        return resultEntity;
    }
}
exports.ODataMetadataV4Service = ODataMetadataV4Service;
//# sourceMappingURL=ODataMetadataV4Service.js.map