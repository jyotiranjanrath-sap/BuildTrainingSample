"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MDKFileSystemDocumentProvider = void 0;
const fs = require("fs-extra");
const path = require("path");
const JSON_FILE_ENCODING = 'UTF-8';
const EMPTY_FILE_CONTENT = '';
const EMPTY_JSON_CONTENT = {};
class MDKFileSystemDocumentProvider {
    isExist(fileFullPath) {
        return __awaiter(this, void 0, void 0, function* () {
            // as the fs.esists has been deprecated
            return this.isExistSync(fileFullPath);
        });
    }
    isExistSync(fileFullPath) {
        return fs.existsSync(fileFullPath);
    }
    isFolder(fullPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => {
                fs.lstat(fullPath, (err, stats) => {
                    if (err) {
                        console.log(err);
                        resolve(false);
                    }
                    else {
                        resolve(stats.isDirectory());
                    }
                });
            });
        });
    }
    isFolderSync(fullPath) {
        try {
            return fs.lstatSync(fullPath).isDirectory();
        }
        catch (error) {
            console.log(error);
            return false;
        }
    }
    getDocumentModifyTime(fileFullPath) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return new Promise(resolve => {
                    fs.stat(fileFullPath, (err, stats) => {
                        if (err) {
                            console.log(err);
                            resolve(null);
                        }
                        else {
                            resolve(stats.mtime);
                        }
                    });
                });
            }
            catch (error) {
                console.log(error);
            }
        });
    }
    getDocumentModifyTimeSync(fileFullPath) {
        try {
            let stats = fs.statSync(fileFullPath);
            return stats.mtime;
        }
        catch (error) {
            console.log(error);
        }
    }
    getDocumentText(fileFullPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => {
                fs.readFile(fileFullPath, JSON_FILE_ENCODING, (err, data) => {
                    if (err) {
                        console.log(err);
                        resolve(EMPTY_FILE_CONTENT);
                    }
                    else {
                        resolve(data);
                    }
                });
            });
        });
    }
    getDocumentTextSync(fileFullPath) {
        try {
            if (this.isFolderSync(fileFullPath)) {
                return EMPTY_FILE_CONTENT;
            }
            return fs.readFileSync(fileFullPath, JSON_FILE_ENCODING);
        }
        catch (error) {
            console.log(error);
            return EMPTY_FILE_CONTENT;
        }
    }
    getDocumentJson(fileFullPath) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let text = yield this.getDocumentText(fileFullPath);
                return JSON.parse(text);
            }
            catch (error) {
                // console.log(error);
                return EMPTY_JSON_CONTENT;
            }
        });
    }
    getDocumentJsonSync(fileFullPath) {
        try {
            let text = this.getDocumentTextSync(fileFullPath);
            return JSON.parse(text);
        }
        catch (error) {
            console.log(error);
            return EMPTY_JSON_CONTENT;
        }
    }
    getChildrenFullPaths(folderFullPath, recursive) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getChildrenFullPathsSync(folderFullPath, recursive);
        });
    }
    getChildrenFullPathsSync(folderFullPath, recursive) {
        let allSubFileFullPaths = [];
        try {
            if (fs.existsSync(folderFullPath)) {
                let childrenNames = fs.readdirSync(folderFullPath);
                childrenNames.forEach(childName => {
                    let childFullPath = path.join(folderFullPath, childName);
                    let isFolder = this.isFolderSync(childFullPath);
                    if (isFolder && recursive) {
                        allSubFileFullPaths = allSubFileFullPaths.concat(this.getChildrenFullPathsSync(childFullPath, true));
                    }
                    else {
                        allSubFileFullPaths.push(childFullPath);
                    }
                }, this);
            }
        }
        catch (error) {
            console.log(error);
        }
        return allSubFileFullPaths;
    }
}
exports.MDKFileSystemDocumentProvider = MDKFileSystemDocumentProvider;
//# sourceMappingURL=MDKDocumentProvider.js.map