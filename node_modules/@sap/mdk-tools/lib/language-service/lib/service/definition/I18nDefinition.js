"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.I18nDefinition = void 0;
const jsonParser_1 = require("vscode-json-languageservice/lib/umd/parser/jsonParser");
const vscode_uri_1 = require("vscode-uri");
const LanguageHelper_1 = require("../../common/LanguageHelper");
const LogUtil_1 = require("../../common/LogUtil");
const PathUtil_1 = require("../../common/PathUtil");
const RuleHelper_1 = require("../../common/RuleHelper");
const MDKApplicationDelegate_1 = require("../../export/MDKApplicationDelegate");
const mdkLanguageTypes_1 = require("../../mdkLanguageTypes");
class I18nDefinition {
    constructor(documentProvider, appContext) {
        this._documentProvider = documentProvider;
        this._appContext = appContext;
    }
    provideDefinition(textDocument, position) {
        let fileType = PathUtil_1.PathUtil.getMDKFileType(textDocument.uri);
        let promise;
        if (fileType === PathUtil_1.MDKFileType.Rule) {
            promise = _detectI18nInRule(textDocument, position);
        }
        else {
            promise = _detectI18nInJSON(textDocument, position);
        }
        return promise.then((i18nKey) => {
            if (i18nKey) {
                let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(textDocument.uri, this._documentProvider, this._appContext ? this._appContext.referenceApps : null);
                return appDelegate.getDefaultI18nFileFullPath().then(i18nFullPath => {
                    return appDelegate.getDefaultI18nContent().then(i18nContent => {
                        if (i18nContent) {
                            const Properties = require('@js.properties/properties');
                            const options = {
                                all: true,
                                original: true,
                                eol: true,
                                location: true,
                            };
                            let output = Properties.parseToEntries(i18nContent, options);
                            if (output) {
                                for (let i = 0; i < output.length; i++) {
                                    let element = output[i];
                                    if (element.key === i18nKey) {
                                        return mdkLanguageTypes_1.Location.create(vscode_uri_1.default.file(i18nFullPath).toString(), mdkLanguageTypes_1.Range.create(mdkLanguageTypes_1.Position.create(element.location.start.line - 1, element.location.start.column - 1), mdkLanguageTypes_1.Position.create(element.location.end.line - 1, element.location.end.column - 1)));
                                    }
                                }
                            }
                        }
                    });
                });
            }
        });
    }
}
exports.I18nDefinition = I18nDefinition;
function _detectI18nInRule(textDocument, position) {
    let i18nKey = "";
    let found = false;
    try {
        let esprima = require('esprima');
        esprima.parseModule(textDocument.getText(), {
            loc: true,
            tolerant: true,
            comment: true
        }, function (node, loc) {
            if (!found && node.type === "CallExpression" && node.callee.property && node.callee.property.name === 'localizeText' && node.arguments.length >= 1 && node.arguments[0].type === "Literal") {
                let localizationKey = node.arguments[0];
                let startPosition = RuleHelper_1.RuleHelper.getPositionFromEsprimaPosition(localizationKey.loc.start);
                let endPosition = RuleHelper_1.RuleHelper.getPositionFromEsprimaPosition(localizationKey.loc.end);
                if (LanguageHelper_1.LanguageHelper.Position.isAfter(position, startPosition) && LanguageHelper_1.LanguageHelper.Position.isBefore(position, endPosition)) {
                    i18nKey = localizationKey.value;
                    found = true;
                }
            }
        });
    }
    catch (error) {
        LogUtil_1.Log.error(`Error while parsing ${vscode_uri_1.default.parse(textDocument.uri).fsPath} : ${error}`);
    }
    return Promise.resolve(i18nKey);
}
function _detectI18nInJSON(textDocument, position) {
    return Promise.resolve().then(() => {
        let i18nKey = "";
        let jsonDocument = (0, jsonParser_1.parse)(textDocument);
        let offset = textDocument.offsetAt(position);
        let node = jsonDocument.getNodeFromOffset(offset, false);
        if (node && node.type === "string" && !LanguageHelper_1.LanguageHelper.isKey(node)) {
            let nodeOffset = node.offset;
            let i18nIndicators = LanguageHelper_1.LanguageHelper.getI18nIndicators(node.value);
            if (i18nIndicators) {
                i18nIndicators.forEach(element => {
                    let localizationKey = LanguageHelper_1.LanguageHelper.getI18nKeyNode(element.indicator);
                    if (localizationKey) {
                        let shrink = 0;
                        if (localizationKey.value && localizationKey.value[0] === "'") {
                            shrink = 1;
                        }
                        let startPosition = textDocument.positionAt(localizationKey.loc.start.column + element.index + nodeOffset + shrink);
                        let endPosition = textDocument.positionAt(localizationKey.loc.end.column + element.index + nodeOffset + 2 - shrink);
                        if (LanguageHelper_1.LanguageHelper.Position.isAfter(position, startPosition) && LanguageHelper_1.LanguageHelper.Position.isBefore(position, endPosition)) {
                            i18nKey = localizationKey.value;
                            if (i18nKey && i18nKey[0] === "'") {
                                i18nKey = i18nKey.slice(1, -1);
                            }
                            return i18nKey;
                        }
                    }
                });
            }
        }
        return i18nKey;
    });
}
//# sourceMappingURL=I18nDefinition.js.map