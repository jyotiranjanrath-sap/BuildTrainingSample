"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PageSchema = void 0;
const _ = require("lodash");
const LanguageHelper_1 = require("../../common/LanguageHelper");
const LogUtil_1 = require("../../common/LogUtil");
const MDKApplicationDelegate_1 = require("../../export/MDKApplicationDelegate");
class PageSchema {
    constructor() {
        this._itemsAnyOfSchemaCache = new Map();
        this._itemsAnyOfTypeCache = new Map();
        this._unknowControlchema = null;
        this._itemsAnyOfUnknownSchemaCache = new Map();
    }
    getControlType(typeValue, schemaVersion) {
        let numSchemaVersion = Number(schemaVersion.slice(0, 3));
        if (typeValue === 'Control.Type.Extension' && numSchemaVersion >= 3.1) {
            return "Extension";
        }
        if (PageSchema.controlTypeMap.has(typeValue)) {
            return PageSchema.controlTypeMap.get(typeValue);
        }
        LogUtil_1.Log.warn('found the unsupported page type ' + typeValue);
        return null;
    }
    getSchema(doc, controlType, pageSchema, documentUri, documentProvider, context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (pageSchema && doc.root && controlType) {
                let ControlsProperties = doc.root.properties.filter(p => p.keyNode.value === 'Controls');
                if (ControlsProperties.length > 0 && ControlsProperties[0].valueNode) {
                    let schema = _.cloneDeep(pageSchema);
                    this.filterControlsSchema(schema.properties.Controls, ControlsProperties[0].valueNode, controlType + 'Controls');
                    if (controlType === "Tabs") {
                        for (let i = 0; i < schema.properties.Controls.items.length; i++) {
                            let itemSchema = schema.properties.Controls.items[i];
                            let typeValue = this.getTypeFromItemSchema(itemSchema);
                            if (typeValue && typeValue.indexOf(".SectionedTable") > 0) {
                                let newSchema = {
                                    "items": schema.properties.Controls.items[i]
                                };
                                this.filterControlsSchema(newSchema, ControlsProperties[0].valueNode, controlType + 'Sections');
                            }
                        }
                    }
                    yield this.populateFunctionSchema(doc, schema, documentUri, documentProvider, context);
                    return schema;
                }
            }
            return pageSchema;
        });
    }
    populateFunctionSchema(doc, schema, documentUri, documentProvider, context) {
        return __awaiter(this, void 0, void 0, function* () {
            let machtingSchema = doc.getMatchingSchemas(schema);
            yield Promise.all(machtingSchema.map((item) => __awaiter(this, void 0, void 0, function* () {
                if (item.node.type === 'object' && item.node.parent && item.node.parent.type === 'property' && item.node.parent.keyNode.value === 'Function') {
                    let namePropertyNode = item.node.properties.find(propertyNode => propertyNode.keyNode.value === 'Name');
                    let servicePropertyNode = item.node.parent.parent.properties.find(propertyNode => propertyNode.keyNode.value === 'Service');
                    let functionName, service;
                    if (namePropertyNode && namePropertyNode.valueNode) {
                        functionName = namePropertyNode.valueNode.value;
                    }
                    if (servicePropertyNode && servicePropertyNode.valueNode) {
                        service = servicePropertyNode.valueNode.value;
                    }
                    let referenceApps;
                    if (context) {
                        referenceApps = context.referenceApps;
                    }
                    let baseAppDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(documentUri, documentProvider, referenceApps);
                    let serviceFullPath = yield baseAppDelegate.toFileFullPath(service);
                    yield LanguageHelper_1.LanguageHelper.populateFunctionSchema(documentUri, item.schema, functionName, serviceFullPath, true);
                }
            })));
        });
    }
    filterControlsSchema(schema, node, cacheId) {
        if (schema.items && schema.items.anyOf) {
            this.replaceItemsAnyOfSchema(schema, node, cacheId);
        }
        else if (schema.items && schema.items.properties && schema.items.properties.Sections) {
            if (node.items && node.items.length > 0) {
                let sectionsProperties = [];
                let sectionProperties = [];
                for (let i = 0; i < node.items.length; i++) {
                    if (sectionsProperties.length === 0) {
                        sectionsProperties = node.items[i].properties.filter(p => p.keyNode.value === 'Sections');
                    }
                    if (sectionProperties.length === 0) {
                        sectionProperties = node.items[i].properties.filter(p => p.keyNode.value === 'Section');
                    }
                }
                if (sectionsProperties.length > 0 && sectionsProperties[0].valueNode) {
                    // this.filterSectionsSchema(schema.items.properties.Sections, sectionsProperties[0].valueNode, cacheId + 'Sections');
                    this.filterSectionsSchema(schema.items.properties.Sections.anyOf ? schema.items.properties.Sections.anyOf[0] : schema.items.properties.Sections, sectionsProperties[0].valueNode, cacheId + 'Sections');
                }
                else if (sectionProperties.length > 0 && sectionProperties[0].valueNode) {
                    this.filterSectionSchema(schema.items.properties.Section, sectionProperties[0].valueNode, cacheId + 'Sections');
                }
            }
        }
    }
    filterSectionSchema(schema, node, cacheId) {
        if (schema && schema.anyOf) {
            this.replaceAnyOfSchema(schema, node, cacheId);
            let typeValue = this.getTypeFromItemSchema(schema);
            if (typeValue === "Section.Type.FormCell") {
                let controlsProperties = node.properties.filter(p => p.keyNode.value === 'Controls');
                let controlsSchema = schema.anyOf[0].allOf.find(o => o.properties && o.properties.Controls);
                if (controlsProperties.length > 0 && controlsProperties[0].valueNode && controlsSchema) {
                    this.replaceItemsAnyOfSchema(controlsSchema.properties.Controls.anyOf ? controlsSchema.properties.Controls.anyOf[0] : controlsSchema.properties.Controls, controlsProperties[0].valueNode, cacheId + "FormCell");
                }
            }
        }
    }
    filterSectionsSchema(schema, node, cacheId) {
        if (schema.items && schema.items.anyOf) {
            this.replaceItemsAnyOfSchema(schema, node, cacheId);
            for (let i = 0; i < schema.items.length; i++) {
                let itemSchema = schema.items[i];
                let typeValue = this.getTypeFromItemSchema(itemSchema);
                if (typeValue === "Section.Type.FormCell") {
                    let controlsProperties = node.items[i].properties.filter(p => p.keyNode.value === 'Controls');
                    let controlsSchema = itemSchema.allOf.find(o => o.properties && o.properties.Controls);
                    if (controlsProperties.length > 0 && controlsProperties[0].valueNode && controlsSchema) {
                        this.replaceItemsAnyOfSchema(controlsSchema.properties.Controls.anyOf ? controlsSchema.properties.Controls.anyOf[0] : controlsSchema.properties.Controls, controlsProperties[0].valueNode, cacheId + "FormCell");
                    }
                }
            }
        }
        else if (schema.items && schema.items.properties && schema.items.properties.Controls) {
            let controlsSchema = null;
            cacheId += 'Controls';
            if (!this._itemsAnyOfSchemaCache.has(cacheId)) {
                controlsSchema = schema.items;
            }
            let controlsSchemas = [];
            for (let nodeItem of node.items) {
                if (nodeItem.properties) {
                    let controlsProperties = nodeItem.properties.filter(p => p.keyNode.value === 'Controls');
                    if (controlsProperties.length > 0 && controlsProperties[0].valueNode) {
                        if (!controlsSchema) {
                            controlsSchema = this.getControlSectionControlTemplate(schema.items);
                        }
                        // this.filterControlsSchema(controlsSchema.properties.Controls, controlsProperties[0].valueNode, cacheId);
                        this.filterControlsSchema(controlsSchema.properties.Controls.anyOf ? controlsSchema.properties.Controls.anyOf[0] : controlsSchema.properties.Controls, controlsProperties[0].valueNode, cacheId);
                        controlsSchemas.push(controlsSchema);
                        controlsSchema = null;
                    }
                    else {
                        controlsSchemas.push(this.getControlSectionControlTemplate(schema.items));
                    }
                }
                else {
                    controlsSchemas.push(this.getControlSectionControlTemplate(schema.items));
                }
            }
            if (controlsSchemas.length > 0) {
                schema.items = controlsSchemas;
            }
        }
    }
    getControlSectionControlTemplate(itemsSchema) {
        let template = _.cloneDeep(PageSchema.controlSectionControlTemplate);
        let copyiedItemsSchema = _.cloneDeep(itemsSchema);
        copyiedItemsSchema.properties.Controls = template.properties.Controls;
        return copyiedItemsSchema;
    }
    setAnyOfSchemaCache(schemaItems, cacheId) {
        if (!this._itemsAnyOfSchemaCache.has(cacheId)) {
            let itemsAnyOfSchemas = {};
            let itemsAnyOfTypes = [];
            for (let i = 0; i < schemaItems.length; i++) {
                let itemSchema = schemaItems[i];
                let typeValue = this.getTypeFromItemSchema(itemSchema);
                if (typeValue) {
                    itemsAnyOfSchemas[typeValue] = itemSchema;
                    itemsAnyOfTypes.push(this.parseSectionType(typeValue));
                }
                else if (itemSchema.type === "string" && itemSchema.pattern) {
                    itemsAnyOfSchemas[itemSchema.pattern] = itemSchema;
                }
            }
            this._itemsAnyOfSchemaCache.set(cacheId, itemsAnyOfSchemas);
            this._itemsAnyOfTypeCache.set(cacheId, itemsAnyOfTypes);
        }
    }
    replaceAnyOfSchema(schema, node, cacheId) {
        this.setAnyOfSchemaCache(schema.anyOf, cacheId);
        schema.anyOf = [];
        let itemsAnyOfSchemas = this._itemsAnyOfSchemaCache.get(cacheId);
        let itemsAnyOfTypes = this._itemsAnyOfTypeCache.get(cacheId);
        let item = node;
        if (item && item.properties) {
            let typeProperties = item.properties.filter(p => p.keyNode.value === "_Type");
            if (typeProperties && typeProperties.length > 0 && typeProperties[0].valueNode) {
                let type = typeProperties[0].valueNode.value;
                let matched = false;
                for (var key in itemsAnyOfSchemas) {
                    let regex = new RegExp(key);
                    if (regex.test(type)) {
                        let itemSchema = itemsAnyOfSchemas[key];
                        let itemSchemaCopy = _.cloneDeep(itemSchema);
                        if (type === 'Control.Type.List') {
                            this.filterControlListSchema(itemSchemaCopy, item, cacheId + 'List');
                        }
                        itemSchema = itemSchemaCopy;
                        schema.anyOf.push(itemSchema);
                        matched = true;
                        break;
                    }
                }
                if (!matched) {
                    schema.anyOf.push(this.addEmptyItemsSchema(itemsAnyOfTypes, cacheId));
                }
            }
            else {
                // do not find any matched type, and then attach the default schema
                schema.anyOf.push(this.addEmptyItemsSchema(itemsAnyOfTypes, cacheId));
            }
        }
        else if (item && item.type === "string" && item.value) {
            // schema for adding fragment to page controls
            for (var key in itemsAnyOfSchemas) {
                let regex = new RegExp(key);
                if (regex.test(item.value)) {
                    let itemSchema = itemsAnyOfSchemas[key];
                    schema.anyOf.push(itemSchema);
                    break;
                }
            }
        }
        else {
            schema.anyOf.push(this.addEmptyItemsSchema(itemsAnyOfTypes, cacheId));
        }
    }
    replaceItemsAnyOfSchema(schema, node, cacheId) {
        this.setAnyOfSchemaCache(schema.items.anyOf, cacheId);
        schema.items = [];
        let itemsAnyOfSchemas = this._itemsAnyOfSchemaCache.get(cacheId);
        let itemsAnyOfTypes = this._itemsAnyOfTypeCache.get(cacheId);
        if (node.items && node.items.length > 0) {
            for (let i = 0; i < node.items.length; i++) {
                let item = node.items[i];
                if (item && item.properties) {
                    let typeProperties = item.properties.filter(p => p.keyNode.value === "_Type");
                    if (typeProperties && typeProperties.length > 0 && typeProperties[0].valueNode) {
                        let type = typeProperties[0].valueNode.value;
                        let matched = false;
                        for (var key in itemsAnyOfSchemas) {
                            let regex = new RegExp(key);
                            if (regex.test(type)) {
                                let itemSchema = itemsAnyOfSchemas[key];
                                let itemSchemaCopy = _.cloneDeep(itemSchema);
                                if (type === 'Control.Type.List') {
                                    this.filterControlListSchema(itemSchemaCopy, item, cacheId + 'List');
                                }
                                itemSchema = itemSchemaCopy;
                                schema.items.push(itemSchema);
                                matched = true;
                                break;
                            }
                        }
                        if (!matched) {
                            schema.items.push(this.addEmptyItemsSchema(itemsAnyOfTypes, cacheId));
                        }
                    }
                    else {
                        // do not find any matched type, and then attach the default schema
                        schema.items.push(this.addEmptyItemsSchema(itemsAnyOfTypes, cacheId));
                    }
                }
                else if (item && item.type === "string" && item.value) {
                    // schema for adding fragment to page controls
                    for (var key in itemsAnyOfSchemas) {
                        let regex = new RegExp(key);
                        if (regex.test(item.value)) {
                            let itemSchema = itemsAnyOfSchemas[key];
                            schema.items.push(itemSchema);
                            break;
                        }
                    }
                }
                else {
                    schema.items.push(this.addEmptyItemsSchema(itemsAnyOfTypes, cacheId));
                }
            }
        }
        if (schema.items.length === 0) {
            schema.items.push(this.addEmptyItemsSchema(itemsAnyOfTypes, cacheId));
        }
    }
    filterControlListSchema(schema, node, cacheId) {
        let properties = node.properties.filter(p => p.keyNode.value === "ListItemContainer");
        if (properties.length > 0 && properties[0].valueNode) {
            let ListItemContainerNode = properties[0].valueNode;
            if (ListItemContainerNode && ListItemContainerNode.properties) {
                properties = ListItemContainerNode.properties.filter(p => p.keyNode.value === "Controls");
                if (properties.length > 0 && properties[0].valueNode) {
                    let controlsSchema = schema.allOf[0].anyOf[0].properties.ListItemContainer.allOf[1].properties.Controls;
                    let controls = properties[0].valueNode;
                    this.filterControlsSchema(controlsSchema, controls, cacheId + 'ListItemContainerControls');
                }
            }
        }
    }
    addEmptyItemsSchema(itemsAnyOfTypes, cacheId) {
        let unknownSchema = this._itemsAnyOfUnknownSchemaCache.get(cacheId);
        if (!unknownSchema) {
            let sectionTypes = '';
            for (let index in itemsAnyOfTypes) {
                sectionTypes += `"${itemsAnyOfTypes[index]}",`;
            }
            sectionTypes = _.trimEnd(sectionTypes, ',');
            unknownSchema = JSON.parse(`{
				"properties": {
					"_Type": {
							"enum": [
								${sectionTypes}
							],
							"type": "string"
						}
				},
				"required": ["_Type"],
				"type": "object"
			}`);
            this._itemsAnyOfUnknownSchemaCache.set(cacheId, unknownSchema);
        }
        return unknownSchema;
    }
    addUnknowControlSchema(schema) {
        if (schema && schema.properties) {
            if (!this._unknowControlchema) {
                let controlTypes = '';
                PageSchema.controlTypeMap.forEach((value, key, map) => {
                    controlTypes += `"${key}",`;
                });
                controlTypes = _.trimEnd(controlTypes, ',');
                this._unknowControlchema = JSON.parse(`{
					"properties": {
						"Controls": {
							"items": {
								"properties": {
									"_Type": {
											"enum": [ 
												${controlTypes}
											],
											"type": "string"
										}
								},
								"required": ["_Type"],
								"type": "object"
							},
							"maxItems": 1,
							"minItems": 1,
							"type": "array"
						}
					}
				}`);
            }
            _.merge(schema, this._unknowControlchema);
        }
        return schema;
    }
    getTypeFromItemSchema(itemSchema) {
        if (itemSchema && itemSchema.allOf) {
            for (let schema of itemSchema.allOf) {
                if (schema.properties && schema.properties._Type) {
                    return schema.properties._Type.pattern || schema.properties._Type.const;
                }
                if (schema.allOf) {
                    let result = this.getTypeFromItemSchema(schema);
                    if (result) {
                        return result;
                    }
                }
            }
        }
        else if (itemSchema && itemSchema.anyOf) {
            for (let schema of itemSchema.anyOf) {
                if (schema.properties && schema.properties._Type) {
                    return schema.properties._Type.pattern || schema.properties._Type.const;
                }
                let result = this.getTypeFromItemSchema(schema);
                if (result) {
                    return result;
                }
            }
        }
        else if (itemSchema && itemSchema.properties && itemSchema.properties._Type) {
            return itemSchema.properties._Type.pattern || itemSchema.properties._Type.const;
        }
        return null;
    }
    parseSectionType(pattern) {
        let sectionType = '';
        let parts = pattern.split('.');
        for (let part of parts) {
            sectionType += _.trim(part, '^\\$') + '.';
        }
        sectionType = _.trimEnd(sectionType, '.');
        return sectionType;
    }
}
exports.PageSchema = PageSchema;
PageSchema.controlTypeMap = new Map([
    ["Control.Type.FormCellContainer", "FormCell"],
    ["Control.Type.SectionedTable", "Section"],
    ["Control.Type.Extension", "Simple"],
    ["Control.Type.BottomNavigation", "BottomNavigation"],
    ["Control.Type.Tabs", "Tabs"],
    ["Control.Type.SideDrawer", "SideDrawer"],
    ["Control.Type.FlexibleColumnLayout", "MasterDetail"]
]);
PageSchema.controlSectionControlTemplate = {
    "properties": {
        "Controls": {
            "anyOf": [
                {
                    "items": {
                        "anyOf": []
                    },
                    "type": "array"
                },
                {
                    "anyOf": [
                        {
                            "properties": {
                                "_Type": {
                                    "const": "Fragment"
                                }
                            },
                            "required": ["_Type"],
                            "type": "object"
                        },
                        {
                            "pattern": "(^\/.+\/Fragments\/).*(.+\\.fragment)$|(^Fragments\/).*(.+\\.fragment)$",
                            "type": "string"
                        }
                    ]
                }
            ]
        }
    },
    "type": "object"
};
//# sourceMappingURL=PageSchema.js.map