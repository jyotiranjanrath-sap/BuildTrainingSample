"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileReferenceValidator = void 0;
const Json = require("jsonc-parser");
const _ = require("lodash");
const path = require("path");
const LanguageHelper_1 = require("../../common/LanguageHelper");
const LogUtil_1 = require("../../common/LogUtil");
const PathUtil_1 = require("../../common/PathUtil");
const RuleHelper_1 = require("../../common/RuleHelper");
const MDKApplicationDelegate_1 = require("../../export/MDKApplicationDelegate");
const MDKDefinitions_1 = require("../../export/MDKDefinitions");
const mdkLanguageTypes_1 = require("../../mdkLanguageTypes");
class FileReferenceValidator {
    constructor(documentProvider) {
        if (!documentProvider) {
            LogUtil_1.Log.error("undefined documentProvider provided for FileReferenceValidator.");
        }
        this._documentProvider = documentProvider;
        this._context = {};
    }
    isSupportDocument(document) {
        return true;
    }
    setup(document, context) {
        return __awaiter(this, void 0, void 0, function* () {
            this._context[document.uri] = Object.assign({}, context);
            let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(document.uri, this._documentProvider);
            this._currentAppInfo = yield appDelegate.getApplicationInfo();
        });
    }
    validateJsonDocument(document, jsonDocument) {
        return __awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    checkJsonNodeSync(document, node) {
        if (PathUtil_1.PathUtil.getMDKFileType(document.uri) === PathUtil_1.MDKFileType.App && LanguageHelper_1.LanguageHelper.isStringValue(node) && node.parent && node.parent.keyNode && node.parent.keyNode.value === "Path") {
            return false;
        }
        if (LanguageHelper_1.LanguageHelper.isPathSuffixValueNode(document.uri, node)) {
            return false;
        }
        if (PathUtil_1.PathUtil.getMDKFileType(document.uri) === PathUtil_1.MDKFileType.Service && node && node.parent && node.parent.keyNode && node.parent.keyNode.value === "ServiceUrl") {
            return false;
        }
        if (node && node.type === 'string' && !LanguageHelper_1.LanguageHelper.isKey(node)) {
            let jsonErrors = [];
            let jsonObj = Json.parse(document.getText(), jsonErrors);
            if (jsonObj['_Type'] === 'Action.Type.RestService.SendRequest' && node.parent && node.parent.keyNode && (node.parent.keyNode.value === 'Path' || node.parent.keyNode.value === 'OutputPath')) {
                return false;
            }
            return true;
        }
        return false;
    }
    validateJsonNode(document, node, schema) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._validateJsonNodeFileReference(document, node).then(result => {
                let diagnostics = [];
                if (result) {
                    diagnostics.push(...result);
                }
                return diagnostics;
            });
        });
    }
    checkJsNodeSync(document, node) {
        return node && node.type === "Literal" ||
            RuleHelper_1.RuleHelper.checkEsprimaNode(node, "executeAction") ||
            RuleHelper_1.RuleHelper.checkEsprimaNode(node, "getGlobalDefinition");
    }
    validateJsNode(document, node, loc) {
        return __awaiter(this, void 0, void 0, function* () {
            let results = [];
            if (node && loc) {
                if (node.type === "Literal") {
                    let literalValue = _.trim(node.value, '"\'');
                    if (PathUtil_1.PathUtil.isMDKFile(literalValue)) {
                        results.push({
                            range: RuleHelper_1.RuleHelper.getRangeFromEsprimaLocation(loc),
                            path: literalValue
                        });
                    }
                }
                else {
                    let loc = node.arguments[0].loc;
                    results.push({
                        range: RuleHelper_1.RuleHelper.getRangeFromEsprimaLocation(loc),
                        path: node.arguments[0].value
                    });
                }
            }
            return this._validateJsNodeFileReference(document, results);
        });
    }
    cleanup(document, diagnostics) {
        return __awaiter(this, void 0, void 0, function* () {
            this._context[document.uri] = null;
            return diagnostics;
        });
    }
    _validateJsNodeFileReference(document, results) {
        return __awaiter(this, void 0, void 0, function* () {
            let promises = [];
            results.forEach(result => {
                if (!!result.path) {
                    let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(document.uri, this._documentProvider, this._context[document.uri].referenceApps);
                    promises.push(appDelegate.checkFileReference(result.path).then((checkResult) => {
                        return {
                            checkResult: checkResult,
                            range: result.range,
                            path: result.path
                        };
                    }));
                }
            });
            let diagnostics = [];
            let checkedRanges = [];
            return Promise.all(promises).then(results => {
                results.forEach(result => {
                    if ((result.checkResult === MDKApplicationDelegate_1.CheckFileReferenceResult.ApplicationNotFound ||
                        result.checkResult === MDKApplicationDelegate_1.CheckFileReferenceResult.FileReferenceNotExist) &&
                        checkedRanges.findIndex(range => {
                            return LanguageHelper_1.LanguageHelper.Range.isEqual(range, result.range);
                        }) < 0) {
                        diagnostics.push(...this._buildFileReferenceProblem(document, result.path, result.range, result.checkResult === MDKApplicationDelegate_1.CheckFileReferenceResult.ApplicationNotFound));
                        checkedRanges.push(result.range);
                    }
                });
            }).then(() => {
                diagnostics.forEach(item => item.source = MDKDefinitions_1.MDKValidator.FileReference);
                return diagnostics;
            }).catch(error => {
                LogUtil_1.Log.debug(error);
                return [];
            });
        });
    }
    _validateJsonNodeFileReference(document, node) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = [];
            if (node.value.startsWith("/")) {
                let range = mdkLanguageTypes_1.Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));
                result.push(...yield this._validateFileReference(document, node.value, range));
                let problem = yield this._buildPotentialProblemForLocalizationNode(document, node);
                if (problem) {
                    result.push(problem);
                }
            }
            else if (node.value.startsWith("$(")) {
                let trimmedValue = node.value.trim();
                if (trimmedValue.endsWith(')')) {
                    trimmedValue = trimmedValue.slice(2, -1);
                }
                else {
                    trimmedValue = trimmedValue.slice(2);
                }
                let index = 2;
                let parts = trimmedValue.split(',');
                for (let i = 0; i < parts.length; i++) {
                    let part = parts[i];
                    if (part.trim().startsWith('/')) {
                        let fileReference = part.trim();
                        let range = mdkLanguageTypes_1.Range.create(document.positionAt(node.offset + index + 1), document.positionAt(node.offset + index + 1 + part.length));
                        result.push(...yield this._validateFileReference(document, fileReference, range));
                    }
                    index += part.length + 1;
                }
            }
            result.forEach(item => item.source = MDKDefinitions_1.MDKValidator.FileReference);
            return result;
        });
    }
    _validateFileReference(document, fileReference, range) {
        return __awaiter(this, void 0, void 0, function* () {
            let _this = this;
            let anchorDocumentuRIs = [document.uri];
            if (PathUtil_1.PathUtil.getMDKFileType(document.uri) === PathUtil_1.MDKFileType.CIM && this._context[document.uri].allAppFullPaths) {
                anchorDocumentuRIs = anchorDocumentuRIs.concat(this._context[document.uri].allAppFullPaths);
            }
            let promises = [];
            anchorDocumentuRIs.forEach(anchorDocumentUri => {
                let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(anchorDocumentUri, _this._documentProvider, this._context[document.uri].referenceApps);
                promises.push(appDelegate.checkFileReference(fileReference));
            });
            return Promise.all(promises).then((fileReferenceCheckArray) => __awaiter(this, void 0, void 0, function* () {
                let noApplication = true;
                let notExist = true;
                fileReferenceCheckArray.forEach(result => {
                    if (result === MDKApplicationDelegate_1.CheckFileReferenceResult.FileReferenceNotExist) {
                        noApplication = false;
                    }
                    else if (result === MDKApplicationDelegate_1.CheckFileReferenceResult.NoProblem) {
                        noApplication = false;
                        notExist = false;
                    }
                });
                let result = [];
                if (noApplication || notExist) {
                    result.push(..._this._buildFileReferenceProblem(document, fileReference, range, noApplication));
                }
                return result;
            }), (error) => {
                LogUtil_1.Log.debug(error);
                return [];
            });
        });
    }
    _buildFileReferenceProblem(document, fileReference, range, appNotFound) {
        if (appNotFound) {
            if (this._context[document.uri].referenceApps) {
                let referencedAppName = PathUtil_1.PathUtil.parseApplicationName(fileReference);
                let referenceApp = this._context[document.uri].referenceApps.find(item => item.name === referencedAppName && item.comp === this._currentAppInfo.name && (item.path === undefined || item.path === ''));
                if (referenceApp) {
                    return [];
                }
            }
        }
        let message = appNotFound ?
            ('Can not find the application: ' + PathUtil_1.PathUtil.parseApplicationName(fileReference)) :
            ('Can not find the file reference: ' + fileReference);
        let problem = mdkLanguageTypes_1.Diagnostic.create(range, message, mdkLanguageTypes_1.DiagnosticSeverity.Error);
        problem.code = appNotFound ? 'ApplicationNotFound' : 'PathNotFound';
        return [problem];
    }
    _buildPotentialProblemForLocalizationNode(document, node) {
        return __awaiter(this, void 0, void 0, function* () {
            if (PathUtil_1.PathUtil.getMDKFileType(document.uri) === PathUtil_1.MDKFileType.App && node && node.parent && node.parent.keyNode && node.parent.keyNode.value === 'Localization') {
                let referencedAppName = PathUtil_1.PathUtil.parseApplicationName(node.value);
                if (this._currentAppInfo && referencedAppName !== this._currentAppInfo.name) {
                    let i18nFolder = path.join(this._currentAppInfo.basePath, PathUtil_1.PathUtil.getFileFolder(PathUtil_1.MDKFileType.i18n));
                    let filePaths = this._documentProvider.getChildrenFullPathsSync(i18nFolder, true);
                    let existed = filePaths.some(filePath => filePath.endsWith('.' + PathUtil_1.PathUtil.getFileExtensionsFromType(PathUtil_1.MDKFileType.i18n)[0]));
                    if (existed) {
                        let range = mdkLanguageTypes_1.Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));
                        let message = `Do you want to use i18n file in current application ${this._currentAppInfo.name}?`;
                        let problem = mdkLanguageTypes_1.Diagnostic.create(range, message, mdkLanguageTypes_1.DiagnosticSeverity.Information);
                        return problem;
                    }
                }
            }
        });
    }
}
exports.FileReferenceValidator = FileReferenceValidator;
//# sourceMappingURL=FileReferenceValidator.js.map