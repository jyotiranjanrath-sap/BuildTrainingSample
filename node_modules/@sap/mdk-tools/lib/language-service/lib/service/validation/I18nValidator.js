"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.I18nValidator = void 0;
const cache_1 = require("../../cache");
const LanguageHelper_1 = require("../../common/LanguageHelper");
const LogUtil_1 = require("../../common/LogUtil");
const PathUtil_1 = require("../../common/PathUtil");
const RuleHelper_1 = require("../../common/RuleHelper");
const MDKApplicationDelegate_1 = require("../../export/MDKApplicationDelegate");
const MDKDefinitions_1 = require("../../export/MDKDefinitions");
const mdkLanguageTypes_1 = require("../../mdkLanguageTypes");
class I18nValidator {
    constructor(documentProvider) {
        if (!documentProvider) {
            LogUtil_1.Log.error("undefined documentProvider provided for I18nValidator.");
        }
        this._documentProvider = documentProvider;
        this._context = {};
    }
    isSupportDocument(document) {
        if (PathUtil_1.PathUtil.getMDKFileType(document.uri) === PathUtil_1.MDKFileType.Rule) {
            return /\.localizeText\(/.test(document.getText());
        }
        return /"\$\(L/.test(document.getText());
    }
    setup(document, context) {
        return __awaiter(this, void 0, void 0, function* () {
            this._context[document.uri] = Object.assign({}, context);
            let i18nKeys = cache_1.cache.getI18nKeys();
            if (!i18nKeys.keys && !i18nKeys.i18nError) {
                return this.getI18nKeys(document.uri).then(i18nKeys => {
                    this._context[document.uri].cachedI18nKeys = i18nKeys;
                }, error => {
                    this._context[document.uri].i18nError = error;
                });
            }
            this._context[document.uri].cachedI18nKeys = i18nKeys.keys;
            this._context[document.uri].i18nError = i18nKeys.i18nError;
        });
    }
    validateJsonDocument(document, jsonDocument) {
        return __awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    checkJsonNodeSync(document, node) {
        return (node && node.type === 'string' && !LanguageHelper_1.LanguageHelper.isKey(node) && !this.isExtensionProperty(node));
    }
    validateJsonNode(document, node, schema) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._validateJsonNodeI18n(document, node);
        });
    }
    checkJsNodeSync(document, node) {
        return (node && node.type === "CallExpression" &&
            node.callee.property && node.callee.property.name === 'localizeText' &&
            node.arguments.length >= 1 && node.arguments[0].type === "Literal");
    }
    validateJsNode(document, node, loc) {
        return __awaiter(this, void 0, void 0, function* () {
            let diagnostics = [];
            try {
                let localizationKey = node.arguments[0];
                let startPosition = RuleHelper_1.RuleHelper.getPositionFromEsprimaPosition(localizationKey.loc.start);
                let endPosition = RuleHelper_1.RuleHelper.getPositionFromEsprimaPosition(localizationKey.loc.end);
                let range = mdkLanguageTypes_1.Range.create(startPosition, endPosition);
                this._validateI18nKey(document, localizationKey.value, range, diagnostics);
            }
            catch (error) {
                LogUtil_1.Log.error(error);
            }
            diagnostics.forEach(item => item.source = MDKDefinitions_1.MDKValidator.I18n);
            return diagnostics;
        });
    }
    cleanup(document, diagnostics) {
        return __awaiter(this, void 0, void 0, function* () {
            this._context[document.uri] = null;
            return diagnostics;
        });
    }
    _validateJsonNodeI18n(document, node) {
        let result = [];
        let _this = this;
        let nodeOffset = node.offset;
        let i18nIndicators = LanguageHelper_1.LanguageHelper.getI18nIndicators(node.value);
        if (i18nIndicators) {
            i18nIndicators.forEach(element => {
                try {
                    let key_parameters = _this._getI18nKeyandParameterNum(element.indicator);
                    if (key_parameters) {
                        let startOffset = 1, endOffset = 1;
                        let i18nKey = key_parameters.key.value;
                        if (i18nKey && i18nKey[0] === "'") {
                            i18nKey = i18nKey.slice(1, -1);
                            startOffset = 2;
                            endOffset = 0;
                        }
                        let startPosition = document.positionAt(key_parameters.key.loc.start.column + element.index + nodeOffset + startOffset);
                        let endPosition = document.positionAt(key_parameters.key.loc.end.column + element.index + nodeOffset + endOffset);
                        let range = mdkLanguageTypes_1.Range.create(startPosition, endPosition);
                        _this._validateI18nKey(document, i18nKey, range, result, true, key_parameters.parmNum);
                    }
                }
                catch (error) {
                    LogUtil_1.Log.error(`Error while parsing ${element.indicator} : ${error.description}`);
                    let startPosition = document.positionAt(element.index + nodeOffset + 1);
                    let endPosition = document.positionAt(element.indicator.length + element.index + nodeOffset + 1);
                    let range = mdkLanguageTypes_1.Range.create(startPosition, endPosition);
                    result.push({
                        range: range,
                        severity: mdkLanguageTypes_1.DiagnosticSeverity.Error,
                        message: error.description
                    });
                }
            });
        }
        result.forEach(item => item.source = MDKDefinitions_1.MDKValidator.I18n);
        return Promise.resolve(result);
    }
    _getI18nKeyandParameterNum(i18nIndicator) {
        let parts = i18nIndicator.slice(2, -1).match(/('.*?'|[^',\s]+)(?=\s*,|\s*$)/g) || [];
        if (parts.length > 1 && parts[0] === 'L') {
            let i18nKey = parts[1];
            let relativeLoc = i18nIndicator.indexOf(i18nKey);
            let parmNum = 0;
            parts.splice(0, 2);
            let additionalParms = parts;
            parmNum = _validateParm(additionalParms);
            return {
                key: {
                    value: i18nKey,
                    loc: {
                        start: {
                            column: relativeLoc
                        },
                        end: {
                            column: relativeLoc + i18nKey.length
                        }
                    }
                },
                parmNum: parmNum
            };
        }
    }
    _validateI18nKey(document, i18nKey, range, result, validateParm, parmNum) {
        let _this = this;
        if (LanguageHelper_1.LanguageHelper.checkExcludeValidationConfig(this._context[document.uri], i18nKey, mdkLanguageTypes_1.ExcludeValidationConfigType.I18nKey)) {
            return;
        }
        let i18nError = this._context[document.uri].i18nError;
        if (i18nError) {
            result.push(mdkLanguageTypes_1.Diagnostic.create(range, i18nError, mdkLanguageTypes_1.DiagnosticSeverity.Error));
        }
        else {
            let i18nValue = _this.getI18nValue(document, i18nKey);
            if (i18nValue === undefined) {
                result.push({
                    range: range,
                    severity: mdkLanguageTypes_1.DiagnosticSeverity.Error,
                    message: "Can not find the i18n key: " + i18nKey,
                    code: "I18nKeyNotFound"
                });
            }
            else if (validateParm) {
                let numOfParmsNeeded = LanguageHelper_1.LanguageHelper.getNumOfParms(i18nValue);
                if (numOfParmsNeeded > parmNum) {
                    let errMsg = `Expected ${numOfParmsNeeded} arguments, but got ${parmNum}.`;
                    result.push({
                        range: range,
                        severity: mdkLanguageTypes_1.DiagnosticSeverity.Error,
                        message: errMsg
                    });
                }
            }
        }
    }
    getI18nKeys(anchorDocumentUri) {
        let appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(anchorDocumentUri, this._documentProvider, this._context[anchorDocumentUri].referenceApps);
        return appDelegate.getDefaultI18nContent().then(i18nContent => {
            let PropertiesParser = require('properties-parser');
            return PropertiesParser.parse(i18nContent);
        });
    }
    getI18nValue(document, i18nKey) {
        let cachedI18nKeys = this._context[document.uri].cachedI18nKeys;
        if (cachedI18nKeys) {
            let key = Object.keys(cachedI18nKeys).find((key) => key === i18nKey);
            if (key) {
                return cachedI18nKeys[i18nKey];
            }
        }
    }
    isExtensionProperty(node) {
        let p = node;
        while (p) {
            if (p.type === 'property' && p.keyNode.value === 'ExtensionProperties') {
                break;
            }
            p = p.parent;
        }
        return !!p;
    }
}
exports.I18nValidator = I18nValidator;
function _validateParm(additionalParms) {
    let numOfParms = 0;
    for (let i = 0; i < additionalParms.length; i++) {
        let parm = additionalParms[i];
        if (parm.startsWith("'") && parm.endsWith("'") || parm.startsWith("{") && parm.endsWith("}")) {
            numOfParms++;
        }
    }
    return numOfParms;
}
//# sourceMappingURL=I18nValidator.js.map