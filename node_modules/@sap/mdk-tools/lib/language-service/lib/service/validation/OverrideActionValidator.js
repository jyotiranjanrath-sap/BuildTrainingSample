"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OverrideActionValidator = void 0;
const _ = require("lodash");
const jsonParser_1 = require("vscode-json-languageservice/lib/umd/parser/jsonParser");
const LogUtil_1 = require("../../common/LogUtil");
const PathUtil_1 = require("../../common/PathUtil");
const MDKApplicationDelegate_1 = require("../../export/MDKApplicationDelegate");
const MDKDefinitions_1 = require("../../export/MDKDefinitions");
const mdkLanguageTypes_1 = require("../../mdkLanguageTypes");
const SchemaVersionAdapter_1 = require("../../tool/SchemaVersionAdapter");
const SchemaProvider_1 = require("../schema/SchemaProvider");
class OverrideActionValidator {
    constructor(documentProvider) {
        if (!documentProvider) {
            LogUtil_1.Log.error("undefined documentProvider provided for TargetPathValidator.");
        }
        this._documentProvider = documentProvider;
        this._appContext = {};
    }
    isSupportDocument(document) {
        let fileType = PathUtil_1.PathUtil.getMDKFileType(document.uri);
        return [
            PathUtil_1.MDKFileType.Action,
            PathUtil_1.MDKFileType.Page,
            PathUtil_1.MDKFileType.App
        ].some(eachType => eachType === fileType);
    }
    setup(document, context) {
        return __awaiter(this, void 0, void 0, function* () {
            this._appContext[document.uri] = Object.assign({}, context);
        });
    }
    validateJsonDocument(document, jsonDocument) {
        return __awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    checkJsonNodeSync(document, node) {
        return node &&
            node.type === 'object' &&
            node.parent &&
            node.parent.keyNode &&
            node.parent.keyNode.value &&
            node.parent.keyNode.value.startsWith('On') &&
            node.parent.valueNode &&
            node.parent.valueNode.type === 'object';
    }
    validateJsonNode(document, node, schema) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = [];
            let overrideActionSchema = yield this.getOverrideActionSchema(document, node);
            if (overrideActionSchema) {
                if (overrideActionSchema.properties) {
                    delete overrideActionSchema.properties["_Type"];
                }
                let targetSchema = {
                    "$schema": overrideActionSchema["$schema"],
                    "properties": overrideActionSchema["properties"],
                    "type": overrideActionSchema.type
                };
                if (schema && schema["properties"] && schema["properties"]["Properties"]) {
                    schema["properties"]["Properties"] = targetSchema;
                }
                else {
                    schema = {
                        "properties": {
                            "Properties": targetSchema
                        }
                    };
                }
                let jsonDocument = new jsonParser_1.JSONDocument(node);
                let diagnostics = jsonDocument.validate(document, schema);
                if (diagnostics && diagnostics.length > 0) {
                    diagnostics.forEach(item => {
                        result.push({
                            range: item.range,
                            severity: mdkLanguageTypes_1.DiagnosticSeverity.Error,
                            message: item.message
                        });
                    });
                }
            }
            result.forEach(item => item.source = MDKDefinitions_1.MDKValidator.OverrideAction);
            return result;
        });
    }
    checkJsNodeSync(document, node) {
        return false;
    }
    validateJsNode(document, node, loc) {
        return __awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    cleanup(document, diagnostics) {
        return __awaiter(this, void 0, void 0, function* () {
            this._appContext[document.uri] = null;
            return diagnostics;
        });
    }
    _getOverrideActionName(node) {
        let actionName;
        if (node && node.type === 'object' && node.properties) {
            for (let i = 0; i < node.properties.length; i++) {
                let property = node.properties[i];
                if (this._isStringASTNodeWithName(property.keyNode, 'Name')) {
                    if (property.valueNode && property.valueNode.type === 'string' && property.valueNode.value) {
                        actionName = property.valueNode.value;
                        if (!_.isEmpty(actionName)) {
                            return actionName;
                        }
                    }
                }
            }
        }
        return null;
    }
    getOverrideActionSchema(document, node) {
        return __awaiter(this, void 0, void 0, function* () {
            let actionName = this._getOverrideActionName(node);
            if (actionName) {
                let referenceApps;
                if (this._appContext[document.uri]) {
                    referenceApps = this._appContext[document.uri].referenceApps;
                }
                let baseAppDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(document.uri, this._documentProvider, referenceApps);
                let overrideActionFullPath = yield baseAppDelegate.toFileFullPath(actionName);
                let actionType = baseAppDelegate.getSchemaTypeByFilePath(overrideActionFullPath);
                if (actionType) {
                    let schemaVersion = yield SchemaVersionAdapter_1.SchemaVersionHelper.getApplicationSchemaVersion(document.uri);
                    let overrideActionSchema = yield SchemaProvider_1.SchemaProvider.getInstance(schemaVersion).getSchemaByActionType(actionType);
                    return overrideActionSchema;
                }
                return Promise.resolve();
            }
            return Promise.resolve();
        });
    }
    _isStringASTNodeWithName(node, name) {
        if (node && node.type === 'string' && node.value === name) {
            return true;
        }
        return false;
    }
}
exports.OverrideActionValidator = OverrideActionValidator;
//# sourceMappingURL=OverrideActionValidator.js.map