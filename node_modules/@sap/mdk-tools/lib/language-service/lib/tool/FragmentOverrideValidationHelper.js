"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FragmentOverrideValidationHelper = void 0;
const Json = require("jsonc-parser");
const _ = require("lodash");
const MDKApplicationDelegate_1 = require("../export/MDKApplicationDelegate");
const MDKDocumentProvider_1 = require("../export/MDKDocumentProvider");
const mdkLanguageTypes_1 = require("../mdkLanguageTypes");
let jsonParser = require('vscode-json-languageservice/lib/umd/parser/jsonParser.js');
const unncessaryTypes = [
    "Control.Type.ActionBarItem",
    "Control.Type.SectionTimelineCell",
    "Control.Type.SectionTimelinePreviewCell",
    "Control.Type.SectionObjectCell",
    "Control.Type.ObjectCell",
    "Control.Type.KPIItem",
    "Control.Type.KeyValue",
    "Control.Type.SectionImageCell",
    "Control.Type.SectionSimplePropertyCell",
    "Control.Type.GridRowItem",
    "Control.Type.DataTableColumnItem",
    "Control.Type.DataTableHeaderItem",
    "Control.Type.ContactCellItem",
    "Section.Type.Button",
    "Control.Type.SideDrawerSection"
];
class FragmentOverrideValidationHelper {
    constructor(oContext) {
        this.hasFragment = false;
        this.hasComplexFragment = false;
        this.overridePathMap = new Map();
        this.context = oContext;
        this.documentProvider = new MDKDocumentProvider_1.MDKFileSystemDocumentProvider();
    }
    resolve(document, jsonDocument) {
        return __awaiter(this, void 0, void 0, function* () {
            let content = document.getText();
            this.hasFragment = this.testFragment(content);
            this.hasComplexFragment = this.testComplexFragment(content);
            if (this.hasFragment || this.hasComplexFragment) {
                this.appDelegate = new MDKApplicationDelegate_1.MDKApplicationDelegate(document.uri, this.documentProvider, this.context[document.uri] ? this.context[document.uri].referenceApps : undefined);
                const jsonObj = JSON.parse(content);
                yield this.resolveFragmentContent(jsonObj);
                this.document = mdkLanguageTypes_1.TextDocument.create(document.uri, 'com.sap.mdk', 1.0, JSON.stringify(jsonObj, null, "\t"));
                this.jsonDocument = jsonParser.parse(this.document);
            }
            else {
                this.document = document;
                this.jsonDocument = jsonDocument;
            }
        });
    }
    convertDiagnosticRange(document, jsonDocument, diagnostic) {
        let offsetNew = this.document.offsetAt(diagnostic.range.start);
        let nodeNew = this.jsonDocument.getNodeFromOffset(offsetNew);
        let jsonPath = jsonParser.getNodePath(nodeNew);
        let jsonPathStr = jsonPath.join('|');
        if (this.overridePathMap.has(jsonPathStr)) {
            jsonPath = this.overridePathMap.get(jsonPathStr);
        }
        let node = Json.findNodeAtLocation(jsonDocument.root, jsonPath);
        if (node) {
            let range = mdkLanguageTypes_1.Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));
            diagnostic.range = range;
            return diagnostic;
        }
        return null;
    }
    keyToSegment(key) {
        let type = Number(key);
        return isNaN(type) ? key : type;
    }
    testFragment(content) {
        const regexp = /\"([\/_a-zA-Z0-9\.]*\.fragment)\"/g;
        return false; //regexp.test(content);
    }
    testComplexFragment(content) {
        const regexp = /\"_Type\":\s*\"Fragment\"/g;
        return regexp.test(content);
    }
    resolveFragmentContent(obj, jsonPath = []) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let property in obj) {
                if (obj.hasOwnProperty(property)) {
                    const value = obj[property];
                    if (value && typeof value === "object") {
                        if (value.hasOwnProperty("_Type") && value["_Type"] === "Fragment") {
                            const fragmentPath = value.Fragment;
                            const sPath = yield this.appDelegate.toFileFullPath(fragmentPath);
                            let fragmentContent = this.documentProvider.getDocumentTextSync(sPath);
                            if (fragmentContent) {
                                // if (hasFragment(fragmentContent)) {
                                // 	fragmentContent = resolveFragment(dir, fragmentContent);
                                // }
                                const properties = value.Properties;
                                const namedProperties = {};
                                const indexedProperties = {};
                                for (const key in properties) {
                                    if (properties.hasOwnProperty(key)) {
                                        if (key.startsWith("#Index:")) {
                                            const index = key.substring(7);
                                            indexedProperties[index] = properties[key];
                                            delete properties[key];
                                        }
                                        else if (key.startsWith("#Name:")) {
                                            const name = key.substring(6);
                                            namedProperties[name] = properties[key];
                                            delete properties[key];
                                        }
                                    }
                                }
                                // 1. merge new properties
                                const fragmentObj = _.merge(JSON.parse(fragmentContent), properties);
                                // const isArrayType = Array.isArray(obj) && Array.isArray(fragmentObj);
                                // 2. override properties by name
                                this.overrideNamedProperties(fragmentObj, namedProperties, jsonPath.concat(property), jsonPath.concat([this.keyToSegment(property), "Properties"]));
                                // 3. override properties by index
                                this.overrideIndexedProperties(fragmentObj, indexedProperties, jsonPath.concat(property), jsonPath.concat([this.keyToSegment(property), "Properties"]));
                                // 4. remove all null properties
                                this.removeUnnecessaryType(fragmentObj);
                                // 5. set overridePathMap
                                this.setOverridePathMap(fragmentObj, properties, jsonPath.concat(property), jsonPath.concat([this.keyToSegment(property), "Properties"]));
                                obj[property] = this.removeNullProperties(fragmentObj);
                                // const _obj = this.removeNullProperties(fragmentObj);
                                // if (isArrayType && fragmentObj.length > 0) {
                                // 	obj[property] = fragmentObj[0];
                                // 	fragmentObj.shift();
                                // 	obj.splice(+property + 1, 0, ...fragmentObj);
                                // } else {
                                // 	obj[property] = _obj;
                                // }
                            }
                        }
                    }
                    else if (value && typeof value === "string" && this.testFragment('"' + value + '"')) {
                        const sPath = yield this.appDelegate.toFileFullPath(value);
                        let fragmentContent = this.documentProvider.getDocumentTextSync(sPath);
                        if (fragmentContent) {
                            const fragmentObj = JSON.parse(fragmentContent);
                            this.removeUnnecessaryType(fragmentObj);
                            this.setFragmentPathMap(fragmentObj, jsonPath.concat(this.keyToSegment(property)));
                            obj[property] = this.removeNullProperties(fragmentObj);
                            // const _obj = this.removeNullProperties(fragmentObj);
                            // const isArrayType = Array.isArray(obj) && Array.isArray(fragmentObj);
                            // if (isArrayType && fragmentObj.length > 0) {
                            // 	obj[property] = fragmentObj[0];
                            // 	fragmentObj.shift();
                            // 	obj.splice(+property + 1, 0, ...fragmentObj);
                            // } else {
                            // 	obj[property] = _obj;
                            // }
                        }
                    }
                    const sValue = JSON.stringify(obj[property]);
                    if (this.testFragment(sValue) || this.testComplexFragment(sValue)) {
                        yield this.resolveFragmentContent(obj[property], jsonPath.concat(this.keyToSegment(property)));
                    }
                }
            }
        });
    }
    setOverridePathMap(fragmentObj, propertiesObj, jsonPathNew, jsonPathOri) {
        for (const key in fragmentObj) {
            if (fragmentObj.hasOwnProperty(key) && propertiesObj && propertiesObj.hasOwnProperty(key)) {
                let value = fragmentObj[key];
                let mapKey = jsonPathNew.concat(key).join('|');
                this.overridePathMap.set(mapKey, jsonPathOri.concat(this.keyToSegment(key)));
                if (value && typeof value === "object") {
                    this.setOverridePathMap(value, propertiesObj[key], jsonPathNew.concat(key), jsonPathOri.concat(this.keyToSegment(key)));
                }
            }
        }
    }
    setFragmentPathMap(fragmentObj, jsonPath) {
        for (const key in fragmentObj) {
            if (fragmentObj && fragmentObj.hasOwnProperty(key)) {
                let value = fragmentObj[key];
                let mapKey = jsonPath.concat(key).join('|');
                this.overridePathMap.set(mapKey, jsonPath);
                if (value && typeof value === "object") {
                    this.setFragmentPathMap(value, jsonPath);
                }
            }
        }
    }
    overrideNamedProperties(obj, properties, jsonPathNew, jsonPathOri) {
        if (Object.keys(properties).length > 0) {
            for (let key in obj) {
                if (obj.hasOwnProperty(key)) {
                    const value = obj[key];
                    if (value && typeof value === "object") {
                        if (value.hasOwnProperty("_Name")) {
                            const name = value["_Name"];
                            for (const n in properties) {
                                if (properties.hasOwnProperty(n) && n === name) {
                                    obj[key] = _.merge(value, properties[n]);
                                    this.setOverridePathMap(value, properties[n], jsonPathNew.concat(key), jsonPathOri.concat("#Name:" + n));
                                    delete properties[n];
                                }
                            }
                        }
                        this.overrideNamedProperties(value, properties, jsonPathNew, jsonPathOri);
                    }
                }
            }
        }
    }
    overrideIndexedProperties(obj, properties, jsonPathNew, jsonPathOri) {
        if (Object.keys(properties).length > 0) {
            for (let key in obj) {
                if (obj.hasOwnProperty(key)) {
                    const value = obj[key];
                    if (value && typeof value === "object") {
                        for (const n in properties) {
                            if (properties.hasOwnProperty(n)) {
                                obj[key] = _.merge(value, properties[n]);
                                this.setOverridePathMap(value, properties[n], jsonPathNew.concat(key), jsonPathOri.concat("#Index:" + n));
                                delete properties[n];
                            }
                        }
                        this.overrideIndexedProperties(value, properties, jsonPathNew, jsonPathOri);
                    }
                }
            }
        }
    }
    removeNullProperties(obj) {
        for (let key in obj) {
            if (obj.hasOwnProperty(key)) {
                const value = obj[key];
                if (value === null) {
                    delete obj[key];
                }
                else if (value && typeof value === "object") {
                    this.removeNullProperties(value);
                }
            }
        }
        return obj;
    }
    removeUnnecessaryType(obj) {
        for (let key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (key === "_Type" && unncessaryTypes.indexOf(obj[key]) >= 0) {
                    delete obj[key];
                }
                else {
                    const value = obj[key];
                    if (value && typeof value === "object") {
                        this.removeUnnecessaryType(value);
                    }
                }
            }
        }
    }
}
exports.FragmentOverrideValidationHelper = FragmentOverrideValidationHelper;
//# sourceMappingURL=FragmentOverrideValidationHelper.js.map