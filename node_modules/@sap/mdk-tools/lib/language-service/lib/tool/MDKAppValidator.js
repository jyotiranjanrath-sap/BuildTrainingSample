"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitApplication = exports.validate = exports.visitMDKFile = exports.visitExtension = exports.checkUnused = void 0;
const path = require("path");
const vscode_uri_1 = require("vscode-uri");
const cache_1 = require("../cache");
const PathUtil_1 = require("../common/PathUtil");
const MDKDocumentProvider_1 = require("../export/MDKDocumentProvider");
const mdkLanguageService_1 = require("../mdkLanguageService");
const mdkLanguageTypes_1 = require("../mdkLanguageTypes");
const DiagnosticFormatter_1 = require("./DiagnosticFormatter");
const ValidationLogger_1 = require("./ValidationLogger");
let g_usedFiles = [];
let g_cachedFiles = [];
function checkUnused(appPath, extPath, context, output, ignoredFiles) {
    return __awaiter(this, void 0, void 0, function* () {
        g_usedFiles = [];
        g_cachedFiles = [];
        context = handleContext(context);
        try {
            //await cache.refresh(PathUtil.buildApplicationPath(appPath), context.documentProvider, context.referenceApps);
            let languageService = (0, mdkLanguageService_1.getLanguageService)({
                documentProvider: context.documentProvider,
                sdkVersion: context.sdkVersion,
                logger: context.logger
            });
            output.append('[MDK check unused file]: Start checking the application ');
            let allFiles = context.documentProvider.getChildrenFullPathsSync(path.dirname(appPath), true);
            return visitMDKFile(languageService, appPath, context, output).then(results => {
                return visitExtension(languageService, appPath, extPath, context, output).then(results => {
                    if (g_usedFiles.length > 0) {
                        g_usedFiles.unshift(appPath.toLocaleLowerCase());
                        const unusedFiles = getUnusedFiles(appPath, allFiles, ignoredFiles);
                        //const unusedFilesBuffer = unusedFiles.sort((a, b) => a.charAt(a.length-1) > b.charAt(b.length-1) ? 1 : -1).map(item => { return `${item}`; });
                        const unusedFilesBuffer = unusedFiles.sort();
                        //let buffer = `-------- All Files: ${allFiles.length}   Used Files: ${g_usedFiles.length} --------\n` + g_usedFiles.join('\n');
                        let buffer = `-------- All Files: ${allFiles.length}   Unused Files: ${unusedFiles.length} --------\n` + unusedFilesBuffer.join('\n');
                        //fs.writeFileSync(logFile, buffer);
                        output.appendLine('\n[MDK check unused file]: ' + buffer);
                        output.appendLine('[MDK check unused file]: End checking the application.');
                        return Promise.resolve(true);
                    }
                });
            }, error => {
                return Promise.reject(`Visiting the application ${appPath} failed with ${error}`);
            });
        }
        catch (error) {
            return Promise.reject(`Validating the application ${appPath} failed with ${error}`);
        }
    });
}
exports.checkUnused = checkUnused;
function getUnusedFiles(appPath, allFiles, ignoredFiles) {
    let unusedFiles = allFiles.filter(item => {
        return !g_usedFiles.includes(item.toLocaleLowerCase())
            && !item.match(/\/i18n_.+\.properties$/gi)
            && !item.match(/\/Images\//gi)
            && !item.match(/\/Objects\//gi)
            && !item.match(/\/Extensions\//gi)
            && !item.match(/\/Web\//gi)
            && !item.match(/\/.vscode\//gi);
    });
    //let ignoredFiles = vscode.workspace.getConfiguration().get<[]>('mdk.ignoredFiles');
    if (ignoredFiles) {
        ignoredFiles.map(item => {
            if (item.indexOf("*.") === 0) {
                const extName = item.substr(1);
                var i = unusedFiles.length;
                for (i = unusedFiles.length - 1; i >= 0; --i) {
                    if (unusedFiles[i].lastIndexOf(extName) >= 1) {
                        unusedFiles.splice(i, 1);
                    }
                }
            }
            else {
                const ignoredFile = path.resolve(path.dirname(appPath), item);
                const index = unusedFiles.indexOf(ignoredFile);
                if (index > -1) {
                    unusedFiles.splice(index, 1);
                }
            }
        });
    }
    return unusedFiles;
}
function visitExtension(languageService, appPath, extPath, context, output) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            let allFiles = [];
            if (extPath) {
                allFiles = context.documentProvider.getChildrenFullPathsSync(extPath, true);
            }
            let allFilepromises = [];
            allFiles.forEach(item => {
                let content = context.documentProvider.getDocumentTextSync(item);
                let uri = vscode_uri_1.default.file(item);
                let document = mdkLanguageTypes_1.TextDocument.create(uri.toString(), 'com.sap.mdk', 1.0, content);
                allFilepromises.push(languageService.doCheckUnusedFile(document, context).then(fileList => {
                    let promises = [];
                    fileList.forEach(filePath => {
                        if (filePath.length > 0) {
                            promises.push(visitMDKFile(languageService, filePath, context, output));
                        }
                    });
                    return Promise.all(promises).then(() => {
                        fileList.forEach(item => {
                            if (!g_usedFiles.includes(item.toLocaleLowerCase())) {
                                g_usedFiles.push(item.toLocaleLowerCase());
                            }
                        });
                        return Promise.resolve(g_usedFiles);
                    });
                }, error => {
                    return Promise.reject(`Visiting the application ${appPath} failed with ${error}`);
                }));
            });
            return Promise.all(allFilepromises).then(() => {
                return Promise.resolve(g_usedFiles);
            });
        }
        catch (error) {
            return Promise.reject(`Validating the application ${appPath} failed with ${error}`);
        }
    });
}
exports.visitExtension = visitExtension;
function visitMDKFile(languageService, appPath, context, output) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (!g_cachedFiles.includes(appPath.toLocaleLowerCase())) {
                g_cachedFiles.push(appPath.toLocaleLowerCase());
                output.append('.');
                let content = context.documentProvider.getDocumentTextSync(appPath);
                let uri = vscode_uri_1.default.file(appPath);
                let document = mdkLanguageTypes_1.TextDocument.create(uri.toString(), 'com.sap.mdk', 1.0, content);
                return languageService.doCheckUnusedFile(document, context).then(fileList => {
                    let promises = [];
                    fileList.forEach(filePath => {
                        if (filePath.length > 0) {
                            promises.push(visitMDKFile(languageService, filePath, context, output));
                        }
                    });
                    return Promise.all(promises).then(() => {
                        fileList.forEach(item => {
                            if (!g_usedFiles.includes(item.toLocaleLowerCase())) {
                                g_usedFiles.push(item.toLocaleLowerCase());
                            }
                        });
                        return Promise.resolve(g_usedFiles);
                    });
                }, error => {
                    return Promise.reject(`Visiting the application ${appPath} failed with ${error}`);
                });
            }
            else {
                return Promise.resolve([]);
            }
        }
        catch (error) {
            return Promise.reject(`Validating the application ${appPath} failed with ${error}`);
        }
    });
}
exports.visitMDKFile = visitMDKFile;
function validate(appPath, context) {
    return __awaiter(this, void 0, void 0, function* () {
        context = handleContext(context);
        try {
            yield cache_1.cache.refresh(PathUtil_1.PathUtil.buildApplicationPath(appPath), context.documentProvider, context.referenceApps);
            let languageService = (0, mdkLanguageService_1.getLanguageService)({
                documentProvider: context.documentProvider,
                sdkVersion: context.sdkVersion,
                logger: context.logger
            });
            // let schemaVersion = await SchemaVersionHelper.getApplicationSchemaVersion(appPath);
            // context.logger.logVailationStart(appPath, SchemaProvider.getInstance(schemaVersion).schemaVersion);
            return visitApplication(languageService, appPath, context).then(diagnostics => {
                let issues = countIssues(diagnostics);
                let errors = issues.errors;
                let warnings = issues.warnings;
                context.logger.logValidationEnd(errors, warnings);
                if (diagnostics && diagnostics.length > 0) {
                    let logger = context.logger;
                    if (logger) {
                        logger.outputDiagnostics();
                    }
                }
                return Promise.resolve(errors === 0);
            }, error => {
                return Promise.reject(`Visiting the application ${appPath} failed with ${error}`);
            });
        }
        catch (error) {
            return Promise.reject(`Validating the application ${appPath} failed with ${error}`);
        }
    });
}
exports.validate = validate;
function handleContext(context) {
    if (!context) {
        context = {};
    }
    if (!context.documentProvider) {
        context.documentProvider = new MDKDocumentProvider_1.MDKFileSystemDocumentProvider();
    }
    if (!context.logger) {
        context.logger = new ValidationLogger_1.ValidationLogger(context.logLevel);
    }
    if (!context.diagnosticFormatter) {
        context.diagnosticFormatter = new DiagnosticFormatter_1.DiagnosticFormatter();
    }
    return context;
}
function visitApplication(languageService, appPath, context) {
    context.logger.debug('visit application ' + appPath);
    let promises = [];
    let excludeFolders = [
        "Web",
        ".che",
        ".typings",
        // "Extensions",
        "i18n",
        "Images",
        "Objects",
        "Styles"
    ];
    let parseDirectory = (directory, visit) => {
        context.logger.debug('visit directory ' + directory);
        let items = context.documentProvider.getChildrenFullPathsSync(directory, false);
        for (let item of items) {
            let excludeFolder = excludeFolders.find(exclude => { return item === path.join(appPath, exclude); });
            if (excludeFolder) {
                continue;
            }
            if (context.documentProvider.isFolderSync(item)) {
                parseDirectory(item, visit);
            }
            else {
                let promise = visitDocument(languageService, item, context);
                if (promise) {
                    promises.push(promise);
                }
            }
        }
    };
    parseDirectory(appPath, visitDocument);
    return limitThen(promises, 3);
}
exports.visitApplication = visitApplication;
function limitThen(promises, max) {
    if (!promises || promises.length === 0) {
        return Promise.resolve([]);
    }
    let diagnostics = [];
    return Promise.all(promises.slice(0, max)).then(results => {
        results.forEach(result => {
            if (result) {
                diagnostics.push(...result);
            }
        });
        promises.splice(0, max);
        return limitThen(promises, max).then(result => {
            diagnostics.push(...result);
            return Promise.resolve(diagnostics);
        });
    }).catch(error => {
        return Promise.reject(error);
    });
}
function visitDocument(languageService, docPath, context) {
    context.logger.debug('visit directory ' + docPath);
    let type = PathUtil_1.PathUtil.getMDKFileType(docPath);
    if ([
        PathUtil_1.MDKFileType.Action,
        PathUtil_1.MDKFileType.Page,
        PathUtil_1.MDKFileType.Rule,
        PathUtil_1.MDKFileType.Global,
        PathUtil_1.MDKFileType.Service,
        PathUtil_1.MDKFileType.App,
        PathUtil_1.MDKFileType.CIM,
        PathUtil_1.MDKFileType.Fragment,
        PathUtil_1.MDKFileType.ExtensionMetadata,
        PathUtil_1.MDKFileType.MergeMap
    ].some(t => t === type)) {
        let uri = vscode_uri_1.default.file(docPath);
        return context.documentProvider.getDocumentText(docPath).then(function (content) {
            let document = mdkLanguageTypes_1.TextDocument.create(uri.toString(), 'com.sap.mdk', 1.0, content);
            return languageService.doValidation(document, context).then(diagnostics => {
                logDiagnostics(document, diagnostics, context);
                return diagnostics;
            });
        });
    }
}
function countIssues(diagnostics) {
    let errors = 0;
    let warnings = 0;
    diagnostics.forEach(diagnostic => {
        if (diagnostic.severity) {
            if (diagnostic.severity === mdkLanguageTypes_1.DiagnosticSeverity.Error) {
                errors++;
            }
            else if (diagnostic.severity === mdkLanguageTypes_1.DiagnosticSeverity.Warning) {
                warnings++;
            }
        }
    });
    return {
        errors: errors,
        warnings: warnings
    };
}
function logDiagnostics(document, diagnostics, context) {
    diagnostics.forEach(diagnostic => {
        logDiagnostic(document, diagnostic, context);
    });
}
function logDiagnostic(document, diagnostic, context) {
    let diagnosticInfo = new DiagnosticFormatter_1.DiagnosticInfo(diagnostic, vscode_uri_1.default.parse(document.uri).fsPath);
    let content = context.diagnosticFormatter.write(diagnosticInfo);
    let logger = context.logger;
    if (logger) {
        logger.logDiagnostic(content);
    }
    else {
        context.logger.error(content);
    }
}
//# sourceMappingURL=MDKAppValidator.js.map