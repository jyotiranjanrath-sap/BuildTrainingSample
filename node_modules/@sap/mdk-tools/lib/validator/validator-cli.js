#!/usr/bin/env node
const path = require('path');
const fs = require('fs-extra');
const Logger = require('../logger');
const timestamp = require('console-timestamp');
const valiator = require('../language-service/lib/tool/MDKAppValidator');
const ChalkValidationLogger = require('./chalk-validation-logger').ChalkValidationLogger;
const DiagnosticFormatter = require('../language-service/lib/tool/DiagnosticFormatter').DiagnosticFormatter;
const validatorArgs = require('./validator-args');

let resultFilePath = validatorArgs.logFile();
if (!resultFilePath && !fs.existsSync(resultFilePath)) {
	resultFilePath = null;
	console.log(Logger.getWarn('Missing temp path and then cannot get the detail information about diagnostics.'));
}

function doValidate(test) {
	console.log("\n" + '[hh:mm:ss]'.timestamp + Logger.getPrompt(" -- validating --"));

	let diagnosticFormatter = new DiagnosticFormatter();
	let logger = new ChalkValidationLogger(resultFilePath, diagnosticFormatter, validatorArgs.logLevel());
	let context = {
		logger: logger,
		sdkVersion: validatorArgs.sdkVersion(),
		platform: validatorArgs.platform()
	};
	context.diagnosticFormatter = diagnosticFormatter;

	logger.start(validatorArgs.project(), validatorArgs.sdkVersion());

	let ok = true;
	let error = false;
	let promises = [];
	let thenable;

	let appFullPaths = validatorArgs.allAppFullPaths();
	if (appFullPaths) {
		if (isWin()) {
			appFullPaths = appFullPaths.replace(/\$/g, '"');
		}
		context.appFullPaths = JSON.parse(appFullPaths);
	}
	let referenceApplications = validatorArgs.referenceApplications();
	if (referenceApplications) {
		if (isWin()) {
			referenceApplications = referenceApplications.replace(/\$/g, '"');
		}
		referenceApplications = JSON.parse(referenceApplications);
	}

	let appBasePath = validatorArgs.project();
	if (referenceApplications) {
		context.referenceApps = referenceApplications[path.join(appBasePath, 'Application.app')];
	}
	thenable = valiator.validate(appBasePath, context);

	if (validatorArgs.cimApps()) {
		let cimAppPaths = validatorArgs.cimApps().split(';');
		cimAppPaths.forEach(cimAppBasePath => {
			if (!!cimAppBasePath) {
				let contextForComponent = Object.assign({}, context);
				if (referenceApplications) {
					contextForComponent.referenceApps = referenceApplications[path.join(cimAppBasePath, 'Application.app')];
				}
				promises.push(valiator.validate(cimAppBasePath, contextForComponent));
			}
		});
	}

	promises.push(Promise.resolve());

	promises.forEach(promise => {
		thenable = thenable.then(result => {
			ok = ok && result;
			return promise;
		}, err => {
			if (err) {
				error = true;
				logger.error(Logger.getError(err));
			}
		});
	});

	return thenable.then(() => {
		if (error) {
			if (!!test) {
				return Promise.resolve(false);
			} else {
				process.exit(-1);
			}
		}

		logger.end();
		if (ok) {
			return Promise.resolve(ok);
		} else {
			if (!!test) {
				return Promise.resolve(false);
			} else {
				process.exit(1);
			}
		}
	});
}

function isWin() {
	const os = require('os');
	const platform = os.platform();
	return platform === 'win32';
}

module.exports = { doValidate };